<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MeasureFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">org.uma.jmetal:jmetal-core</a> &gt; <a href="index.source.html" class="el_package">org.uma.jmetal.measure.impl</a> &gt; <span class="el_source">MeasureFactory.java</span></div><h1>MeasureFactory.java</h1><pre class="source lang-java linenums">package org.uma.jmetal.measure.impl;

import org.uma.jmetal.measure.Measure;
import org.uma.jmetal.measure.MeasureListener;
import org.uma.jmetal.measure.PullMeasure;
import org.uma.jmetal.measure.PushMeasure;
import org.uma.jmetal.util.JMetalException;

import java.lang.ref.WeakReference;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

/**
 * The {@link MeasureFactory} provides some useful methods to build specific
 * {@link Measure}s.
 * 
 * @author Matthieu Vergne &lt;matthieu.vergne@gmail.com&gt;
 * 
 */
<span class="fc" id="L24">public class MeasureFactory {</span>

<span class="fc" id="L26">	private final Logger log = Logger.getLogger(MeasureFactory.class.getName());</span>

	/**
	 * Create a {@link PullMeasure} to backup the last {@link Value} of a
	 * {@link PushMeasure}. When the {@link PushMeasure} send a notification
	 * with a given {@link Value}, this {@link Value} is stored into a variable
	 * so that it can be retrieved at any time through the method
	 * {@link PullMeasure#get()}.
	 * 
	 * @param push
	 *            a {@link PushMeasure} to backup
	 * @param initialValue
	 *            the {@link Value} to return before the next notification of
	 *            the {@link PushMeasure} is sent
	 * @return a {@link PullMeasure} allowing to retrieve the last value sent by
	 *         the {@link PushMeasure}, or the initial value if it did not send
	 *         any
	 */
	@SuppressWarnings(&quot;serial&quot;)
	public &lt;Value&gt; PullMeasure&lt;Value&gt; createPullFromPush(
			final PushMeasure&lt;Value&gt; push, Value initialValue) {
<span class="fc" id="L47">		final Object[] cache = { initialValue };</span>
<span class="fc" id="L48">		final MeasureListener&lt;Value&gt; listener = new MeasureListener&lt;Value&gt;() {</span>

			@Override
			public void measureGenerated(Value value) {
<span class="fc" id="L52">				cache[0] = value;</span>
<span class="fc" id="L53">			}</span>
		};
<span class="fc" id="L55">		push.register(listener);</span>
<span class="fc" id="L56">		return new PullMeasure&lt;Value&gt;() {</span>

			@Override
			public String getName() {
<span class="nc" id="L60">				return push.getName();</span>
			}

			@Override
			public String getDescription() {
<span class="nc" id="L65">				return push.getDescription();</span>
			}

			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public Value get() {
<span class="fc" id="L71">				return (Value) cache[0];</span>
			}

			@Override
			protected void finalize() throws Throwable {
<span class="fc" id="L76">				push.unregister(listener);</span>
<span class="fc" id="L77">				super.finalize();</span>
<span class="fc" id="L78">			}</span>
		};
	}

	/**
	 * Create a {@link PushMeasure} which checks at regular intervals the value
	 * of a {@link PullMeasure}. If the value have changed since the last check
	 * (or since the creation of the {@link PushMeasure}), a notification will
	 * be generated by the {@link PushMeasure} with the new {@link Value}.&lt;br/&gt;
	 * &lt;br/&gt;
	 * Notice that if the period is two small, the checking process could have a
	 * significant impact on performances, because a {@link Thread} is run in
	 * parallel to check regularly the {@link Value} modifications. If the
	 * period is too big, you could miss relevant notifications, especially if
	 * the {@link PullMeasure} change to a new {@link Value} and change back to
	 * its previous {@link Value} between two consecutive checks. In such a
	 * case, no notification will be sent because the {@link Value} during the
	 * two checks is equal.
	 * 
	 * @param pull
	 *            the {@link PullMeasure} to cover
	 * @param period
	 *            the number of milliseconds between each check
	 * @return a {@link PushMeasure} which will notify any change occurred on
	 *         the {@link PullMeasure} at the given frequency
	 */
	public &lt;Value&gt; PushMeasure&lt;Value&gt; createPushFromPull(
			PullMeasure&lt;Value&gt; pull, final long period) {
<span class="fc" id="L106">		SimplePushMeasure&lt;Value&gt; push = new SimplePushMeasure&lt;&gt;(pull.getName(),</span>
<span class="fc" id="L107">				pull.getDescription());</span>
<span class="fc" id="L108">		final WeakReference&lt;PullMeasure&lt;Value&gt;&gt; weakPull = new WeakReference&lt;PullMeasure&lt;Value&gt;&gt;(</span>
				pull);
<span class="fc" id="L110">		final WeakReference&lt;SimplePushMeasure&lt;Value&gt;&gt; weakPush = new WeakReference&lt;SimplePushMeasure&lt;Value&gt;&gt;(</span>
				push);
<span class="fc" id="L112">		final Value initialValue = pull.get();</span>
		/*
		 * TODO Use a static thread to run the checks of all the measures
		 * created that way. Using a WeakHashMap could probably do the trick.
		 */
<span class="fc" id="L117">		Thread thread = new Thread(new Runnable() {</span>
<span class="fc" id="L118">			private Value lastValue = initialValue;</span>

			@Override
			public void run() {
<span class="fc" id="L122">				boolean isThreadNeeded = true;</span>
<span class="fc" id="L123">				long alreadyConsumed = 0;</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">				while (isThreadNeeded) {</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">					if (alreadyConsumed &gt; period) {</span>
<span class="nc" id="L126">						long realConsumption = alreadyConsumed;</span>
<span class="nc" id="L127">						long missed = alreadyConsumed / period;</span>
<span class="nc" id="L128">						alreadyConsumed = alreadyConsumed % period;</span>
<span class="nc" id="L129">						log.warning(&quot;Too much time consumed in the last measuring (&quot;</span>
								+ realConsumption
								+ &quot;&gt;&quot;
								+ period
								+ &quot;), ignore the &quot;
								+ missed
								+ &quot; pushes missed and consider it has consumed &quot;
								+ alreadyConsumed);
					} else {
						// usual case.
					}
					try {
<span class="fc" id="L141">						Thread.sleep(period - alreadyConsumed);</span>
<span class="nc" id="L142">					} catch (InterruptedException e) {</span>
<span class="nc" id="L143">						throw new JMetalException(&quot;Error in run method: &quot;, e) ;</span>
<span class="fc" id="L144">					}</span>

<span class="fc" id="L146">					long measureStart = System.currentTimeMillis();</span>

<span class="fc" id="L148">					PullMeasure&lt;Value&gt; pull = weakPull.get();</span>
<span class="fc" id="L149">					SimplePushMeasure&lt;Value&gt; push = weakPush.get();</span>
<span class="fc bfc" id="L150" title="All 4 branches covered.">					if (pull == null || push == null) {</span>
<span class="fc" id="L151">						isThreadNeeded = false;</span>
					} else {
<span class="fc" id="L153">						Value value = pull.get();</span>
<span class="pc bpc" id="L154" title="1 of 4 branches missed.">						if (value == lastValue || value != null</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">								&amp;&amp; value.equals(lastValue)) {</span>
							// still the same, don't notify
						} else {
<span class="fc" id="L158">							lastValue = value;</span>
<span class="fc" id="L159">							push.push(value);</span>
						}
					}
<span class="fc" id="L162">					pull = null;</span>
<span class="fc" id="L163">					push = null;</span>

<span class="fc" id="L165">					long measureEnd = System.currentTimeMillis();</span>
<span class="fc" id="L166">					alreadyConsumed = measureEnd - measureStart;</span>
<span class="fc" id="L167">				}</span>
<span class="fc" id="L168">			}</span>
		});
<span class="fc" id="L170">		thread.setDaemon(true);</span>
<span class="fc" id="L171">		thread.start();</span>
<span class="fc" id="L172">		return push;</span>
	}

	/**
	 * Create {@link PullMeasure}s based on the getters available from an
	 * instance, whatever it is. The {@link Class} of the instance is analyzed
	 * to retrieve its public methods and a {@link PullMeasure} is built for
	 * each method which use a getter-like signature. The name of the method is
	 * further exploited to identify the measure, such that the map returned use
	 * the name of the method (without &quot;get&quot;) as a key which maps to the
	 * {@link PullMeasure} built from this method. The {@link PullMeasure}
	 * itself is named by using the name of the method.
	 * 
	 * @param object
	 *            the {@link Object} to cover
	 * @return the {@link Map} which contains the names of the getter methods
	 *         and the corresponding {@link PullMeasure} built from them
	 */
	@SuppressWarnings(&quot;serial&quot;)
	public Map&lt;String, PullMeasure&lt;?&gt;&gt; createPullsFromGetters(
			final Object object) {
<span class="fc" id="L193">		Map&lt;String, PullMeasure&lt;?&gt;&gt; measures = new HashMap&lt;String, PullMeasure&lt;?&gt;&gt;();</span>
<span class="fc" id="L194">		Class&lt;? extends Object&gt; clazz = object.getClass();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">		for (final Method method : clazz.getMethods()) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">			if (method.getParameterTypes().length == 0</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">					&amp;&amp; !method.getReturnType().equals(Void.TYPE)</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">					&amp;&amp; !method.getName().equals(&quot;getClass&quot;)</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">					&amp;&amp; method.getName().matches(&quot;get[^a-z].*&quot;)) {</span>
<span class="fc" id="L200">				String key = method.getName().substring(3);</span>
				// TODO exploit return type to restrict the generics
<span class="fc" id="L202">				measures.put(key, new SimplePullMeasure&lt;Object&gt;(key) {</span>

					@Override
					public Object get() {
						try {
<span class="fc" id="L207">							return method.invoke(object);</span>
<span class="nc" id="L208">						} catch (IllegalAccessException</span>
								| IllegalArgumentException
								| InvocationTargetException e) {
<span class="nc" id="L211">							throw new RuntimeException(e);</span>
						}
					}
				});
			} else {
				// not a getter, ignore it
			}
		}
<span class="fc" id="L219">		return measures;</span>
	}

	/**
	 * Create {@link PullMeasure}s based on the fields available from an
	 * instance, whatever it is. The {@link Class} of the instance is analyzed
	 * to retrieve its public fields and a {@link PullMeasure} is built for each
	 * of them. The name of the field is further exploited to identify the
	 * measure, such that the map returned use the name of the field as a key
	 * which maps to the {@link PullMeasure} built from this field. The
	 * {@link PullMeasure} itself is named by using the name of the field.
	 * 
	 * @param object
	 *            the {@link Object} to cover
	 * @return the {@link Map} which contains the names of the getter methods
	 *         and the corresponding {@link PullMeasure} built from them
	 */
	@SuppressWarnings(&quot;serial&quot;)
	public Map&lt;String, PullMeasure&lt;?&gt;&gt; createPullsFromFields(final Object object) {
<span class="fc" id="L238">		Map&lt;String, PullMeasure&lt;?&gt;&gt; measures = new HashMap&lt;String, PullMeasure&lt;?&gt;&gt;();</span>
<span class="fc" id="L239">		Class&lt;? extends Object&gt; clazz = object.getClass();</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">		for (final Field field : clazz.getFields()) {</span>
<span class="fc" id="L241">			String key = field.getName();</span>
			// TODO exploit return type to restrict the generics
<span class="fc" id="L243">			measures.put(key, new SimplePullMeasure&lt;Object&gt;(key) {</span>

				@Override
				public Object get() {
					try {
<span class="fc" id="L248">						return field.get(object);</span>
<span class="nc" id="L249">					} catch (IllegalArgumentException | IllegalAccessException e) {</span>
<span class="nc" id="L250">						throw new RuntimeException();</span>
					}
				}
			});
		}
<span class="fc" id="L255">		return measures;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>