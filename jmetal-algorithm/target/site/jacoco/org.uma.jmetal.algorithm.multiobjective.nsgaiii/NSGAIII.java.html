<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NSGAIII.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">org.uma.jmetal:jmetal-algorithm</a> &gt; <a href="index.source.html" class="el_package">org.uma.jmetal.algorithm.multiobjective.nsgaiii</a> &gt; <span class="el_source">NSGAIII.java</span></div><h1>NSGAIII.java</h1><pre class="source lang-java linenums">package org.uma.jmetal.algorithm.multiobjective.nsgaiii;

import org.uma.jmetal.algorithm.impl.AbstractGeneticAlgorithm;
import org.uma.jmetal.algorithm.multiobjective.nsgaiii.util.EnvironmentalSelection;
import org.uma.jmetal.algorithm.multiobjective.nsgaiii.util.ReferencePoint;
import org.uma.jmetal.solution.Solution;
import org.uma.jmetal.util.JMetalLogger;
import org.uma.jmetal.util.SolutionListUtils;
import org.uma.jmetal.util.evaluator.SolutionListEvaluator;
import org.uma.jmetal.util.solutionattribute.Ranking;
import org.uma.jmetal.util.solutionattribute.impl.DominanceRanking;

import java.util.ArrayList;
import java.util.List;
import java.util.Vector;

/**
 * Created by ajnebro on 30/10/14.
 * Modified by Juanjo on 13/11/14
 *
 * This implementation is based on the code of Tsung-Che Chiang
 * http://web.ntnu.edu.tw/~tcchiang/publications/nsga3cpp/nsga3cpp.htm
 */
@SuppressWarnings(&quot;serial&quot;)
public class NSGAIII&lt;S extends Solution&lt;?&gt;&gt; extends AbstractGeneticAlgorithm&lt;S, List&lt;S&gt;&gt; {
  protected int iterations ;
  protected int maxIterations ;
  protected int populationSize ;
  protected SolutionListEvaluator&lt;S&gt; evaluator ;

  protected Vector&lt;Integer&gt; numberOfDivisions  ;
<span class="nc" id="L32">  protected List&lt;ReferencePoint&lt;S&gt;&gt; referencePoints = new Vector&lt;&gt;() ;</span>

  /** Constructor */
  public NSGAIII(NSGAIIIBuilder&lt;S&gt; builder) { // can be created from the NSGAIIIBuilder within the same package
<span class="nc" id="L36">    super(builder.getProblem()) ;</span>
<span class="nc" id="L37">    maxIterations = builder.getMaxIterations() ;</span>

<span class="nc" id="L39">    crossoverOperator =  builder.getCrossoverOperator() ;</span>
<span class="nc" id="L40">    mutationOperator  =  builder.getMutationOperator() ;</span>
<span class="nc" id="L41">    selectionOperator =  builder.getSelectionOperator() ;</span>
<span class="nc" id="L42">    populationSize = builder.getPopulationSize();</span>
<span class="nc" id="L43">    evaluator = builder.getEvaluator() ;</span>

    /// NSGAIII
<span class="nc" id="L46">    numberOfDivisions = new Vector&lt;&gt;(1) ;</span>
<span class="nc" id="L47">    numberOfDivisions.add(12) ; // Default value for 3D problems</span>

<span class="nc" id="L49">    (new ReferencePoint&lt;S&gt;()).generateReferencePoints(referencePoints,getProblem().getNumberOfObjectives() , numberOfDivisions);</span>
    /*
    int populationSize = referencePoints.size();
    //System.out.println(referencePoints.size());
    while (populationSize%4&gt;0) {
      populationSize++;
    }
    */
    //populationSize = 100;
<span class="nc" id="L58">    System.out.println(populationSize);</span>
<span class="nc" id="L59">    setMaxPopulationSize(populationSize);</span>
<span class="nc" id="L60">    JMetalLogger.logger.info(&quot;rpssize: &quot; + referencePoints.size()); ;</span>
<span class="nc" id="L61">  }</span>

  @Override
  protected void initProgress() {
<span class="nc" id="L65">    iterations = 1 ;</span>
<span class="nc" id="L66">  }</span>

  @Override
  protected void updateProgress() {
<span class="nc" id="L70">    iterations++ ;</span>
<span class="nc" id="L71">  }</span>

  @Override
  protected boolean isStoppingConditionReached() {
<span class="nc bnc" id="L75" title="All 2 branches missed.">    return iterations &gt;= maxIterations;</span>
  }

  @Override
  protected List&lt;S&gt; evaluatePopulation(List&lt;S&gt; population) {
<span class="nc" id="L80">    population = evaluator.evaluate(population, getProblem()) ;</span>

<span class="nc" id="L82">    return population ;</span>
  }

  @Override
  protected List&lt;S&gt; selection(List&lt;S&gt; population) {
<span class="nc" id="L87">    List&lt;S&gt; matingPopulation = new ArrayList&lt;&gt;(population.size()) ;</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">    for (int i = 0; i &lt; getMaxPopulationSize(); i++) {</span>
<span class="nc" id="L89">      S solution = selectionOperator.execute(population);</span>
<span class="nc" id="L90">      matingPopulation.add(solution) ;</span>
    }

<span class="nc" id="L93">    return matingPopulation;</span>
  }

  @Override
  protected List&lt;S&gt; reproduction(List&lt;S&gt; population) {
<span class="nc" id="L98">    List&lt;S&gt; offspringPopulation = new ArrayList&lt;&gt;(getMaxPopulationSize());</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">    for (int i = 0; i &lt; getMaxPopulationSize(); i+=2) {</span>
<span class="nc" id="L100">      List&lt;S&gt; parents = new ArrayList&lt;&gt;(2);</span>
<span class="nc" id="L101">      parents.add(population.get(i));</span>
<span class="nc" id="L102">      parents.add(population.get(Math.min(i + 1, getMaxPopulationSize()-1)));</span>

<span class="nc" id="L104">      List&lt;S&gt; offspring = crossoverOperator.execute(parents);</span>

<span class="nc" id="L106">      mutationOperator.execute(offspring.get(0));</span>
<span class="nc" id="L107">      mutationOperator.execute(offspring.get(1));</span>

<span class="nc" id="L109">      offspringPopulation.add(offspring.get(0));</span>
<span class="nc" id="L110">      offspringPopulation.add(offspring.get(1));</span>
    }
<span class="nc" id="L112">    return offspringPopulation ;</span>
  }

  
  private List&lt;ReferencePoint&lt;S&gt;&gt; getReferencePointsCopy() {
<span class="nc" id="L117">	  List&lt;ReferencePoint&lt;S&gt;&gt; copy = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">	  for (ReferencePoint&lt;S&gt; r : this.referencePoints) {</span>
<span class="nc" id="L119">		  copy.add(new ReferencePoint&lt;&gt;(r));</span>
<span class="nc" id="L120">	  }</span>
<span class="nc" id="L121">	  return copy;</span>
  }
  
  @Override
  protected List&lt;S&gt; replacement(List&lt;S&gt; population, List&lt;S&gt; offspringPopulation) {
   
<span class="nc" id="L127">	List&lt;S&gt; jointPopulation = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L128">    jointPopulation.addAll(population) ;</span>
<span class="nc" id="L129">    jointPopulation.addAll(offspringPopulation) ;</span>

<span class="nc" id="L131">    Ranking&lt;S&gt; ranking = computeRanking(jointPopulation);</span>
    
    //List&lt;Solution&gt; pop = crowdingDistanceSelection(ranking);
<span class="nc" id="L134">    List&lt;S&gt; pop = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L135">    List&lt;List&lt;S&gt;&gt; fronts = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L136">    int rankingIndex = 0;</span>
<span class="nc" id="L137">    int candidateSolutions = 0;</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">    while (candidateSolutions &lt; getMaxPopulationSize()) {</span>
<span class="nc" id="L139">      fronts.add(ranking.getSubfront(rankingIndex));</span>
<span class="nc" id="L140">      candidateSolutions += ranking.getSubfront(rankingIndex).size();</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">      if ((pop.size() + ranking.getSubfront(rankingIndex).size()) &lt;= getMaxPopulationSize())</span>
<span class="nc" id="L142">        addRankedSolutionsToPopulation(ranking, rankingIndex, pop);</span>
<span class="nc" id="L143">      rankingIndex++;</span>
    }
    
    // A copy of the reference list should be used as parameter of the environmental selection
<span class="nc" id="L147">    EnvironmentalSelection&lt;S&gt; selection =</span>
<span class="nc" id="L148">            new EnvironmentalSelection&lt;&gt;(fronts,getMaxPopulationSize(),getReferencePointsCopy(),</span>
<span class="nc" id="L149">                    getProblem().getNumberOfObjectives());</span>
    
<span class="nc" id="L151">    pop = selection.execute(pop);</span>
     
<span class="nc" id="L153">    return pop;</span>
  }

  @Override
  public List&lt;S&gt; getResult() {
<span class="nc" id="L158">    return getNonDominatedSolutions(getPopulation()) ;</span>
  }

  protected Ranking&lt;S&gt; computeRanking(List&lt;S&gt; solutionList) {
<span class="nc" id="L162">    Ranking&lt;S&gt; ranking = new DominanceRanking&lt;&gt;() ;</span>
<span class="nc" id="L163">    ranking.computeRanking(solutionList) ;</span>

<span class="nc" id="L165">    return ranking ;</span>
  }

  protected void addRankedSolutionsToPopulation(Ranking&lt;S&gt; ranking, int rank, List&lt;S&gt; population) {
    List&lt;S&gt; front ;

<span class="nc" id="L171">    front = ranking.getSubfront(rank);</span>

<span class="nc bnc" id="L173" title="All 2 branches missed.">    for (int i = 0 ; i &lt; front.size(); i++) {</span>
<span class="nc" id="L174">      population.add(front.get(i));</span>
    }
<span class="nc" id="L176">  }</span>

  protected List&lt;S&gt; getNonDominatedSolutions(List&lt;S&gt; solutionList) {
<span class="nc" id="L179">    return SolutionListUtils.getNondominatedSolutions(solutionList) ;</span>
  }

  @Override public String getName() {
<span class="nc" id="L183">    return &quot;NSGAIII&quot; ;</span>
  }

  @Override public String getDescription() {
<span class="nc" id="L187">    return &quot;Nondominated Sorting Genetic Algorithm version III&quot; ;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>