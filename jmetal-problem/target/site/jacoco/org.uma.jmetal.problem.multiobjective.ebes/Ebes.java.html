<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Ebes.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">org.uma.jmetal:jmetal-problem</a> &gt; <a href="index.source.html" class="el_package">org.uma.jmetal.problem.multiobjective.ebes</a> &gt; <span class="el_source">Ebes.java</span></div><h1>Ebes.java</h1><pre class="source lang-java linenums">/**
 * EBEs.java
 *
 @author Gustavo R. Zavala &lt;grzavala@gmail.com&gt;
  *         Antonio J. Nebro &lt;antonio@lcc.uma.es&gt;
  *         Juan J. Durillo &lt;durillo@lcc.uma.es&gt;
  * @version 1.0
 *//**
 * Ebes.java
 *
 @author Gustavo R. Zavala &lt;grzavala@gmail.com&gt;
  *         Antonio J. Nebro &lt;antonio@lcc.uma.es&gt;
  *         Juan J. Durillo &lt;durillo@lcc.uma.es&gt;
  * @version 1.0
 */
package org.uma.jmetal.problem.multiobjective.ebes;

import org.uma.jmetal.problem.ConstrainedProblem;
import org.uma.jmetal.problem.impl.AbstractDoubleProblem;
import org.uma.jmetal.solution.DoubleSolution;
import org.uma.jmetal.solution.impl.DefaultDoubleSolution;
import org.uma.jmetal.util.JMetalException;
import org.uma.jmetal.util.solutionattribute.impl.OverallConstraintViolation;

import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Class representing problem Ebes
 * Spatial Bars Structure (Estructuras de Barras Espaciales)
 */
@SuppressWarnings(&quot;serial&quot;)
public class Ebes extends AbstractDoubleProblem implements ConstrainedProblem&lt;DoubleSolution&gt; {
  /**
   * Constructor.
   * Creates a default instance of the Ebes problem.
   * @param solutionType The solution type must &quot;Real&quot; or &quot;BinaryReal&quot;.
   */

  /**
   * Stores the number of Bar Groups
   */
  protected int numberOfEval_ ;

 /*
    protected int maxEvaluations_ ;

    public void setMaxEvaluations(int maxEvaluations) {
        maxEvaluations_ = maxEvaluations;
    } // setNumberOfElement

    public int getMaxEvaluations() {
        return maxEvaluations_;
    } // setNumberOfElement
 */

  /*
   * Stores the number of Nodes of the problem
   */
  protected int numberOfNodes;

  public void setNumberOfNodes(int numberOfNodes) {
<span class="nc" id="L67">    this.numberOfNodes = numberOfNodes;</span>
<span class="nc" id="L68">  } // setNumberOfNodes</span>

  public int getNumberOfNodes() {
<span class="nc" id="L71">    return numberOfNodes;</span>
  } // getNumberOfNodes


  /**
   * Stores the number of Nodes of the problem
   */
<span class="nc" id="L78">  protected int numberOfLibertyDegree_=6 ;</span>

  protected int numberOfNodesRestricts_ ;

  public void numberOfNodesRestricts(int numberOfNodesRestricts) {
<span class="nc" id="L83">    numberOfNodesRestricts_ = numberOfNodesRestricts;</span>
<span class="nc" id="L84">  } // set numberOfNodesRestricts</span>

  public int getNumberOfNodesRestricts() {
<span class="nc" id="L87">    return numberOfNodesRestricts_ ;</span>
  } // get NumberOfNodes

  /**
   * Stores the number of Nodes of the problem
   */
  protected double [][] nodeCheck_ ;
  public double nodeCheck(int i, int j) {
<span class="nc" id="L95">    return nodeCheck_[i][j];</span>
  } // get node check

  protected int [][] geometryCheck_ ;
  public int geometryCheck(int i, int j) {
<span class="nc" id="L100">    return geometryCheck_[i][j];</span>
  } // get node check

  /**
   * Stores the number of Bar Groups
   */
  protected int numberOfGroupElements_ ;

  public void setnumberOfGroupElements(int i) {
<span class="nc" id="L109">    numberOfGroupElements_ = i;</span>
<span class="nc" id="L110">  } // setNumberOfElement</span>

  public int getnumberOfGroupElements() {
<span class="nc" id="L113">    return numberOfGroupElements_;</span>
  } // getNumberOfElements

  /**
   * Stores the number of Bar of the problem
   */
  protected int numberOfElements_ ;

  public void setNumberOfElements(int numberOfElements) {
<span class="nc" id="L122">    numberOfElements_ = numberOfElements;</span>
<span class="nc" id="L123">  } // setNumberOfElement</span>

  public int getNumberOfElements() {
<span class="nc" id="L126">    return numberOfElements_;</span>
  } // getNumberOfElements

  public boolean lLoadsOwnWeight;

  public boolean lSecondOrderGeometric;

  public boolean lBuckling;

  /**
   * Stores the Elements Between Difference Greatest
   */
  protected int elementsBetweenDiffGreat_;

  public void setElementsBetweenDiffGreat(int elementsBetweenDiffGreat) {
<span class="nc" id="L141">    elementsBetweenDiffGreat_ = elementsBetweenDiffGreat;</span>
<span class="nc" id="L142">  } // setNumberOfElement</span>

  public int getElementsBetweenDiffGreat() {
<span class="nc" id="L145">    return elementsBetweenDiffGreat_;</span>
  } // getNumberOfElements

  /**
   * Stores the number of Load in Nodes of the problem
   */
  protected int numberOfWeigthsNodes_ ;

  public void setNumberOfWeigthsNodes(int numberOfWeigthsNodes) {
<span class="nc" id="L154">    numberOfWeigthsNodes_ = numberOfWeigthsNodes;</span>
<span class="nc" id="L155">  } // setNumberOfWeigths</span>

  public int getNumberOfWeigthsNodes() {
<span class="nc" id="L158">    return numberOfWeigthsNodes_;</span>
  } // getNumberOfWeigths

  /**
   * Stores the number of Load in ElementsNodes of the problem
   */
  protected int numberOfWeigthsElements_ ;

  public void setNumberOfWeigthsElements(int numberOfWeigthsElements) {
<span class="nc" id="L167">    numberOfWeigthsElements_ = numberOfWeigthsElements;</span>
<span class="nc" id="L168">  } // setNumberOfWeigths</span>

  public int getNumberOfWeigthsElements() {
<span class="nc" id="L171">    return numberOfWeigthsElements_;</span>
  } // getNumberOfWeigths

  /**
   * Stores the number a wide the diagonal matrix
   */
  protected int matrixWidthBand_ ;

  public void setMatrixWidthBand(int matrixWidthBand) {
<span class="nc" id="L180">    matrixWidthBand_ = matrixWidthBand;</span>
<span class="nc" id="L181">  } // setMatrixWidtBand</span>

  public int getMatrixWidthBand() {
<span class="nc" id="L184">    return matrixWidthBand_;</span>
  } // getMatrixWidtBand


  protected int numberOfWeigthHypothesis_ ;

  public void setNumberOfWeigthHypothesis(int numberOfWeigthHypothesis) {
<span class="nc" id="L191">    numberOfWeigthHypothesis_ = numberOfWeigthHypothesis;</span>
<span class="nc" id="L192">  } // set numberOfLibertyDegree</span>

  public int getNumberOfWeigthHypothesis() {
<span class="nc" id="L195">    return numberOfWeigthHypothesis_ ;</span>
  } // get numberOfLibertyDegree

  public int numberOfConstraintsGeometric_;
  public void setnumberOfConstraintsGeometric(int i) {
<span class="nc" id="L200">    numberOfConstraintsGeometric_ = i;</span>
<span class="nc" id="L201">  } // set numberOfConstraintsGeometric_</span>

  public int getnumberOfConstraintsGeometric() {
<span class="nc" id="L204">    return numberOfConstraintsGeometric_ ;</span>
  } // get numberOfConstraintsGeometric_


  protected int numberOfConstraintsNodes_ ;
  protected int numberOfGroupsToCheckGeometry_;

  public void setNumberOfConstraintsNodes(int numberOfConstraintsNodes) {
<span class="nc" id="L212">    numberOfConstraintsNodes_ = numberOfConstraintsNodes;</span>
<span class="nc" id="L213">  } // set numberOfConstraintsNodes</span>

  public int getNumberOfConstraintsNodes() {
<span class="nc" id="L216">    return numberOfWeigthHypothesis_ ;</span>
  } // get numberOfRestrictionNodes

  /**
   * Stores the Node
   */
  protected double [][] Node_ ;

  public double getNode(int i, int j) {
<span class="nc" id="L225">    return Node_[i][j] ;</span>
  } // getNodes

  /**
   * Stores the NodeRestrict
   */
  protected double [][] NodeRestrict_ ;

  public double getNodeRestrict(int i, int j) {
<span class="nc" id="L234">    return NodeRestrict_[i][j] ;</span>
  } // getNodes

  /**
   * Stores the Groups
   */
  protected double [][] Groups_ ;

  public double getGroups(int i) {
<span class="nc" id="L243">    return Groups_[i][MAX_COLUMN] ;</span>
  } // getGroups


  /**
   * Stores the Element
   */
  protected double [][] Element_ ;

  public double getElement(int i, int j) {
<span class="nc" id="L253">    return Element_[i][j] ;</span>
  } // getElement


  /**
   * Stores the Load on Nodes
   */
  protected double [][] WeightNode_  ;

  public double getWeightNode(int i, int j) {
<span class="nc" id="L263">    return WeightNode_[i][j] ;</span>
  } // getWeight

  /**
   * Stores the OverLoad on Elements
   */
  protected double [][] OverloadInElement_  ;

  public double getWeightElement(int i, int j) {
<span class="nc" id="L272">    return OverloadInElement_[i][j] ;</span>
  } // getWeight


  /**
   * Stores the Load on Elements Itself
   */
  protected double [][] WeightElement_  ;

  public double getWeightElementItself(int i, int j) {
<span class="nc" id="L282">    return WeightElement_[i][j];</span>
  } // getWeight

  /**
   * Stores the k
   */
  protected double [] MatrixStiffness_ ;

  public double MatrixStiffness(int i) {
<span class="nc" id="L291">    return MatrixStiffness_[i];</span>
  } // get Strain i

  /**
   * Stores the k displacement
   */
  protected double [][] DisplacementNodes_ ;

  public double DisplacementNodes(int node, int hi) {
<span class="nc" id="L300">    return DisplacementNodes_[node][hi];</span>
  } // get DisplacementNodes i


  /**
   * Stores the Effort in node i
   */
  protected double [][][] Efforti_ ;

  public double Efforti(int i, int element, int hypothesis) {
<span class="nc" id="L310">    return Efforti_[i][element][hypothesis];</span>
  } // get Effort i

  /**
   * Stores the Effort in node j
   */
  protected double [][][] Effortj_ ;

  public double Effortj(int i, int element, int hypothesis) {
<span class="nc" id="L319">    return Effortj_[i][element][hypothesis];</span>
  } // get Effort j

  /**
   * Stores the Axial force in node i
   */
  protected double [] AxialForcei_ ;

  public double AxialForcei_(int element) {
<span class="nc" id="L328">    return AxialForcei_[element];</span>
  } // get Axial Force i

  /**
   * Stores the Axial force in node j
   */
  protected double [] AxialForcej_ ;

  public double AxialForcej_(int element) {
<span class="nc" id="L337">    return AxialForcej_[element];</span>
  } // get Axial Force j

  protected int strainAdmissibleCut_ ;

  public void setStrainAdmissibleCut(int strainAdmissibleCut) {
<span class="nc" id="L343">    strainAdmissibleCut_ = strainAdmissibleCut;</span>
<span class="nc" id="L344">  } // setStrainAdmissibleCompress</span>

  public int getStrainAdmissibleCut() {
<span class="nc" id="L347">    return strainAdmissibleCut_ ;</span>
  } // getStrainAdmissibleCut


  /**
   * Stores the Strain in node i
   */
  protected double [][][] Straini_ ;

  public double Straini(int i, int element, int hypothesis) {
<span class="nc" id="L357">    return Straini_[i][element][hypothesis];</span>
  } // get Strain i

  /**
   * Stores the Strain in node j
   */
  protected double [][][] Strainj_ ;

  public double getStrainj(int i, int element, int hypothesis) {
    // i=0: Compression, =1: Traction, =2: Tangential
<span class="nc" id="L367">    return Strainj_[i][element][hypothesis];</span>
  } // get Strain j

  /**
   * Stores the max omega for groups
   */
  protected double [][] omegaMax_ ;
  public double getOmegaMax(int group, int hypothesis) {
<span class="nc" id="L375">    return omegaMax_[group][hypothesis] ;</span>
  } // get

  /**
   * Stores the max Nxx for groups
   */
  protected double [][] NxxMax_ ;
  public double getNxxMax(int group, int hypothesis) {
    // normal (+)
<span class="nc" id="L384">    return NxxMax_[group][hypothesis] ;</span>
  } // get

  /**
   * Stores the min Nxx for groups
   */
  protected double [][] NxxMin_ ;
  public double getNxxMin(int group, int hypothesis) {
    // normal (-)
<span class="nc" id="L393">    return NxxMin_[group][hypothesis] ;</span>
  } // get

  /**
   * Stores the max Mxz for groups
   */
  protected double [][] MxzMax_ ;
  public double getMxzMax(int group, int hypothesis) {
    // flexor moment (+)
<span class="nc" id="L402">    return MxzMax_[group][hypothesis] ;</span>
  } // get

  /**
   * Stores the max Mxz for groups
   */
  protected double [][] MxzMin_ ;
  public double getMxzMin(int group, int hypothesis) {
    // flexor moment (-)
<span class="nc" id="L411">    return MxzMin_[group][hypothesis] ;</span>
  } // get

  /**
   * Stores the max Mxy for groups
   */
  protected double [][] MxyMax_ ;
  public double getMxyMax(int group, int hypothesis) {
    // flexor moment (+)
<span class="nc" id="L420">    return MxyMax_[group][hypothesis] ;</span>
  } // get

  /**
   * Stores the min Mxy for groups
   */
  protected double [][] MxyMin_ ;
  public double getMxyMin(int group, int hypothesis) {
    // flexor moment (-)
<span class="nc" id="L429">    return MxyMin_[group][hypothesis] ;</span>
  } // get

  /**
   * Stores the max Nxx Strain for groups
   */
  protected double [][] StrainNxxMax_ ;
  public double getStrainNxxMax(int group, int hypothesis) {
    // normal (+)
<span class="nc" id="L438">    return StrainNxxMax_[group][hypothesis] ;</span>
  } // get Strain

  protected double [][] StrainNxxMin_ ;
  public double getStrainNxxMin(int group, int hypothesis) {
    // normal  (-)
<span class="nc" id="L444">    return StrainNxxMin_[group][hypothesis] ;</span>
  } // get Strain

  /**
   * Stores the max Mxz Strain for groups
   */
  protected double [][] StrainMxzMax_ ;
  public double getStrainMxzMax(int group, int hypothesis) {
    // normal (+)
<span class="nc" id="L453">    return StrainMxzMax_[group][hypothesis] ;</span>
  } // get Strain

  /**
   * Stores the max Mxz Strain for groups
   */
  protected double [][] StrainMxzMin_ ;
  public double getStrainMxzMin(int group, int hypothesis) {
    // normal (-)
<span class="nc" id="L462">    return StrainMxzMin_[group][hypothesis] ;</span>
  } // get Strain

  /**
   * Stores the max Mxz Strain for groups
   */
  protected double [][] StrainMxyMax_ ;
  public double getStrainMxyMax(int group, int hypothesis) {
    // normal (+)
<span class="nc" id="L471">    return StrainMxyMax_[group][hypothesis] ;</span>
  } // get Strain

  /**
   * Stores the max Mxz Strain for groups
   */
  protected double [][] StrainMxyMin_ ;
  public double getStrainMxyMin(int group, int hypothesis) {
    // normal (-)
<span class="nc" id="L480">    return StrainMxyMin_[group][hypothesis] ;</span>
  } // get Strain

  /**
   * Stores the max Strain for elements
   */
  protected double [][] StrainMax_ ;
  public double getStrainMax(int group, int hypothesis) {
    // normal (+)
<span class="nc" id="L489">    return StrainMax_[group][hypothesis] ;</span>
  } // get Strain j

  protected double [][] StrainMin_ ;
  public double getStrainMin(int group, int hypothesis) {
    // normal (+)
<span class="nc" id="L495">    return StrainMin_[group][hypothesis] ;</span>
  } // get Strain j

  /**
   * Stores the max Strain for elements
   */
  protected double [][] OldStrainMax_ ;
  public double getOldStrainMax(int group, int hypothesis) {
    // normal (+)
<span class="nc" id="L504">    return OldStrainMax_[group][hypothesis] ;</span>
  } // get Strain j

  protected double [][] OldStrainMin_ ;
  public double getOldStrainMin(int group, int hypothesis) {
    // normal (+)
<span class="nc" id="L510">    return OldStrainMin_[group][hypothesis] ;</span>
  } // get Strain j

  /**
   * Stores the max Strain for elements
   */
  protected double [][] StrainCutMax_ ;

  public double getStrainCutMax(int group, int hypothesis) {
    // Tangential
<span class="nc" id="L520">    return StrainCutMax_[group][hypothesis] ;</span>
  } // get Strain j


  /**
   * Stores the min Strain for elements
   */
  protected double [] StrainResidualMin_ ;

  public double getStrainResidualMin(int hypothesis) {
    // stress negative
<span class="nc" id="L531">    return StrainResidualMin_[hypothesis] ;</span>
  } // get Strain j

  /**
   * Stores the max Strain for elements
   */
  protected double [] StrainResidualMax_ ;

  public double getStrainResidualMax(int hypothesis) {
    // stress positive
<span class="nc" id="L541">    return StrainResidualMax_[hypothesis] ;</span>
  } // get Strain j

  /**
   * Stores the Cut Strain Residual for elements
   */
  protected double [] StrainResidualCut_ ;

  public double getStrainResidualCut(int hypothesis) {
    // stress cut
<span class="nc" id="L551">    return StrainResidualCut_[hypothesis] ;</span>
  } // get Strain j

  //---- ANTONIO -----//
  public int getGroupShape(int groupId) {
<span class="nc" id="L556">    return (int) Groups_[groupId][SHAPE];</span>
  }

  public int getVariablePosition(int groupId) {
<span class="nc" id="L560">    return (int) Groups_[groupId][VAR_POSITION];</span>
  }
//---- ANTONIO -----//

  // NEW 20/05/2016
  String GravitationalAxis_;
//-----------------------

  //
<span class="nc" id="L569">  double g_ = 9.81; // acceleration of gravity</span>
  //variables load beams
  double [][][] cbi;
  double [][][] cbj;
<span class="nc" id="L573">  double []Qi = new double [numberOfLibertyDegree_]; //carga equivalente en nudo i referida al eje global</span>
<span class="nc" id="L574">  double []Qj = new double [numberOfLibertyDegree_]; //carga equivalente en nudo j referida al eje global</span>
<span class="nc" id="L575">  double []pi = new double [numberOfLibertyDegree_]; // variable auxiliar carga equivalente en nudo i referida al eje local</span>
<span class="nc" id="L576">  double []pj = new double [numberOfLibertyDegree_]; // variable auciliar carga equivalente en nudo j referida al eje local</span>

  double [][] PQ;
  double Reaction_[][];
<span class="nc" id="L580">  double [][]Kii = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L581">  double [][]Kij = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L582">  double [][]Kji = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L583">  double [][]Kjj = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L584">  double [][]KGii= new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L585">  double [][]KGij= new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L586">  double [][]KGji= new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L587">  double [][]KGjj= new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L588">  double [][]Rij  = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L589">  double [][]Rji  = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L590">  double [][]RTij = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L591">  double [][]RTji = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L592">  double [][]Rpij = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L593">  double [][]Rpji = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L594">  double [][]RpTij= new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L595">  double [][]RpTji= new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
  // second order geometric
<span class="nc" id="L597">  double [][]KiiSOG = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L598">  double [][]KijSOG = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L599">  double [][]KjiSOG = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L600">  double [][]KjjSOG = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>

  // matrix indexes of groups elements
<span class="nc" id="L603">  int INDEX_=0; // index for the asociation with elements group</span>
<span class="nc" id="L604">  int GROUP_=1; // groups classification</span>
<span class="nc" id="L605">  int SHAPE=2; // section type</span>
<span class="nc" id="L606">  int BETA=3; // principal angle</span>
<span class="nc" id="L607">  int AREA=4; // angle of the principal axis of inertia</span>
<span class="nc" id="L608">  int Az_=5; // static moment in Z local principal axis</span>
<span class="nc" id="L609">  int Ay_=6; // static moment in Y local principal axis</span>
<span class="nc" id="L610">  int Iz_=7; // inertia moment in Z local principal axis</span>
<span class="nc" id="L611">  int Iy_=8; // inertia moment in Y local principal axis</span>
<span class="nc" id="L612">  int It_=9; // inertia polar in Y and Z local principal axis</span>
<span class="nc" id="L613">  int Iw_=10; // warp modulus (mÃƒÂ³dlo de alabeo)</span>
<span class="nc" id="L614">  int TypeMaterial_=11; // lengthwise modulus of elasticity</span>
<span class="nc" id="L615">  int E_=12; // lengthwise modulus of elasticity</span>
<span class="nc" id="L616">  int G_=13; // transversal modulus of elasticity</span>
<span class="nc" id="L617">  int BLijY_=14; // buckling beta coefficient</span>
<span class="nc" id="L618">  int BLijZ_=15; // buckling beta coefficient</span>
<span class="nc" id="L619">  int Fyz_=16; //Fyz</span>
<span class="nc" id="L620">  int Li_=17; // longitudinal de la barra rÃƒÂ­gida en nodo i</span>
<span class="nc" id="L621">  int Lj_=18; // longitud de la barra rÃƒÂ­gida en nodo j</span>
<span class="nc" id="L622">  int VARIABLES=19; //  cantidad de vaiables de decision</span>
<span class="nc" id="L623">  int Y_=20; // variable height in Y axis local principal</span>
<span class="nc" id="L624">  int Z_=21; // variable width in Z axis local principal</span>
<span class="nc" id="L625">  int eY_=22; // variable tickness in Y axis or coefficient thickness of the axis Y -&gt;  Ay</span>
<span class="nc" id="L626">  int eZ_=23; // variable tickness in Z axis or coefficient thickness of the axis Z -&gt;  Az</span>
<span class="nc" id="L627">  int uY_=24; // baricentro a la fibra extrema superior (up)</span>
<span class="nc" id="L628">  int dY_=25; // baricentro a la fibra extrema inferior (down)</span>
<span class="nc" id="L629">  int lZ_=26; //baricentro a la fibra extrema izquierda (left)</span>
<span class="nc" id="L630">  int rZ_=27; // //baricentro a la fibra extrema derecha (right)</span>
<span class="nc" id="L631">  int CONSTRAINT=28; // cantidad de restricciones</span>
<span class="nc" id="L632">  int RATIO_YZ=29; // ratio with heigth and width</span>
<span class="nc" id="L633">  int SPECIFIC_WEIGHT=30; // material density</span>
<span class="nc" id="L634">  int STRESS=31; // strain positive in the extreme fiber</span>
<span class="nc" id="L635">  int COMPRESSION=32; // strain negative in the extreme fiber</span>
<span class="nc" id="L636">  int STRESS_CUT=33; // cut strain in the section</span>
<span class="nc" id="L637">  int ELONGATION_POS=34; // elongation + in %</span>
<span class="nc" id="L638">  int ELONGATION_NEG=35; // elongation - in %</span>
<span class="nc" id="L639">  int VAR_Y_LOWER_LIMIT=36;</span>
<span class="nc" id="L640">  int VAR_Y_UPPER_LIMIT=37;</span>
<span class="nc" id="L641">  int VAR_Z_LOWER_LIMIT=38;</span>
<span class="nc" id="L642">  int VAR_Z_UPPER_LIMIT=39;</span>
<span class="nc" id="L643">  int VAR_eY_LOWER_LIMIT=40;</span>
<span class="nc" id="L644">  int VAR_eY_UPPER_LIMIT=41;</span>
<span class="nc" id="L645">  int VAR_eZ_LOWER_LIMIT=42;</span>
<span class="nc" id="L646">  int VAR_eZ_UPPER_LIMIT=43;</span>
<span class="nc" id="L647">  int VAR_POSITION=44;</span>
<span class="nc" id="L648">  int DESCRIPTION=45;</span>

<span class="nc" id="L650">  int MAX_COLUMN=45;</span>

  // matrix indexes of weight element
<span class="nc" id="L653">  int CARGA_UNIFORME_TOTAL = 0;</span>
<span class="nc" id="L654">  int CARGA_PUNTUAL = 1;</span>
<span class="nc" id="L655">  int CARGA_UNIFORME_PARCIAL = 2;</span>
<span class="nc" id="L656">  int CARGA_TRIANGULAR_I = 3;</span>
<span class="nc" id="L657">  int CARGA__TRIANGULAR_J = 4;</span>
<span class="nc" id="L658">  int CARGA_PARABOLICA = 5;</span>
<span class="nc" id="L659">  int CARGA_MOMENTO_PUNTUAL = 8;</span>
<span class="nc" id="L660">  int CARGA_MOMENTO_DISTRIBUIDO = 6;</span>
<span class="nc" id="L661">  int CARGA_TEMPERATURA = 10;</span>

  // reference weight of elements in node
  // axis reference
<span class="nc" id="L665">  int aX_ = 0;  // to axis X</span>
<span class="nc" id="L666">  int aY_ = 1;  // to axis Y</span>
<span class="nc" id="L667">  int aZ_ = 2;  // to axis Z</span>
<span class="nc" id="L668">  int gX_ = 3;  // to axis X flexor moment</span>
<span class="nc" id="L669">  int gY_ = 4;  // to axis Y flexor moment</span>
<span class="nc" id="L670">  int gZ_ = 5;  // to axis Z flexor moment</span>

  // matrix indexes of shape
  public static final int CIRCLE = 0;         // section type, 1 variable (diÃƒÂ¡metro)
  public static final int HOLE_CIRCLE = 1;    // section type, 2 variable (diÃƒÂ¡metro externo y espesor)
  public static final int RECTANGLE = 2;      // section type, 2 variables (y=alto,  z=ancho)
  public static final int HOLE_RECTANGLE = 3; // section type, 4 variables (y, z, eY_, eZ_)
  public static final int I_SINGLE = 4;        // section type, 4 variables (y(alma), z(ala), eY_, eZ_)
  public static final int I_DOUBLE = 5;        // section type, 4 variables (y(alma), z(ala), eY_, eZ_)
  public static final int H_SINGLE = 6;        // section type, 4 variables (y(alma), z(ala), eY_, eZ_)
  public static final int H_DOUBLE = 7;        // section type, 4 variables (y(alma), z(ala), eY_, eZ_)
  public static final int L_SINGLE = 8;        // section type, 4 variables (y(alma), z(ala), eY_, eZ_)
  public static final int L_DOUBLE = 9;        // section type, 4 variables (y(alma), z(ala), eY_, eZ_)
  public static final int T_SINGLE = 10;        // section type, 4 variables (y(alma), z(ala), eY_, eZ_)
  public static final int T_DOUBLE = 11;        // section type, 4 variables (y(alma), z(ala), eY_, eZ_)

<span class="nc" id="L686">  int RIG_RIG = 0;</span>
<span class="nc" id="L687">  int RIG_ART = 1;</span>
<span class="nc" id="L688">  int ART_RIG = 10;</span>
<span class="nc" id="L689">  int ART_ART = 11;</span>

  // matrix indexes of structure elements
  // int INDEX_=0; // id elements groups
<span class="nc" id="L693">  int i_=1; // i, minor number node</span>
<span class="nc" id="L694">  int j_=2; // j, mayor number node</span>
<span class="nc" id="L695">  int L_=3; // length of element</span>
<span class="nc" id="L696">  int Vij_=4; // linked between nodes i and j</span>
<span class="nc" id="L697">  int Ei_=5; // rigidez elÃƒÂ¡stica en nudo i</span>
<span class="nc" id="L698">  int Ej_=6; // rigidez elÃƒÂ¡stica en nudo j</span>

  // beams load index
<span class="nc" id="L701">  int QH_=0; // hipÃƒÂ³tesis de cargas</span>
<span class="nc" id="L702">  int QE_=1; // barra aplicada</span>
<span class="nc" id="L703">  int QT_=2;   //tipo de cargas</span>
<span class="nc" id="L704">  int QAx_=3;  //intensidad en sentido del eje local x</span>
<span class="nc" id="L705">  int QAy_=4;  //intensidad en sentido del eje local y</span>
<span class="nc" id="L706">  int QAz_=5;  //intensidad en sentido del eje local z</span>
<span class="nc" id="L707">  int Qa_=6;   //distancia de aplicaciÃƒÂ³n de la carga respecto al nudo i</span>
<span class="nc" id="L708">  int Qb_=7;   //longitud de la carga aplicada</span>

  // strain matrix
<span class="nc" id="L711">  int STRAIN_COMPRESS = 0;</span>
<span class="nc" id="L712">  int STRAIN_TRACTION = 1;</span>
<span class="nc" id="L713">  int STRAIN_CUT = 2;</span>

  // selected objetive functions
<span class="nc" id="L716">  int  selectedOF = 12;</span>
  String []OF_;

  public OverallConstraintViolation&lt;DoubleSolution&gt; overallConstraintViolationDegree ;

<span class="nc" id="L721">  public Ebes() throws FileNotFoundException {</span>
<span class="nc" id="L722">    overallConstraintViolationDegree = new OverallConstraintViolation&lt;DoubleSolution&gt;() ;</span>
<span class="nc" id="L723">    String file = EBEsReadProblems() + &quot;.ebe&quot;;</span>

<span class="nc" id="L725">    EBEsInitialize(file);</span>
<span class="nc" id="L726">  }</span>

  /**
   * Constructor
   * @throws FileNotFoundException
   */
<span class="nc" id="L732">  public Ebes(String ebesFileName, String[] objectiveList) throws FileNotFoundException {</span>
<span class="nc" id="L733">    overallConstraintViolationDegree = new OverallConstraintViolation&lt;DoubleSolution&gt;() ;</span>
<span class="nc" id="L734">    OF_ = objectiveList ;</span>

<span class="nc" id="L736">    EBEsInitialize(ebesFileName);</span>
<span class="nc" id="L737">  }</span>

  public void EBEsInitialize(String file) throws FileNotFoundException {
    // CALCULAR dd Y CA (CANTIDADES DE NUDOS COARTADOS) AL CARGAR EL ARCHIVO
    // CON ESTO EVITO RECALCULARLOS CADA VEZ QUE SE BUSCA UNA SOLUCIÃƒÂ³N
    // CONTAR EN PENALIZACIÃƒÂ³N DE LA MATRIZ CA Y NO CN, CON ESTO
    // EVITO RECORRER INNECESARIAMENTE TODOS LOS NUDOS

<span class="nc" id="L745">    setName(&quot;Ebes&quot;);</span>
<span class="nc" id="L746">    numberOfEval_ = 1;</span>

    try {
      // read file topology structural
<span class="nc" id="L750">      EBEsReadDataFile(file);</span>
<span class="nc" id="L751">    } catch (JMetalException ex) {</span>
<span class="nc" id="L752">      Logger.getLogger(Ebes.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="nc" id="L753">    }</span>

    // variables and restrictions
    // la forma de la secciÃƒÂ³n determina las cantidades de variables
    // y la cantidad inicial de restricciones

    //numberOfVariables_=0;
<span class="nc" id="L760">    int numberOfConstraints_=0;</span>
      /*
      for(int gr=0;gr&lt;numberOfGroupElements_;gr++){
        numberOfVariables_+= Groups_[gr][VARIABLES];
        numberOfConstraintsGeometric_+= Groups_[gr][CONSTRAINT];
      }
      */
    // variable position, amount variables and geometric constraints
<span class="nc" id="L768">    setNumberOfVariables(Variable_Position());</span>
    // geomtric constraints for shape
<span class="nc" id="L770">    numberOfConstraints_=numberOfConstraintsGeometric_;</span>

    // constraint for stress
<span class="nc" id="L773">    numberOfConstraints_+= numberOfGroupElements_ * 3;</span>

    // total restrictions
<span class="nc" id="L776">    numberOfConstraints_+= numberOfConstraintsNodes_;</span>
<span class="nc" id="L777">    setNumberOfConstraints(numberOfConstraints_);</span>

    // amount objectives
<span class="nc" id="L780">    setNumberOfObjectives(OF_.length);</span>

    // problem data print
<span class="nc" id="L783">    System.out.println(&quot;Structure&quot;);</span>
<span class="nc" id="L784">    System.out.println(&quot;  file: &quot; + file);</span>
<span class="nc" id="L785">    System.out.println(&quot;  Number of Nodes: &quot; + numberOfNodes);</span>
<span class="nc" id="L786">    System.out.println(&quot;  Number of Bars: &quot; + numberOfElements_);</span>
<span class="nc" id="L787">    System.out.println(&quot;  Number of Groups: &quot; + numberOfGroupElements_);</span>
<span class="nc" id="L788">    System.out.println(&quot;Optimization multi-objective: &quot;);</span>
<span class="nc" id="L789">    System.out.println(&quot;  Number of objective function: &quot; + getNumberOfObjectives());</span>
<span class="nc" id="L790">    String txt=&quot;&quot;;</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">    for(int i=0; i&lt;getNumberOfObjectives(); i++)</span>
    {
<span class="nc" id="L793">      txt = txt + OF_[i] + &quot; &quot;;</span>
    }
<span class="nc" id="L795">    System.out.println(&quot;  &quot; + txt);</span>
<span class="nc" id="L796">    System.out.println(&quot;  Number of Variables: &quot; + getNumberOfVariables());</span>
<span class="nc" id="L797">    System.out.println(&quot;  Number of constraints for Geometric: &quot; + numberOfConstraintsGeometric_);</span>
<span class="nc" id="L798">    System.out.println(&quot;  Number of constraints for Stress: &quot; + (numberOfGroupElements_ * 3));</span>
<span class="nc" id="L799">    System.out.println(&quot;  Number of constraints for Deflection: &quot; + numberOfConstraintsNodes_);</span>
<span class="nc" id="L800">    System.out.println(&quot;  Number of Constraints: &quot; + numberOfConstraints_);</span>
<span class="nc" id="L801">    System.out.println(&quot;  Number of groups to check geometry: &quot; + numberOfGroupsToCheckGeometry_);</span>

    // objectives
    // Weight, Deflections, stress squared absolute error;

<span class="nc" id="L806">    System.out.println(&quot;Algorithm configuration: &quot;);</span>

    //Fill lower and upper limits
<span class="nc" id="L809">    Double[] lowerLimit_ = new Double[getNumberOfVariables()];</span>
<span class="nc" id="L810">    Double[] upperLimit_ = new Double[getNumberOfVariables()];</span>
<span class="nc" id="L811">    int var=0;</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">    for (int gr=0; gr&lt;numberOfGroupElements_;gr++){</span>
<span class="nc" id="L813">      var+=Groups_[gr][VARIABLES];</span>

<span class="nc bnc" id="L815" title="All 2 branches missed.">      if (Groups_[gr][SHAPE]==CIRCLE){</span>
<span class="nc" id="L816">        lowerLimit_[var-1] = Groups_[gr][VAR_Y_LOWER_LIMIT]; // diameter min</span>
<span class="nc" id="L817">        upperLimit_[var-1] = Groups_[gr][VAR_Y_UPPER_LIMIT]; // diameter max</span>
      }
<span class="nc bnc" id="L819" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==HOLE_CIRCLE){</span>
<span class="nc" id="L820">        lowerLimit_[var-2] = Groups_[gr][VAR_Y_LOWER_LIMIT]; // diameter min</span>
<span class="nc" id="L821">        lowerLimit_[var-1] = Groups_[gr][VAR_eY_LOWER_LIMIT]; // thickness min</span>
<span class="nc" id="L822">        upperLimit_[var-2] = Groups_[gr][VAR_Y_UPPER_LIMIT]; // diameter max</span>
<span class="nc" id="L823">        upperLimit_[var-1] = Groups_[gr][VAR_eY_UPPER_LIMIT]; // thickness max</span>
      }
<span class="nc bnc" id="L825" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==RECTANGLE){</span>
<span class="nc" id="L826">        lowerLimit_[var-2] = Groups_[gr][VAR_Y_LOWER_LIMIT]; // higth min for rectangle</span>
<span class="nc" id="L827">        lowerLimit_[var-1] = Groups_[gr][VAR_Z_LOWER_LIMIT]; // witdth min</span>
<span class="nc" id="L828">        upperLimit_[var-2] = Groups_[gr][VAR_Y_UPPER_LIMIT]; // higth max for rectangle</span>
<span class="nc" id="L829">        upperLimit_[var-1] = Groups_[gr][VAR_Z_UPPER_LIMIT]; // width max for rectangle</span>
      }
<span class="nc bnc" id="L831" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==HOLE_RECTANGLE){</span>
<span class="nc" id="L832">        lowerLimit_[var-4] = Groups_[gr][VAR_Y_LOWER_LIMIT]; // height min</span>
<span class="nc" id="L833">        lowerLimit_[var-3] = Groups_[gr][VAR_Z_LOWER_LIMIT]; // wide min</span>
<span class="nc" id="L834">        lowerLimit_[var-2] = Groups_[gr][VAR_eY_LOWER_LIMIT];  // tickness min in Y principal local axis</span>
<span class="nc" id="L835">        lowerLimit_[var-1] = Groups_[gr][VAR_eZ_LOWER_LIMIT];  // tickness min in Z principal local axis</span>
<span class="nc" id="L836">        upperLimit_[var-4] = Groups_[gr][VAR_Y_UPPER_LIMIT]; // height max</span>
<span class="nc" id="L837">        upperLimit_[var-3] = Groups_[gr][VAR_Z_UPPER_LIMIT]; // wide max</span>
<span class="nc" id="L838">        upperLimit_[var-2] = Groups_[gr][VAR_eY_UPPER_LIMIT]; // tickness max in Y principal local axis</span>
<span class="nc" id="L839">        upperLimit_[var-1] = Groups_[gr][VAR_eZ_UPPER_LIMIT]; // tickness max in Z principal local axis</span>
      }
<span class="nc bnc" id="L841" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==I_SINGLE){</span>
<span class="nc" id="L842">        lowerLimit_[var-4] = Groups_[gr][VAR_Y_LOWER_LIMIT]; // height min</span>
<span class="nc" id="L843">        lowerLimit_[var-3] = Groups_[gr][VAR_Z_LOWER_LIMIT]; // wide min</span>
<span class="nc" id="L844">        lowerLimit_[var-2] = Groups_[gr][VAR_eY_LOWER_LIMIT]; // tickness min in Y principal local axis</span>
<span class="nc" id="L845">        lowerLimit_[var-1] = Groups_[gr][VAR_eZ_LOWER_LIMIT]; // ticknees min in Z principal local axis</span>
<span class="nc" id="L846">        upperLimit_[var-4] = Groups_[gr][VAR_Y_UPPER_LIMIT]; // height max in y axis</span>
<span class="nc" id="L847">        upperLimit_[var-3] = Groups_[gr][VAR_Z_UPPER_LIMIT]; // wide max in z axiz</span>
<span class="nc" id="L848">        upperLimit_[var-2] = Groups_[gr][VAR_eY_UPPER_LIMIT]; // tickness max in Y principal local axis</span>
<span class="nc" id="L849">        upperLimit_[var-1] = Groups_[gr][VAR_eZ_UPPER_LIMIT]; // tickness max in Z principal local axis</span>
      }
<span class="nc bnc" id="L851" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==I_DOUBLE){</span>
<span class="nc" id="L852">        lowerLimit_[var-4] = Groups_[gr][VAR_Y_LOWER_LIMIT]; // height min</span>
<span class="nc" id="L853">        lowerLimit_[var-3] = Groups_[gr][VAR_Z_LOWER_LIMIT]; // wide min</span>
<span class="nc" id="L854">        lowerLimit_[var-2] = Groups_[gr][VAR_eY_LOWER_LIMIT]; // tickness min in Y principal local axis</span>
<span class="nc" id="L855">        lowerLimit_[var-1] = Groups_[gr][VAR_eZ_LOWER_LIMIT]; // tickness min in Z principal local axis</span>
<span class="nc" id="L856">        upperLimit_[var-4] = Groups_[gr][VAR_Y_UPPER_LIMIT]; // height max</span>
<span class="nc" id="L857">        upperLimit_[var-3] = Groups_[gr][VAR_Z_UPPER_LIMIT]; // wide max in z</span>
<span class="nc" id="L858">        upperLimit_[var-2] = Groups_[gr][VAR_eY_UPPER_LIMIT]; // tickness max in Y principal local axis</span>
<span class="nc" id="L859">        upperLimit_[var-1] = Groups_[gr][VAR_eZ_UPPER_LIMIT]; // thickness max in plate z</span>
      }
<span class="nc bnc" id="L861" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==H_SINGLE){</span>
<span class="nc" id="L862">        lowerLimit_[var-4] = Groups_[gr][VAR_Y_LOWER_LIMIT]; // height min</span>
<span class="nc" id="L863">        lowerLimit_[var-3] = Groups_[gr][VAR_Z_LOWER_LIMIT]; // wide min</span>
<span class="nc" id="L864">        lowerLimit_[var-2] = Groups_[gr][VAR_eY_LOWER_LIMIT]; // tickness min in Y principal local axis</span>
<span class="nc" id="L865">        lowerLimit_[var-1] = Groups_[gr][VAR_eZ_LOWER_LIMIT]; // ticknees min in Z principal local axis</span>
<span class="nc" id="L866">        upperLimit_[var-4] = Groups_[gr][VAR_Y_UPPER_LIMIT]; // height max in y axis</span>
<span class="nc" id="L867">        upperLimit_[var-3] = Groups_[gr][VAR_Z_UPPER_LIMIT]; // wide max in z axiz</span>
<span class="nc" id="L868">        upperLimit_[var-2] = Groups_[gr][VAR_eY_UPPER_LIMIT]; // tickness max in Y principal local axis</span>
<span class="nc" id="L869">        upperLimit_[var-1] = Groups_[gr][VAR_eZ_UPPER_LIMIT]; // tickness max in Z principal local axis</span>
      }
<span class="nc bnc" id="L871" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==H_DOUBLE){</span>
<span class="nc" id="L872">        lowerLimit_[var-4] = Groups_[gr][VAR_Y_LOWER_LIMIT]; // height min</span>
<span class="nc" id="L873">        lowerLimit_[var-3] = Groups_[gr][VAR_Z_LOWER_LIMIT]; // wide min</span>
<span class="nc" id="L874">        lowerLimit_[var-2] = Groups_[gr][VAR_eY_LOWER_LIMIT]; // tickness min in Y principal local axis</span>
<span class="nc" id="L875">        lowerLimit_[var-1] = Groups_[gr][VAR_eZ_LOWER_LIMIT]; // tickness min in Z principal local axis</span>
<span class="nc" id="L876">        upperLimit_[var-4] = Groups_[gr][VAR_Y_UPPER_LIMIT]; // height max</span>
<span class="nc" id="L877">        upperLimit_[var-3] = Groups_[gr][VAR_Z_UPPER_LIMIT]; // wide max in z</span>
<span class="nc" id="L878">        upperLimit_[var-2] = Groups_[gr][VAR_eY_UPPER_LIMIT]; // tickness max in Y principal local axis</span>
<span class="nc" id="L879">        upperLimit_[var-1] = Groups_[gr][VAR_eZ_UPPER_LIMIT]; // thickness max in plate z</span>
      }
<span class="nc bnc" id="L881" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==L_SINGLE){</span>
<span class="nc" id="L882">        lowerLimit_[var-4] = Groups_[gr][VAR_Y_LOWER_LIMIT]; // height min</span>
<span class="nc" id="L883">        lowerLimit_[var-3] = Groups_[gr][VAR_Z_LOWER_LIMIT]; // wide min</span>
<span class="nc" id="L884">        lowerLimit_[var-2] = Groups_[gr][VAR_eY_LOWER_LIMIT]; // ticknees min in plate y</span>
<span class="nc" id="L885">        lowerLimit_[var-1] = Groups_[gr][VAR_eZ_LOWER_LIMIT]; // ticknees min in plate z</span>
<span class="nc" id="L886">        upperLimit_[var-4] = Groups_[gr][VAR_Y_UPPER_LIMIT]; // height max</span>
<span class="nc" id="L887">        upperLimit_[var-3] = Groups_[gr][VAR_Z_UPPER_LIMIT]; // wide max in z</span>
<span class="nc" id="L888">        upperLimit_[var-2] = Groups_[gr][VAR_eY_UPPER_LIMIT]; // thickness max in</span>
<span class="nc" id="L889">        upperLimit_[var-1] = Groups_[gr][VAR_eZ_UPPER_LIMIT]; // thickness max in</span>
      }
<span class="nc bnc" id="L891" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==L_DOUBLE){</span>
<span class="nc" id="L892">        lowerLimit_[var-4] = Groups_[gr][VAR_Y_LOWER_LIMIT]; // height min</span>
<span class="nc" id="L893">        lowerLimit_[var-3] = Groups_[gr][VAR_Z_LOWER_LIMIT]; // wide min</span>
<span class="nc" id="L894">        lowerLimit_[var-2] = Groups_[gr][VAR_eY_LOWER_LIMIT]; // ticknees min in</span>
<span class="nc" id="L895">        lowerLimit_[var-1] = Groups_[gr][VAR_eZ_LOWER_LIMIT]; // ticknees min in</span>
<span class="nc" id="L896">        upperLimit_[var-4] = Groups_[gr][VAR_Y_UPPER_LIMIT]; // height max</span>
<span class="nc" id="L897">        upperLimit_[var-3] = Groups_[gr][VAR_Z_UPPER_LIMIT]; // wide max in z</span>
<span class="nc" id="L898">        upperLimit_[var-2] = Groups_[gr][VAR_eY_UPPER_LIMIT]; // thickness max in</span>
<span class="nc" id="L899">        upperLimit_[var-1] = Groups_[gr][VAR_eZ_UPPER_LIMIT]; // thickness max in</span>
      }
<span class="nc bnc" id="L901" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==T_SINGLE){</span>
<span class="nc" id="L902">        lowerLimit_[var-4] = Groups_[gr][VAR_Y_LOWER_LIMIT]; // height min</span>
<span class="nc" id="L903">        lowerLimit_[var-3] = Groups_[gr][VAR_Z_LOWER_LIMIT]; // wide min</span>
<span class="nc" id="L904">        lowerLimit_[var-2] = Groups_[gr][VAR_eY_LOWER_LIMIT]; // ticknees min in plate y</span>
<span class="nc" id="L905">        lowerLimit_[var-1] = Groups_[gr][VAR_eZ_LOWER_LIMIT]; // ticknees min in plate z</span>
<span class="nc" id="L906">        upperLimit_[var-4] = Groups_[gr][VAR_Y_UPPER_LIMIT]; // height max</span>
<span class="nc" id="L907">        upperLimit_[var-3] = Groups_[gr][VAR_Z_UPPER_LIMIT]; // wide max in z</span>
<span class="nc" id="L908">        upperLimit_[var-2] = Groups_[gr][VAR_eY_UPPER_LIMIT]; // thickness max in</span>
<span class="nc" id="L909">        upperLimit_[var-1] = Groups_[gr][VAR_eZ_UPPER_LIMIT]; // thickness max in</span>
      }
<span class="nc bnc" id="L911" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==T_DOUBLE){</span>
<span class="nc" id="L912">        lowerLimit_[var-4] = Groups_[gr][VAR_Y_LOWER_LIMIT]; // height min</span>
<span class="nc" id="L913">        lowerLimit_[var-3] = Groups_[gr][VAR_Z_LOWER_LIMIT]; // wide min</span>
<span class="nc" id="L914">        lowerLimit_[var-2] = Groups_[gr][VAR_eY_LOWER_LIMIT]; // ticknees min in</span>
<span class="nc" id="L915">        lowerLimit_[var-1] = Groups_[gr][VAR_eZ_LOWER_LIMIT]; // ticknees min in</span>
<span class="nc" id="L916">        upperLimit_[var-4] = Groups_[gr][VAR_Y_UPPER_LIMIT]; // height max</span>
<span class="nc" id="L917">        upperLimit_[var-3] = Groups_[gr][VAR_Z_UPPER_LIMIT]; // wide max in z</span>
<span class="nc" id="L918">        upperLimit_[var-2] = Groups_[gr][VAR_eY_UPPER_LIMIT]; // thickness max in</span>
<span class="nc" id="L919">        upperLimit_[var-1] = Groups_[gr][VAR_eZ_UPPER_LIMIT]; // thickness max in</span>
      }
      else{
<span class="nc" id="L922">        System.out.println(&quot;Error in LIMITES LOWER/UPPER: transversal section not considerated for: &quot; + gr + &quot; group&quot;) ;</span>
      } // end if
    } // gr

<span class="nc" id="L926">    setLowerLimit(new ArrayList&lt;Double&gt;(Arrays.&lt;Double&gt;asList(lowerLimit_)));</span>
<span class="nc" id="L927">    setUpperLimit(new ArrayList&lt;Double&gt;(Arrays.&lt;Double&gt;asList(upperLimit_)));</span>

    // greates difference between nodes
<span class="nc" id="L930">    elementsBetweenDiffGreat_ = 0;</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">    for(int ba = 0; ba&lt;numberOfElements_; ba++){</span>
<span class="nc" id="L932">      int i = (int)Element_[ba][i_];</span>
<span class="nc" id="L933">      int j = (int)Element_[ba][j_];</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">      if (Math.abs(j - i) &gt; elementsBetweenDiffGreat_){</span>
<span class="nc" id="L935">        elementsBetweenDiffGreat_ = Math.abs(j - i);</span>
      }
    }
<span class="nc" id="L938">    matrixWidthBand_ = (elementsBetweenDiffGreat_ +1) * numberOfLibertyDegree_;</span>

<span class="nc" id="L940">  } // end InitializeEBEs</span>

  @Override
  public DoubleSolution createSolution() {
<span class="nc" id="L944">    return new DefaultDoubleSolution(this) ;</span>
  }

  /**
   * Evaluates a solution
   * @param solution The solution to evaluate
   */
  @Override
  public void evaluate(DoubleSolution solution) {

<span class="nc" id="L954">    int hi=0;</span>
<span class="nc" id="L955">    double [] fx = new double[getNumberOfObjectives()] ; // functions</span>

<span class="nc" id="L957">    EBEsElementsTopology(solution); // transforma geometria a caracterÃƒÂ­sticas mecÃƒÂ¡nicas</span>

<span class="nc" id="L959">    EBEsCalculus(); //  metodo matricial de la rigidez para estructuras espaciales (3D)</span>

    // START OBJETIVES FUNCTION
<span class="nc bnc" id="L962" title="All 2 branches missed.">    for(int j=0; j&lt;getNumberOfObjectives(); j++)</span>
    {
      // total weight
<span class="nc bnc" id="L965" title="All 2 branches missed.">      if(OF_[j].equals(&quot;W&quot;))</span>
      {
        // START structure total weight ---------------------
<span class="nc" id="L968">        fx[j]=0.0;</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">        for(int ba=0; ba&lt;numberOfElements_; ba++){</span>
<span class="nc" id="L970">          int idx =(int)Element_[ba][INDEX_];</span>
<span class="nc" id="L971">          fx[j]+=Groups_[idx][AREA]*Element_[ba][L_]*Groups_[idx][SPECIFIC_WEIGHT];</span>
        }
<span class="nc" id="L973">        solution.setObjective(j, fx[j]);</span>
        // END minimizing structure total weight ------------------------
      }
      // summation of deformations
<span class="nc bnc" id="L977" title="All 2 branches missed.">      else if(OF_[j].equals(&quot;D&quot;))</span>
      {
        // START maximize displacement nodes ---------------------------------------------
<span class="nc" id="L980">        fx[j] = 0.0;</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">        for(int i=0;i&lt;nodeCheck_.length;i++){</span>
<span class="nc" id="L982">          double xn=DisplacementNodes_[numberOfLibertyDegree_ * (int)nodeCheck_[i][0]+aX_][hi];</span>
<span class="nc" id="L983">          double yn=DisplacementNodes_[numberOfLibertyDegree_ * (int)nodeCheck_[i][0]+aY_][hi];</span>
<span class="nc" id="L984">          double zn=DisplacementNodes_[numberOfLibertyDegree_ * (int)nodeCheck_[i][0]+aZ_][hi];</span>
<span class="nc" id="L985">          fx[j]+= Math.sqrt(Math.pow(xn,2.0)+Math.pow(yn,2.0)+Math.pow(zn,2.0));</span>
        }
<span class="nc" id="L987">        solution.setObjective(j, fx[j]);</span>
        // END minimizing sum of displacement in nodes ---------------------------------------------
      }
      // stress square absolute error
<span class="nc bnc" id="L991" title="All 2 branches missed.">      else if(OF_[j].equals(&quot;SSAE&quot;))</span>
      {
        // START strain residual minimun ---------------------------------------------
        // strain residualt global
<span class="nc" id="L995">        fx[j]=StrainResidualMin_[hi]+StrainResidualMax_[hi];</span>
<span class="nc" id="L996">        solution.setObjective(j, fx[j]);</span>
        // END strain residual minimun ---------------------------------------------
      }
      // Efficiency of Nash-Sutcliffe for stress and compress
<span class="nc bnc" id="L1000" title="All 2 branches missed.">      else if(OF_[j].equals(&quot;ENS&quot;))</span>
      {
<span class="nc" id="L1002">        fx[j]=FunctionENS(0);</span>
<span class="nc" id="L1003">        solution.setObjective(j, fx[j]);</span>
      }
<span class="nc bnc" id="L1005" title="All 2 branches missed.">      else if(OF_[j].equals(&quot;MDV&quot;))</span>
      {
<span class="nc" id="L1007">        fx[j]=FunctionsMahalanobis_Distance_With_Variance(0);</span>
<span class="nc" id="L1008">        solution.setObjective(j, fx[j]);</span>
      }
      else
      {
<span class="nc" id="L1012">        System.out.println(&quot;Error: not considerate START OBJECTIVES FUNCTION &quot;);</span>
      }
    }

<span class="nc" id="L1016">    numberOfEval_++;</span>

<span class="nc bnc" id="L1018" title="All 2 branches missed.">    if((numberOfEval_ % 1000) == 0) System.out.println(numberOfEval_);</span>

    //  END OBJETIVES FUNCTION

    // maximizing the function objective ------------------------
    // fx[1] *= -1.0;



    // NOT USED -----------------------------------
/*
    double l=0; // longitud total de todos los elementos
    // total deflection of estructure
    fx[1]=0;
    for(int ba=0; ba&lt;numberOfElements_; ba++){
        l+=Element_[ba][L_];
        int ni = (int)Element_[ba][i_];
        int nj = (int)Element_[ba][j_];
        double dxi=DisplacementNodes_[numberOfLibertyDegree_*ni+aX_][hi];
        double dyi=DisplacementNodes_[numberOfLibertyDegree_*ni+aY_][hi];
        double dzi=DisplacementNodes_[numberOfLibertyDegree_*ni+aZ_][hi];
        double dxj=DisplacementNodes_[numberOfLibertyDegree_*nj+aX_][hi];
        double dyj=DisplacementNodes_[numberOfLibertyDegree_*nj+aY_][hi];
        double dzj=DisplacementNodes_[numberOfLibertyDegree_*nj+aZ_][hi];
        // fx[1]+=Math.sqrt(Math.pow((dxi-dxj), 2.0)+Math.pow((dyi-dyj), 2.0)+Math.pow((dzi-dzj), 2.0))/l;
        fx[1]+=(-dxi+dxj)/l;
    }
*/
    // END NOT USED ------------------------------------------------------------------------------

<span class="nc" id="L1048">  } // evaluate</span>

  /**
   * Evaluates the constraint overhead of a solution
   * @param solution The solution
   * @throws JMetalException
   */
  @Override
  public void evaluateConstraints(DoubleSolution solution) {
<span class="nc" id="L1057">    double [] constraint = new double[this.getNumberOfConstraints()];</span>
<span class="nc" id="L1058">    double[] x = new double[getNumberOfVariables()] ;</span>

<span class="nc bnc" id="L1060" title="All 2 branches missed.">    for (int i = 0; i &lt; getNumberOfVariables(); i++) {</span>
<span class="nc" id="L1061">      x[i] = solution.getVariableValue(i) ;</span>
    }

    double x1, x2, x3, x4;
<span class="nc" id="L1065">    int var=0;</span>
<span class="nc" id="L1066">    int con=0;</span>

    // restricciones de relaciÃƒÂ³n de forma en las paredes b/t
<span class="nc bnc" id="L1069" title="All 2 branches missed.">    for (int gr=0; gr&lt;numberOfGroupElements_;gr++){</span>

<span class="nc" id="L1071">      var+=Groups_[gr][VARIABLES];</span>
<span class="nc" id="L1072">      con+=Groups_[gr][CONSTRAINT];</span>

<span class="nc bnc" id="L1074" title="All 2 branches missed.">      if (Groups_[gr][SHAPE]==CIRCLE){</span>
<span class="nc" id="L1075">        x1=x[var-1]; // diameter</span>
      }
<span class="nc bnc" id="L1077" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==HOLE_CIRCLE){</span>
<span class="nc" id="L1078">        x1=x[var-2]; // diameter</span>
<span class="nc" id="L1079">        x2=x[var-1]; // tickness plate</span>

<span class="nc" id="L1081">        double ratio=x1/x2;</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">        if(ratio&lt;x2/x1) ratio=x2/x1;</span>
<span class="nc" id="L1083">        constraint[con-1]=-ratio+Groups_[gr][RATIO_YZ]; // relaciÃƒÂ³n entre altura y base</span>
<span class="nc" id="L1084">      }</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==RECTANGLE){</span>
<span class="nc" id="L1086">        x1=x[var-2]; // higth (y axis)</span>
<span class="nc" id="L1087">        x2=x[var-1]; // witdth (z axis)</span>

<span class="nc" id="L1089">        double ratio = x1/x2;</span>
<span class="nc" id="L1090">        constraint[con-2]=+ratio-Groups_[gr][RATIO_YZ]*0.75; // relaciÃƒÂ³n entre altura y base maxima</span>
<span class="nc" id="L1091">        constraint[con-1]=-ratio+Groups_[gr][RATIO_YZ]*1.5; // relaciÃƒÂ³n entre altura y base minima</span>

<span class="nc" id="L1093">      }</span>

<span class="nc bnc" id="L1095" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==HOLE_RECTANGLE){</span>
<span class="nc" id="L1096">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1097">        x2=x[var-3]; // width (z axis)</span>
<span class="nc" id="L1098">        x3=x[var-2]; // tickness along Y axis =&gt; tickness of width  plate</span>
<span class="nc" id="L1099">        x4=x[var-1]; // tickness along Z axis =&gt; tickness of heigth plate</span>

<span class="nc" id="L1101">        double ratio=x1/x2;</span>
<span class="nc" id="L1102">        constraint[con-4]=+ratio-Groups_[gr][RATIO_YZ]*0.75; // relaciÃƒÂ³n entre altura y base maxima</span>
<span class="nc" id="L1103">        constraint[con-3]=-ratio+Groups_[gr][RATIO_YZ]*1.25; // relaciÃƒÂ³n entre altura y base minima</span>

<span class="nc" id="L1105">        double tb1=-x3*15+x1;</span>
<span class="nc" id="L1106">        double tb2=+x3*30-x1;</span>
<span class="nc" id="L1107">        double ta1=-x4*10+x2;</span>
<span class="nc" id="L1108">        double ta2=+x4*20-x2;</span>
        //double ta2=-x2/x4+27;//0.3*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS])); // relaciÃƒÂ³n entre espesor de la placa y altura de lados
<span class="nc" id="L1110">        constraint[con-2]=Math.min(tb1, tb2);//-x1/x3+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1111">        constraint[con-1]=Math.min(ta1, ta2);//-x2/x4+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>

<span class="nc" id="L1113">      }</span>

<span class="nc bnc" id="L1115" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==I_SINGLE){</span>
<span class="nc" id="L1116">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1117">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1118">        x3=x[var-2]; // tickness along Y axis =&gt; tickness of width  plate</span>
<span class="nc" id="L1119">        x4=x[var-1]; // tickness along Z axis =&gt; tickness of heigth plate</span>

<span class="nc" id="L1121">        double ratio=x1/x2;</span>
<span class="nc" id="L1122">        constraint[con-4]=+ratio-Groups_[gr][RATIO_YZ]*0.75; // relaciÃƒÂ³n entre altura y base maxima</span>
<span class="nc" id="L1123">        constraint[con-3]=-ratio+Groups_[gr][RATIO_YZ]*1.25; // relaciÃƒÂ³n entre altura y base minima</span>

<span class="nc" id="L1125">        double tb1=-x3*15+x1;</span>
<span class="nc" id="L1126">        double tb2=+x3*30-x1;</span>
<span class="nc" id="L1127">        double ta1=-x4*10+x2;</span>
<span class="nc" id="L1128">        double ta2=+x4*20-x2;</span>

        //double tb1=-x3*20+x1;
        //double tb2=-x1/x3+35;//0.6*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS])); // relaciÃƒÂ³n entre espesor de la placa y altura de lados
        //double ta1=-x4*15+x2;
        //double ta2=-x2/x4+27;//0.3*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS])); // relaciÃƒÂ³n entre espesor de la placa y altura de lados
<span class="nc" id="L1134">        constraint[con-2]=Math.min(tb1, tb2);//-x1/x3+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1135">        constraint[con-1]=Math.min(ta1, ta2);//-x2/x4+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>

<span class="nc" id="L1137">      }</span>

<span class="nc bnc" id="L1139" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==I_DOUBLE){</span>
<span class="nc" id="L1140">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1141">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1142">        x3=x[var-2]; // tickness along Y axis =&gt; tickness of width  plate</span>
<span class="nc" id="L1143">        x4=x[var-1]; // tickness along Z axis =&gt; tickness of heigth plate</span>
<span class="nc" id="L1144">        double ratio=x1/x2;</span>
<span class="nc" id="L1145">        constraint[con-4]=-ratio+Groups_[gr][RATIO_YZ]; // relaciÃƒÂ³n entre altura y base maxima</span>
<span class="nc" id="L1146">        constraint[con-3]=+ratio-Groups_[gr][RATIO_YZ]*0.85; // /2.0 relaciÃƒÂ³n entre altura y base minima</span>
<span class="nc" id="L1147">        constraint[con-2]=-x1/x3+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS])); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1148">        constraint[con-1]=-x2/x4+0.35*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS_CUT]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1149">      }</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==H_SINGLE){</span>
<span class="nc" id="L1151">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1152">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1153">        x3=x[var-2]; // tickness along Y axis =&gt; tickness of width  plate</span>
<span class="nc" id="L1154">        x4=x[var-1]; // tickness along Z axis =&gt; tickness of heigth plate</span>
<span class="nc" id="L1155">        double ratio=x1/x2;</span>
<span class="nc" id="L1156">        constraint[con-4]=-ratio+Groups_[gr][RATIO_YZ]*0.85; // /2.0 relaciÃƒÂ³n entre altura y base maxima</span>
<span class="nc" id="L1157">        constraint[con-3]=+ratio-Groups_[gr][RATIO_YZ]; // relaciÃƒÂ³n entre altura y base minima</span>
<span class="nc" id="L1158">        constraint[con-2]=-x1/x3+0.35*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS_CUT]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1159">        constraint[con-1]=-x2/x4+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1160">      }</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==H_DOUBLE){</span>
<span class="nc" id="L1162">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1163">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1164">        x3=x[var-2]; // thickness along Y axis =&gt; thickness of width  plate</span>
<span class="nc" id="L1165">        x4=x[var-1]; // thickness along Z axis =&gt; thickness of heigth plate</span>
<span class="nc" id="L1166">        double ratio=x1/x2;</span>
<span class="nc" id="L1167">        constraint[con-4]=-ratio+Groups_[gr][RATIO_YZ]*0.1; // 2.0 relaciÃƒÂ³n entre altura y base maxima</span>
<span class="nc" id="L1168">        constraint[con-3]=+ratio-Groups_[gr][RATIO_YZ]; // relaciÃƒÂ³n entre altura y base minima</span>
<span class="nc" id="L1169">        constraint[con-2]=-x1/x3+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS_CUT]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1170">        constraint[con-1]=-x2/x4+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1171">      }</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==L_SINGLE){</span>
<span class="nc" id="L1173">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1174">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1175">        x3=x[var-2]; // thickness along Y axis =&gt; thickness of width  plate</span>
<span class="nc" id="L1176">        x4=x[var-1]; // thickness along Z axis =&gt; thickness heigth plate</span>
<span class="nc" id="L1177">        double ratio=x1/x2;</span>
<span class="nc" id="L1178">        constraint[con-4]=-ratio+Groups_[gr][RATIO_YZ]; // ratio between height and base</span>
<span class="nc" id="L1179">        constraint[con-3]=+ratio-Groups_[gr][RATIO_YZ]; // relaciÃƒÂ³n entre altura y base minima</span>
<span class="nc" id="L1180">        constraint[con-2]=-x1/x3+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1181">        constraint[con-1]=-x2/x4+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1182">      }</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==L_DOUBLE){</span>
<span class="nc" id="L1184">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1185">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1186">        x3=x[var-2]; // tickness along Y axis =&gt; tickness of width  plate</span>
<span class="nc" id="L1187">        x4=x[var-1]; // tickness along Z axis =&gt; tickness of heigth plate</span>
<span class="nc" id="L1188">        double ratio=x1/x2;</span>
<span class="nc" id="L1189">        constraint[con-4]=-ratio+Groups_[gr][RATIO_YZ]; // relaciÃƒÂ³n entre altura y base maxima</span>
<span class="nc" id="L1190">        constraint[con-3]=+ratio-Groups_[gr][RATIO_YZ]; // relaciÃƒÂ³n entre altura y base minima</span>
<span class="nc" id="L1191">        constraint[con-2]=-x1/x3+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1192">        constraint[con-1]=-x2/x4+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1193">      }</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==T_SINGLE){</span>
<span class="nc" id="L1195">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1196">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1197">        x3=x[var-2]; // tickness along Y axis =&gt; tickness of width  plate</span>
<span class="nc" id="L1198">        x4=x[var-1]; // tickness along Z axis =&gt; tickness of heigth plate</span>
<span class="nc" id="L1199">        double ratio=x1/x2;</span>
<span class="nc" id="L1200">        constraint[con-4]=-ratio+Groups_[gr][RATIO_YZ]; // relaciÃƒÂ³n entre altura y base maxima</span>
<span class="nc" id="L1201">        constraint[con-3]=+ratio-Groups_[gr][RATIO_YZ]*0.9; // 2.0 relaciÃƒÂ³n entre altura y base minima</span>
<span class="nc" id="L1202">        constraint[con-2]=-x1/x3+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1203">        constraint[con-1]=-x2/x4+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1204">      }</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==T_DOUBLE){</span>
<span class="nc" id="L1206">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1207">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1208">        x3=x[var-2]; // tickness along Y axis =&gt; tickness of width  plate</span>
<span class="nc" id="L1209">        x4=x[var-1]; // tickness along Z axis =&gt; tickness of heigth plate</span>
<span class="nc" id="L1210">        double ratio=x1/x2;</span>
<span class="nc" id="L1211">        constraint[con-4]=-ratio+Groups_[gr][RATIO_YZ]; // relaciÃƒÂ³n entre altura y base maxima</span>
<span class="nc" id="L1212">        constraint[con-3]=+ratio-Groups_[gr][RATIO_YZ]*0.9; // 2.0 relaciÃƒÂ³n entre altura y base minima</span>
<span class="nc" id="L1213">        constraint[con-2]=-x1/x3+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1214">        constraint[con-1]=-x2/x4+1.12*Math.sqrt(Groups_[gr][E_]/(Groups_[gr][STRESS]*2.0)); // relaciÃƒÂ³n entre espesor de la placa y altura de lados</span>
<span class="nc" id="L1215">      }</span>
      else{
<span class="nc" id="L1217">        System.out.println(&quot;Error in constraint: transverse section not considerated for: &quot; + gr + &quot; group&quot;) ;</span>
      }
    } // next gr

/*
    // LONGITUD TOTAL DE LA VIGA
    double l=0;
    for(int ba=0; ba&lt;numberOfElements_; ba++){
        l+=Element_[ba][2];
    }
*/

    // RESTRICCIONES POR TENSIÃ“N
<span class="nc bnc" id="L1230" title="All 2 branches missed.">    for(int hi=0; hi&lt;numberOfWeigthHypothesis_; hi++){</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">      for(int gr=0; gr&lt;numberOfGroupElements_; gr++){</span>

        // RESTRICCIONES DEBIDO A LA TENSIÃƒÂ³N DE TRACCIÃƒÂ³N
<span class="nc" id="L1234">        constraint[con]=(-StrainMax_[gr][hi]+Groups_[gr][STRESS]); // -StrainMax_[gr][hi]*1.001+Groups_[gr][STRESS]</span>
<span class="nc" id="L1235">        con += 1;</span>

        //constraint[con]=(-StrainMax_[gr][hi]+Groups_[gr][STRESS]*0.50); // -StrainMax_[gr][hi]*1.001+Groups_[gr][STRESS]
        //con += 1;

        // RESTRICCIONES DEBIDO A LA TENSIÃƒÂ³N DE COMPRESIÃƒÂ³N
<span class="nc" id="L1241">        constraint[con]=(+StrainMin_[gr][hi]-Groups_[gr][COMPRESSION]); // +StrainMin_[gr][hi]*0.999-Groups_[gr][COMPRESSION]</span>
<span class="nc" id="L1242">        con += 1;</span>

        //constraint[con]=(+StrainMin_[gr][hi]+Groups_[gr][COMPRESSION]*0.50); // +StrainMin_[gr][hi]*0.999-Groups_[gr][COMPRESSION]
        //con += 1;

        // RESTRICCIONES DEBIDO A LA TENSIÃƒâ€œN DE CORTE
<span class="nc" id="L1248">        constraint[con]=(-StrainCutMax_[gr][hi]+Groups_[gr][STRESS_CUT]); // -StrainCutMax_[gr][hi]*1.001+Groups_[gr][STRESS_CUT]</span>
<span class="nc" id="L1249">        con += 1;</span>
      }
    }


<span class="nc bnc" id="L1254" title="All 2 branches missed.">    for(int hi=0; hi&lt;numberOfWeigthHypothesis_; hi++){</span>
      // constraint of node displacement structure
<span class="nc" id="L1256">      double deltaN=0;</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">      for(int i=0;i&lt;nodeCheck_.length;i++){</span>
<span class="nc" id="L1258">        double xn=DisplacementNodes_[numberOfLibertyDegree_ * (int)nodeCheck_[i][0]+aX_][hi];</span>
<span class="nc" id="L1259">        double yn=DisplacementNodes_[numberOfLibertyDegree_ * (int)nodeCheck_[i][0]+aY_][hi];</span>
<span class="nc" id="L1260">        double zn=DisplacementNodes_[numberOfLibertyDegree_ * (int)nodeCheck_[i][0]+aZ_][hi];</span>
<span class="nc" id="L1261">        deltaN= Math.sqrt(Math.pow(xn,2)+Math.pow(yn,2)+Math.pow(zn,2));</span>
<span class="nc" id="L1262">        constraint[con]= (-deltaN +nodeCheck_[i][1]);</span>
<span class="nc" id="L1263">        con+=1;</span>
      }
    }

    //constraint[0]=Math.sqrt(Math.pow(x, 2)+Math.pow(y, 2)+Math.pow(z, 2))+0.005;
    //descenso mÃƒÂ¡ximo en un nudo
    //constraint[1]=StrainResidual_[0][hi];


<span class="nc" id="L1272">    double total = 0.0;</span>
    //int number = 0;
<span class="nc bnc" id="L1274" title="All 2 branches missed.">    for (int i = 0; i &lt; this.getNumberOfConstraints(); i++)</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">      if (constraint[i]&lt;0.0){</span>
<span class="nc" id="L1276">        total+=constraint[i];</span>
        //number++;
      }
<span class="nc" id="L1279">    overallConstraintViolationDegree.setAttribute(solution, total);</span>
    //solution.setOverallConstraintViolationDegree(total);
    //solution.setNumberOfViolatedConstraint(number);

<span class="nc" id="L1283">  } // evaluateConstraints</span>

  public void EBEsElementsTopology(DoubleSolution solution) throws JMetalException{
    // asignaciÃƒÂ³n de las variables para cada grupo
    // y determinaciÃƒÂ³n de las caracterÃƒÂ­sticas mecÃƒÂ¡nicas

<span class="nc" id="L1289">    double[] x = new double[solution.getNumberOfVariables()];</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">    for (int i = 0; i &lt; solution.getNumberOfVariables(); i++) {</span>
<span class="nc" id="L1291">      x[i] = solution.getVariableValue(i) ;</span>
    }

    double x1, x2, x3, x4;

<span class="nc" id="L1296">    int var=0;</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">    for (int gr=0; gr&lt;numberOfGroupElements_;gr++){</span>

<span class="nc" id="L1299">      var+=Groups_[gr][VARIABLES];</span>

<span class="nc bnc" id="L1301" title="All 2 branches missed.">      if (Groups_[gr][SHAPE]==CIRCLE){</span>
<span class="nc" id="L1302">        x1=x[var-1]; // diameter</span>
<span class="nc" id="L1303">        EBEsTransversalSectionCircular(gr, x1);</span>
      }
<span class="nc bnc" id="L1305" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==HOLE_CIRCLE){</span>
<span class="nc" id="L1306">        x1=x[var-2]; // diameter</span>
<span class="nc" id="L1307">        x2=x[var-1]; // tickness plate</span>
<span class="nc" id="L1308">        EBEsTransversalSectionHoleCircular(gr, x1, x2);</span>
      }
<span class="nc bnc" id="L1310" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==RECTANGLE){</span>
<span class="nc" id="L1311">        x1=x[var-2]; // higth (y axis)</span>
<span class="nc" id="L1312">        x2=x[var-1]; // witdth (z axis)</span>
<span class="nc" id="L1313">        EBEsTransversalSectionRectangle(gr, x1, x2);</span>
      }
<span class="nc bnc" id="L1315" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==HOLE_RECTANGLE){</span>
<span class="nc" id="L1316">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1317">        x2=x[var-3]; // width (z axis)</span>
<span class="nc" id="L1318">        x3=x[var-2]; // horizontal plate tickness (up and down)</span>
<span class="nc" id="L1319">        x4=x[var-1]; // vertical plate tickness (left and right)</span>
<span class="nc" id="L1320">        EBEsTransversalSectionHoleRectangle(gr, x1, x2, x3, x4);</span>
      }
<span class="nc bnc" id="L1322" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==I_SINGLE){</span>

        //EbesMutation(gr, 0, x);

<span class="nc" id="L1326">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1327">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1328">        x3=x[var-2]; // plate tickness heigth and down</span>
<span class="nc" id="L1329">        x4=x[var-1]; // vertical plate tickness (centre)</span>
<span class="nc" id="L1330">        EBEsTransversalSection_I_Single(gr, x1, x2, x3, x4);</span>
      }
<span class="nc bnc" id="L1332" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==I_DOUBLE){</span>
<span class="nc" id="L1333">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1334">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1335">        x3=x[var-2]; // tickness heigth plate</span>
<span class="nc" id="L1336">        x4=x[var-1]; // tickness width plate</span>
<span class="nc" id="L1337">        EBEsTransversalSection_I_Double(gr, x1, x2, x3, x4);</span>
      }
<span class="nc bnc" id="L1339" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==H_SINGLE){</span>
<span class="nc" id="L1340">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1341">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1342">        x3=x[var-2]; // tickness heigth plate</span>
<span class="nc" id="L1343">        x4=x[var-1]; // tickness width plate</span>
<span class="nc" id="L1344">        EBEsTransversalSection_H_Single(gr, x1, x2, x3, x4);</span>
      }
<span class="nc bnc" id="L1346" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==H_DOUBLE){</span>
<span class="nc" id="L1347">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1348">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1349">        x3=x[var-2]; // tickness heigth plate</span>
<span class="nc" id="L1350">        x4=x[var-1]; // tickness width plate</span>
<span class="nc" id="L1351">        EBEsTransversalSection_H_Double(gr, x1, x2, x3, x4);</span>
      }
<span class="nc bnc" id="L1353" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==L_SINGLE){</span>
<span class="nc" id="L1354">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1355">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1356">        x3=x[var-2]; // tickness heigth plate</span>
<span class="nc" id="L1357">        x4=x[var-1]; // tickness width plate</span>
<span class="nc" id="L1358">        EBEsTransversalSection_L_Single(gr, x1, x2, x3, x4);</span>
      }
<span class="nc bnc" id="L1360" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==L_DOUBLE){</span>
<span class="nc" id="L1361">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1362">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1363">        x3=x[var-2]; // tickness heigth plate</span>
<span class="nc" id="L1364">        x4=x[var-1]; // tickness width plate</span>
<span class="nc" id="L1365">        EBEsTransversalSection_L_Double(gr, x1, x2, x3, x4);</span>
      }
<span class="nc bnc" id="L1367" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==T_SINGLE){</span>
<span class="nc" id="L1368">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1369">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1370">        x3=x[var-2]; // tickness heigth plate</span>
<span class="nc" id="L1371">        x4=x[var-1]; // tickness width plate</span>
<span class="nc" id="L1372">        EBEsTransversalSection_T_Single(gr, x1, x2, x3, x4);</span>
      }
<span class="nc bnc" id="L1374" title="All 2 branches missed.">      else if (Groups_[gr][SHAPE]==T_DOUBLE){</span>
<span class="nc" id="L1375">        x1=x[var-4]; // height (y axis)</span>
<span class="nc" id="L1376">        x2=x[var-3]; // width (Z axis)</span>
<span class="nc" id="L1377">        x3=x[var-2]; // tickness heigth plate</span>
<span class="nc" id="L1378">        x4=x[var-1]; // tickness width plate</span>
<span class="nc" id="L1379">        EBEsTransversalSection_T_Double(gr, x1, x2, x3, x4);</span>
      }
      else{
<span class="nc" id="L1382">        System.out.println(&quot;Error in VARIABLES: transversal section not considerated for: &quot; + gr + &quot; group&quot;) ;</span>
      }
    }// next gr

<span class="nc" id="L1386">  }</span>

  public void EBEsWeigthElement() throws JMetalException{

    // load by weight of the element
<span class="nc bnc" id="L1391" title="All 2 branches missed.">    for (int el=0; el&lt;numberOfElements_;el++){</span>
<span class="nc" id="L1392">      int idx =(int)Element_[el][INDEX_];</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">      if(GravitationalAxis_==&quot;Z&quot;)</span>
      {
        // gravitational in Z-AXIS
<span class="nc" id="L1396">        WeightElement_[el][QH_] = 0;</span>
<span class="nc" id="L1397">        WeightElement_[el][QE_] = el;</span>
<span class="nc" id="L1398">        WeightElement_[el][QT_] = CARGA_UNIFORME_TOTAL;</span>
<span class="nc" id="L1399">        WeightElement_[el][QAx_] = 0.0;</span>
<span class="nc" id="L1400">        WeightElement_[el][QAy_] = 0.0;</span>
<span class="nc" id="L1401">        WeightElement_[el][QAz_] = -Groups_[idx][AREA] * Groups_[idx][SPECIFIC_WEIGHT];</span>
<span class="nc" id="L1402">        WeightElement_[el][Qa_] = 0.0;</span>
<span class="nc" id="L1403">        WeightElement_[el][Qb_] = 0.0;</span>
      }
      else {
        // gravitational in Y-AXIS
<span class="nc" id="L1407">        WeightElement_[el][QH_] = 0;</span>
<span class="nc" id="L1408">        WeightElement_[el][QE_] = el;</span>
<span class="nc" id="L1409">        WeightElement_[el][QT_] = CARGA_UNIFORME_TOTAL;</span>
<span class="nc" id="L1410">        WeightElement_[el][QAx_] = 0.0;</span>
<span class="nc" id="L1411">        WeightElement_[el][QAy_] = -Groups_[idx][AREA] * Groups_[idx][SPECIFIC_WEIGHT];</span>
<span class="nc" id="L1412">        WeightElement_[el][QAz_] = 0.0;</span>
<span class="nc" id="L1413">        WeightElement_[el][Qa_] = 0.0;</span>
<span class="nc" id="L1414">        WeightElement_[el][Qb_] = 0.0;</span>
      }

<span class="nc" id="L1417">      Qi = new double[numberOfLibertyDegree_];</span>
<span class="nc" id="L1418">      Qj = new double[numberOfLibertyDegree_];</span>
<span class="nc" id="L1419">      pi = new double[numberOfLibertyDegree_];</span>
<span class="nc" id="L1420">      pj = new double[numberOfLibertyDegree_];</span>

<span class="nc" id="L1422">      EBEsWeightDistributedUniformly(el, WeightElement_[el]);</span>

<span class="nc" id="L1424">      int hi = 0;</span>
<span class="nc" id="L1425">      int ni = (int)Element_[el][i_];</span>
<span class="nc" id="L1426">      int nj = (int)Element_[el][j_];</span>

      // nudi i
<span class="nc" id="L1429">      PQ[numberOfLibertyDegree_ * ni + aX_][hi] += Qi[aX_];</span>
<span class="nc" id="L1430">      PQ[numberOfLibertyDegree_ * ni + aY_][hi] += Qi[aY_];</span>
<span class="nc" id="L1431">      PQ[numberOfLibertyDegree_ * ni + aZ_][hi] += Qi[aZ_];</span>
<span class="nc" id="L1432">      PQ[numberOfLibertyDegree_ * ni + gX_][hi] += Qi[gX_];</span>
<span class="nc" id="L1433">      PQ[numberOfLibertyDegree_ * ni + gY_][hi] += Qi[gY_];</span>
<span class="nc" id="L1434">      PQ[numberOfLibertyDegree_ * ni + gZ_][hi] += Qi[gZ_];</span>
      //nudo j
<span class="nc" id="L1436">      PQ[numberOfLibertyDegree_ * nj + aX_][hi] += Qj[aX_];</span>
<span class="nc" id="L1437">      PQ[numberOfLibertyDegree_ * nj + aY_][hi] += Qj[aY_];</span>
<span class="nc" id="L1438">      PQ[numberOfLibertyDegree_ * nj + aZ_][hi] += Qj[aZ_];</span>
<span class="nc" id="L1439">      PQ[numberOfLibertyDegree_ * nj + gX_][hi] += Qj[gX_];</span>
<span class="nc" id="L1440">      PQ[numberOfLibertyDegree_ * nj + gY_][hi] += Qj[gY_];</span>
<span class="nc" id="L1441">      PQ[numberOfLibertyDegree_ * nj + gZ_][hi] += Qj[gZ_];</span>

      //acumula cargas equivalentes en nudos en coordenadas LOCALES para la MISMA BARRA E HIPÃƒÂ³TESIS
<span class="nc" id="L1444">      cbi[aX_][el][hi] += pi[aX_];</span>
<span class="nc" id="L1445">      cbi[aY_][el][hi] += pi[aY_];</span>
<span class="nc" id="L1446">      cbi[aZ_][el][hi] += pi[aZ_];</span>
<span class="nc" id="L1447">      cbi[gX_][el][hi] += pi[gX_];</span>
<span class="nc" id="L1448">      cbi[gY_][el][hi] += pi[gY_];</span>
<span class="nc" id="L1449">      cbi[gZ_][el][hi] += pi[gZ_];</span>
<span class="nc" id="L1450">      cbj[aX_][el][hi] += pj[aX_];</span>
<span class="nc" id="L1451">      cbj[aY_][el][hi] += pj[aY_];</span>
<span class="nc" id="L1452">      cbj[aZ_][el][hi] += pj[aZ_];</span>
<span class="nc" id="L1453">      cbj[gX_][el][hi] += pj[gX_];</span>
<span class="nc" id="L1454">      cbj[gY_][el][hi] += pj[gY_];</span>
<span class="nc" id="L1455">      cbj[gZ_][el][hi] += pj[gZ_];</span>
    }

<span class="nc" id="L1458">  }</span>

  public void EBEsCalculus() throws JMetalException{
    //  Module de calc

    // Effort in boundary element
<span class="nc" id="L1464">    Efforti_ = new double[numberOfLibertyDegree_][numberOfElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L1465">    Effortj_ = new double[numberOfLibertyDegree_][numberOfElements_][numberOfWeigthHypothesis_];</span>

    // corrimientos y rotaciones de los nudos por hipÃƒÂ³tesis de cargas
<span class="nc" id="L1468">    DisplacementNodes_= new double[numberOfLibertyDegree_* numberOfNodes][numberOfWeigthHypothesis_];</span>

    // Strain in extrem i por hipÃƒÂ³tesis de cargas
<span class="nc" id="L1471">    Straini_ = new double[3][numberOfElements_][numberOfWeigthHypothesis_];</span>
    // Strain in extrem j  por hipÃƒÂ³tesis de cargas
<span class="nc" id="L1473">    Strainj_ = new double[3][numberOfElements_][numberOfWeigthHypothesis_];</span>
    // Strain minimun por hipÃƒÂ³tesis de cargas
    // StrainMin_ = new double[2][numberOfElements_][numberOfWeigthHypothesis_];
<span class="nc" id="L1476">    OldStrainMin_ = StrainMin_;</span>
<span class="nc" id="L1477">    StrainMin_ = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
    // Strain maximus  por hipÃƒÂ³tesis de cargas
    // StrainMax_ = new double[2][numberOfElements_][numberOfWeigthHypothesis_];
<span class="nc" id="L1480">    OldStrainMax_ = StrainMax_;</span>
<span class="nc" id="L1481">    StrainMax_ = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
    // stress tangencial mamimun
<span class="nc" id="L1483">    StrainCutMax_ = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
    // Negative Strain residual  por hipÃƒÂ³tesis de cargas
<span class="nc" id="L1485">    StrainResidualMin_ = new double[numberOfWeigthHypothesis_];</span>
    // Positive Strain residual  por hipÃƒÂ³tesis de cargas
<span class="nc" id="L1487">    StrainResidualMax_ = new double[numberOfWeigthHypothesis_];</span>
    // Cut Strain residual  por hipÃƒÂ³tesis de cargas
<span class="nc" id="L1489">    StrainResidualCut_ = new double[numberOfWeigthHypothesis_];</span>

<span class="nc" id="L1491">    MatrixStiffness_ = new double [numberOfLibertyDegree_* numberOfLibertyDegree_* numberOfNodes *(elementsBetweenDiffGreat_+1)];</span>

    // load inself witch element
<span class="nc" id="L1494">    WeightElement_ = new double[numberOfElements_][8];</span>

    //variables load in extrem of beams
<span class="nc" id="L1497">    cbi= new double [numberOfLibertyDegree_][numberOfElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L1498">    cbj= new double [numberOfLibertyDegree_][numberOfElements_][numberOfWeigthHypothesis_];</span>

    // total equivalent load nodes in all structure witch load on elements and load nodes
<span class="nc" id="L1501">    PQ= new double [numberOfLibertyDegree_* numberOfNodes][numberOfWeigthHypothesis_];</span>

<span class="nc" id="L1503">    Reaction_= new double [numberOfLibertyDegree_* numberOfNodes][numberOfWeigthHypothesis_];</span>

<span class="nc" id="L1505">    EBEsWeightNodes();</span>

<span class="nc bnc" id="L1507" title="All 2 branches missed.">    if(lLoadsOwnWeight)</span>
<span class="nc" id="L1508">      EBEsWeigthElement();</span>

<span class="nc" id="L1510">    EBEsOverloadWeightElement();</span>

    // checked if geometric second orden calculus
<span class="nc" id="L1513">    int NumIter=0;</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">    if(lSecondOrderGeometric)</span>
<span class="nc" id="L1515">      NumIter=1;</span>

    // load hypotesis
<span class="nc bnc" id="L1518" title="All 2 branches missed.">    for(int hi=0; hi&lt;numberOfWeigthHypothesis_;hi++){</span>

<span class="nc bnc" id="L1520" title="All 2 branches missed.">      for(int countIter=0;countIter&lt;=NumIter;countIter++){</span>

<span class="nc" id="L1522">        EBEsMatrixWeight(hi);</span>

<span class="nc" id="L1524">        EBEsMatrixGlobalFactory(countIter);</span>
        //imprime la matriz de rigidez
        //EBEsPrintArchTxtMKG(&quot;1&quot;, hi);

<span class="nc" id="L1528">        EBEsMatrixGlobalPenalization();</span>
        // matriz penalizada
        //EBEsPrintArchTxtMKG(&quot;2&quot;, hi);

<span class="nc" id="L1532">        EBEsEcuationSolution(hi);</span>

<span class="nc" id="L1534">        EBEsEffortsElements3D(hi, countIter, DisplacementNodes_);</span>

<span class="nc" id="L1536">        EBEsEffortsTotal3D(hi);</span>

        //ARCHIVADO DE LA SOLUCIÃƒâ€œN DE ESTABILIDAD Y MECÃƒï¿½NICA
        //EBEsPrintArchTxtElements();
        //EBEsPrintArchTxtDesp(hi);
        //EBEsPrintArchTxtEfforts(hi);
        //EBEsPrintArchTxtReaction(hi);

<span class="nc bnc" id="L1544" title="All 4 branches missed.">        if(lSecondOrderGeometric &amp;&amp; countIter==0){</span>
<span class="nc" id="L1545">          EBEsAssignAxialForces(hi);</span>
<span class="nc" id="L1546">          EBEsSteelingResults(hi);</span>
        }
      } // next numIter

      // para el proceso de optimizaciÃƒÂ³n podemos prescindir
      // EBEsNodesEquilibrium3D(hi);

      // para el proceso de optimizaciÃƒÂ³n podemos prescindir
      // EBEsReactions3D(hi);

    } //next hi

    // cÃƒÂ¡lculo de las tensiones, por barra calculo en los extremos
    // faltarÃƒÂ­a calcular en los tramos y quedarme con el mÃƒÂ¡ximo
    // tensiones en i
<span class="nc" id="L1561">    Straini_=EBEsStrainNode(Efforti_);</span>

    // tensiones en extriemo j
<span class="nc" id="L1564">    Strainj_=EBEsStrainNode(Effortj_);</span>

    // tensiones mÃƒÂ¡ximas en cada barra
    // EBEsStrainMaxWhitElement();
<span class="nc" id="L1568">    EBEsStrainMaxWhitGroup();</span>

    // tensiones mÃƒÂ­nimaa en cada barra
    // EBEsStrainMinWhitElement();
<span class="nc" id="L1572">    EBEsStrainMinWhitGroup();</span>

    // verificaciÃƒÂ³n de las tensiones mÃƒÂ¡ximas respecto a las
    // tensiones admisibles
<span class="nc" id="L1576">    EBEsStrainResidualVerication();</span>

    // ARCHIVADO DE LAS TENSIONES
    //EBEsPrintArchTxtStrain();

<span class="nc" id="L1581">  } // end EBEsCalculus</span>

  public void EBEsAssignAxialForces(int hi){

<span class="nc" id="L1585">    AxialForcei_ = new double[numberOfElements_];</span>
<span class="nc" id="L1586">    AxialForcej_ = new double[numberOfElements_];</span>

<span class="nc bnc" id="L1588" title="All 2 branches missed.">    for(int el=0;el&lt;numberOfElements_;el++){</span>
<span class="nc" id="L1589">      AxialForcei_[el] = Efforti_[aX_][el][hi];</span>
<span class="nc" id="L1590">      AxialForcej_[el] = Effortj_[aX_][el][hi];</span>
    }
<span class="nc" id="L1592">  }</span>

  public void EBEsSteelingResults(int hi){

    // stiffness matrix steeling
<span class="nc bnc" id="L1597" title="All 2 branches missed.">    for(int m = 0; m&lt;numberOfLibertyDegree_* numberOfLibertyDegree_* numberOfNodes *(elementsBetweenDiffGreat_+1); m++){</span>
<span class="nc" id="L1598">      MatrixStiffness_[m] = 0.0;</span>
    }

    // corrimientos y rotaciones de los nudos por hipÃƒÂ³tesis de cargas
<span class="nc bnc" id="L1602" title="All 2 branches missed.">    for(int no = 0; no&lt;numberOfLibertyDegree_* numberOfNodes; no++){</span>
<span class="nc" id="L1603">      DisplacementNodes_[no][hi]= 0.0;</span>
    }

<span class="nc bnc" id="L1606" title="All 2 branches missed.">    for(int el = 0; el&lt;Element_.length; el++){</span>
      //esfuerzos en extremo i de la barra para el sistema principal de la secciÃƒÂ³n
<span class="nc" id="L1608">      Efforti_[aX_][el][hi] = 0.0;</span>
<span class="nc" id="L1609">      Efforti_[aY_][el][hi] = 0.0;</span>
<span class="nc" id="L1610">      Efforti_[aZ_][el][hi] = 0.0;</span>
<span class="nc" id="L1611">      Efforti_[gX_][el][hi] = 0.0;</span>
<span class="nc" id="L1612">      Efforti_[gY_][el][hi] = 0.0;</span>
<span class="nc" id="L1613">      Efforti_[gZ_][el][hi] = 0.0;</span>

      //esfuerzos en extremo j de la elrra para el sistema principal de la secciÃƒÂ³n
<span class="nc" id="L1616">      Effortj_[aX_][el][hi] = 0.0;</span>
<span class="nc" id="L1617">      Effortj_[aY_][el][hi] = 0.0;</span>
<span class="nc" id="L1618">      Effortj_[aZ_][el][hi] = 0.0;</span>
<span class="nc" id="L1619">      Effortj_[gX_][el][hi] = 0.0;</span>
<span class="nc" id="L1620">      Effortj_[gY_][el][hi] = 0.0;</span>
<span class="nc" id="L1621">      Effortj_[gZ_][el][hi] = 0.0;</span>
    }
<span class="nc" id="L1623">  }</span>

  public void EBEsMatrixWeight(int hi){

    // formaciÃƒÂ³n del vector de fuerzas
<span class="nc bnc" id="L1628" title="All 2 branches missed.">    for(int j = 0; j&lt;Node_.length ;j++){</span>
<span class="nc" id="L1629">      DisplacementNodes_[numberOfLibertyDegree_ * j + aX_][hi] = PQ[numberOfLibertyDegree_ * j + aX_][hi];</span>
<span class="nc" id="L1630">      DisplacementNodes_[numberOfLibertyDegree_ * j + aY_][hi] = PQ[numberOfLibertyDegree_ * j + aY_][hi];</span>
<span class="nc" id="L1631">      DisplacementNodes_[numberOfLibertyDegree_ * j + aZ_][hi] = PQ[numberOfLibertyDegree_ * j + aZ_][hi];</span>
<span class="nc" id="L1632">      DisplacementNodes_[numberOfLibertyDegree_ * j + gX_][hi] = PQ[numberOfLibertyDegree_ * j + gX_][hi];</span>
<span class="nc" id="L1633">      DisplacementNodes_[numberOfLibertyDegree_ * j + gY_][hi] = PQ[numberOfLibertyDegree_ * j + gY_][hi];</span>
<span class="nc" id="L1634">      DisplacementNodes_[numberOfLibertyDegree_ * j + gZ_][hi] = PQ[numberOfLibertyDegree_ * j + gZ_][hi];</span>
    }

<span class="nc" id="L1637">  }</span>

  public void EBEsMatrixGlobalFactory(int countIter) throws JMetalException{

    // select link between elements
<span class="nc bnc" id="L1642" title="All 2 branches missed.">    for(int el=0; el&lt;numberOfElements_; el++){</span>
      // int ni=(int)Element_[el][i_];
      // int nj=(int)Element_[el][j_];
      // the global coordinates
      // double xi=Node_[ni][aX_]; double yi=Node_[ni][aY_]; double zi=Node_[ni][aZ_];
      // double xj=Node_[nj][aX_]; double yj=Node_[nj][aY_]; double zj=Node_[nj][aZ_];
      // long element
      // Element_[el][L_]=Math.sqrt(Math.pow((xi-xj),2)+Math.pow((yi-yj),2)+Math.pow((zi-zj),2));

<span class="nc bnc" id="L1651" title="All 5 branches missed.">      switch ((int)Element_[el][Vij_]){</span>
<span class="nc" id="L1652">        case 00: EBEsMat3DL_iRig_jRig(el); break;</span>
<span class="nc" id="L1653">        case 01: EBEsMat3DL_iRig_jArt(el); break;</span>
<span class="nc" id="L1654">        case 10: EBEsMat3DL_iArt_jRig(el); break;</span>
<span class="nc" id="L1655">        case 11: EBEsMat3DL_iArt_jArt(el); break;</span>
<span class="nc" id="L1656">        default: System.out.println(&quot;invalid link&quot;);return;</span>
      } // end switch

<span class="nc bnc" id="L1659" title="All 4 branches missed.">      if(lSecondOrderGeometric &amp;&amp; countIter==1){</span>
<span class="nc" id="L1660">        EBEsMat3DL_SOG(el);</span>
<span class="nc" id="L1661">        Kii=EBEsMatrixAdd(Kii, KiiSOG);</span>
<span class="nc" id="L1662">        Kij=EBEsMatrixAdd(Kij, KijSOG);</span>
<span class="nc" id="L1663">        Kji=EBEsMatrixAdd(Kji, KjiSOG);</span>
<span class="nc" id="L1664">        Kjj=EBEsMatrixAdd(Kjj, KjjSOG);</span>
      }

      // matriz de rotaciÃƒÂ³n de ejes principales de secciÃƒÂ³n a ejes locales (xp,yp)
<span class="nc" id="L1668">      EBEsMatRot3DLpSaL(el);</span>
      // matriz de rotaciÃƒÂ³n de ejes locales a globales (x,y)
<span class="nc" id="L1670">      EBEsMatRot3DLaG(el);</span>
      //formaciÃƒÂ³n y cÃƒÂ¡lculo de la matriz de rigidez de cada barra 3D en coordenadas globales
<span class="nc" id="L1672">      EBEsMat3DGij();</span>
      // FORMACION DE LA MATRIZ DE RIGIDEZ de la estructura en coordenada globales
<span class="nc" id="L1674">      EBEsMat3DG(el);</span>
    } // next el

<span class="nc" id="L1677">  }</span>
  public void EBEsMatrixGlobalPenalization(){

    // penalizaciÃƒÂ³n de la matriz asignando coacciones de nudos (apoyos)
<span class="nc bnc" id="L1681" title="All 2 branches missed.">    for(int i = 0; i&lt;numberOfNodesRestricts_; i++){</span>
<span class="nc" id="L1682">      int no=(int)NodeRestrict_[i][0];</span>
      //trasforma el nÃƒÆ’Ã‚Âºmero en cÃƒÂ³digo texto caracterizando las coacciones;
<span class="nc" id="L1684">      String strCxyz=String.valueOf((int)NodeRestrict_[i][1]);</span>
<span class="nc" id="L1685">      String str=&quot;&quot;;</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">      for(int j=numberOfLibertyDegree_;j&gt;strCxyz.length();j--){str+=&quot;0&quot;;}</span>
<span class="nc" id="L1687">      strCxyz=str+strCxyz;</span>
      // penalizaciÃƒÂ³n de la matriz de rigidez

<span class="nc" id="L1690">      char w0 = strCxyz.charAt(aX_); //sentido en X</span>
<span class="nc bnc" id="L1691" title="All 2 branches missed.">      if(w0 == '1'){</span>
<span class="nc" id="L1692">        MatrixStiffness_[matrixWidthBand_ * (numberOfLibertyDegree_ * no + aX_)] = 1.0E+35; // coacciÃƒÂ³n rÃƒÂ­gida en X</span>
      } //coacciÃƒÂ³n rÃƒÂ­gida en X

<span class="nc" id="L1695">      w0 = strCxyz.charAt(aY_); //sentido en Y</span>
<span class="nc bnc" id="L1696" title="All 2 branches missed.">      if(w0 == '1'){</span>
<span class="nc" id="L1697">        MatrixStiffness_[matrixWidthBand_ * (numberOfLibertyDegree_ * no + aY_)] = 1.0E+35; // coacciÃƒÂ³n rÃƒÂ­gida en Y</span>
      } //coacciÃƒÂ³n rÃƒÂ­gida en Y

<span class="nc" id="L1700">      w0 = strCxyz.charAt(aZ_); //sentido en Z</span>
<span class="nc bnc" id="L1701" title="All 2 branches missed.">      if(w0 == '1'){</span>
<span class="nc" id="L1702">        MatrixStiffness_[matrixWidthBand_ * (numberOfLibertyDegree_ * no + aZ_)] = 1.0E+35; // coacciÃƒÂ³n rÃƒÂ­gida en Z</span>
      } //coacciÃƒÂ³n rÃƒÂ­gida en Z

<span class="nc" id="L1705">      w0 = strCxyz.charAt(gX_); //rotaciÃƒÂ³n alrededor del eje X</span>
<span class="nc bnc" id="L1706" title="All 2 branches missed.">      if(w0 == '1'){</span>
<span class="nc" id="L1707">        MatrixStiffness_[matrixWidthBand_ * (numberOfLibertyDegree_ * no + gX_)] = 1.0E+35; // coacciÃƒÂ³n rÃƒÂ­gida alrededor de X</span>
      } //coacciÃƒÂ³n rÃƒÂ­gida de rotaciÃƒÂ³n en X

<span class="nc" id="L1710">      w0 = strCxyz.charAt(gY_); //rotaciÃƒÂ³n alrededor del eje Y</span>
<span class="nc bnc" id="L1711" title="All 2 branches missed.">      if(w0 == '1'){</span>
<span class="nc" id="L1712">        MatrixStiffness_[matrixWidthBand_ * (numberOfLibertyDegree_ * no + gY_)] = 1.0E+35; // coacciÃƒÂ³n rÃƒÂ­gida alrededor de Y</span>
      } //coacciÃƒÂ³n rÃƒÂ­gida en Y

<span class="nc" id="L1715">      w0 = strCxyz.charAt(gZ_); //rotaciÃƒÂ³n alrededor del eje Z</span>
<span class="nc bnc" id="L1716" title="All 2 branches missed.">      if(w0 == '1'){</span>
<span class="nc" id="L1717">        MatrixStiffness_[matrixWidthBand_ * (numberOfLibertyDegree_ * no + gZ_)] = 1.0E+35; // coacciÃƒÂ³n rÃƒÂ­gida alrededor de Z</span>
      } //coacciÃƒÂ³n rÃƒÂ­gida de rotaciÃƒÂ³n en Z

    } //nex i

<span class="nc" id="L1722">  }</span>
  public void EBEsEffortsTotal3D(int hi){

    //ESFUERZOS EN EXTREMOS DE BARRA 3D EN COORDENADAS LOCALES
    //i: rigido
    //j: rigido
<span class="nc bnc" id="L1728" title="All 2 branches missed.">    for(int el = 0; el&lt;Element_.length; el++){</span>
      //esfuerzos en extremo i de la barra para el sistema principal de la secciÃƒÂ³n
<span class="nc" id="L1730">      Efforti_[aX_][el][hi] += -cbi[aX_][el][hi];</span>
<span class="nc" id="L1731">      Efforti_[aY_][el][hi] += -cbi[aY_][el][hi];</span>
<span class="nc" id="L1732">      Efforti_[aZ_][el][hi] += -cbi[aZ_][el][hi];</span>
<span class="nc" id="L1733">      Efforti_[gX_][el][hi] += -cbi[gX_][el][hi];</span>
<span class="nc" id="L1734">      Efforti_[gY_][el][hi] += -cbi[gY_][el][hi];</span>
<span class="nc" id="L1735">      Efforti_[gZ_][el][hi] += -cbi[gZ_][el][hi];</span>

      //esfuerzos en extremo j de la elrra para el sistema principal de la secciÃƒÂ³n
<span class="nc" id="L1738">      Effortj_[aX_][el][hi] += -cbj[aX_][el][hi];</span>
<span class="nc" id="L1739">      Effortj_[aY_][el][hi] += -cbj[aY_][el][hi];</span>
<span class="nc" id="L1740">      Effortj_[aZ_][el][hi] += -cbj[aZ_][el][hi];</span>
<span class="nc" id="L1741">      Effortj_[gX_][el][hi] += -cbj[gX_][el][hi];</span>
<span class="nc" id="L1742">      Effortj_[gY_][el][hi] += -cbj[gY_][el][hi];</span>
<span class="nc" id="L1743">      Effortj_[gZ_][el][hi] += -cbj[gZ_][el][hi];</span>
    }
<span class="nc" id="L1745">  }</span>


  public void EBEsWeightNodes(){

<span class="nc bnc" id="L1750" title="All 2 branches missed.">    for(int j=0; j &lt;numberOfWeigthsNodes_ ; j++){</span>
<span class="nc" id="L1751">      int hi = (int)WeightNode_[j][0];</span>
<span class="nc" id="L1752">      int no = (int)WeightNode_[j][1];</span>
      // variables displacement
<span class="nc" id="L1754">      DisplacementNodes_[numberOfLibertyDegree_ * no + aX_][hi] =  WeightNode_[j][2];</span>
<span class="nc" id="L1755">      DisplacementNodes_[numberOfLibertyDegree_ * no + aY_][hi] =  WeightNode_[j][3];</span>
<span class="nc" id="L1756">      DisplacementNodes_[numberOfLibertyDegree_ * no + aZ_][hi] =  WeightNode_[j][4];</span>
<span class="nc" id="L1757">      DisplacementNodes_[numberOfLibertyDegree_ * no + gX_][hi] =  WeightNode_[j][5];</span>
<span class="nc" id="L1758">      DisplacementNodes_[numberOfLibertyDegree_ * no + gY_][hi] =  WeightNode_[j][6];</span>
<span class="nc" id="L1759">      DisplacementNodes_[numberOfLibertyDegree_ * no + gZ_][hi] =  WeightNode_[j][7];</span>
      // variables total load = loads node
<span class="nc" id="L1761">      PQ[numberOfLibertyDegree_ * no + aX_][hi] =  WeightNode_[j][2];</span>
<span class="nc" id="L1762">      PQ[numberOfLibertyDegree_ * no + aY_][hi] =  WeightNode_[j][3];</span>
<span class="nc" id="L1763">      PQ[numberOfLibertyDegree_ * no + aZ_][hi] =  WeightNode_[j][4];</span>
<span class="nc" id="L1764">      PQ[numberOfLibertyDegree_ * no + gX_][hi] =  WeightNode_[j][5];</span>
<span class="nc" id="L1765">      PQ[numberOfLibertyDegree_ * no + gY_][hi] =  WeightNode_[j][6];</span>
<span class="nc" id="L1766">      PQ[numberOfLibertyDegree_ * no + gZ_][hi] =  WeightNode_[j][7];</span>
    }
<span class="nc" id="L1768">  }</span>

  public void EBEsOverloadWeightElement() throws JMetalException{
    //transfiere las cargas de las barras hacia los nudos

    //bucle para todas las barras cargadas
<span class="nc bnc" id="L1774" title="All 2 branches missed.">    for(int i = 0; i&lt; numberOfWeigthsElements_;i++){</span>

<span class="nc" id="L1776">      Qi = new double[numberOfLibertyDegree_];</span>
<span class="nc" id="L1777">      Qj = new double[numberOfLibertyDegree_];</span>
<span class="nc" id="L1778">      pi = new double[numberOfLibertyDegree_];</span>
<span class="nc" id="L1779">      pj = new double[numberOfLibertyDegree_];</span>
      //int hi = (int)OverloadInElement_[nQ][QH_];
      // load element
<span class="nc" id="L1782">      int el = (int)OverloadInElement_[i][QE_];</span>
      // nodes element

      //determinacion del tipo de cargas
<span class="nc bnc" id="L1786" title="All 2 branches missed.">      switch ((int)OverloadInElement_[i][QT_]){</span>
<span class="nc" id="L1787">        case 0: EBEsWeightDistributedUniformly(el, OverloadInElement_[i]); break;</span>

<span class="nc" id="L1789">        default: System.out.println(&quot;invalid link&quot;);return;</span>
      }

      //acumula cargas equivalentes en nudos en coordenadas GLOBALES la MISMA BARRA E HIPÃƒÂ³TESIS
      //hipotesis asignada
<span class="nc" id="L1794">      int hi = (int)OverloadInElement_[i][QH_];</span>
      //identificaciÃƒÂ³n de las barras cargadas
<span class="nc" id="L1796">      int ni = (int)Element_[el][i_];</span>
<span class="nc" id="L1797">      int nj = (int)Element_[el][j_];</span>

      // nudi i
<span class="nc" id="L1800">      PQ[numberOfLibertyDegree_ * ni + aX_][hi] += Qi[aX_];</span>
<span class="nc" id="L1801">      PQ[numberOfLibertyDegree_ * ni + aY_][hi] += Qi[aY_];</span>
<span class="nc" id="L1802">      PQ[numberOfLibertyDegree_ * ni + aZ_][hi] += Qi[aZ_];</span>
<span class="nc" id="L1803">      PQ[numberOfLibertyDegree_ * ni + gX_][hi] += Qi[gX_];</span>
<span class="nc" id="L1804">      PQ[numberOfLibertyDegree_ * ni + gY_][hi] += Qi[gY_];</span>
<span class="nc" id="L1805">      PQ[numberOfLibertyDegree_ * ni + gZ_][hi] += Qi[gZ_];</span>
      //nudo j
<span class="nc" id="L1807">      PQ[numberOfLibertyDegree_ * nj + aX_][hi] += Qj[aX_];</span>
<span class="nc" id="L1808">      PQ[numberOfLibertyDegree_ * nj + aY_][hi] += Qj[aY_];</span>
<span class="nc" id="L1809">      PQ[numberOfLibertyDegree_ * nj + aZ_][hi] += Qj[aZ_];</span>
<span class="nc" id="L1810">      PQ[numberOfLibertyDegree_ * nj + gX_][hi] += Qj[gX_];</span>
<span class="nc" id="L1811">      PQ[numberOfLibertyDegree_ * nj + gY_][hi] += Qj[gY_];</span>
<span class="nc" id="L1812">      PQ[numberOfLibertyDegree_ * nj + gZ_][hi] += Qj[gZ_];</span>

      //acumula cargas equivalentes en nudos en coordenadas LOCALES para la MISMA BARRA E HIPÃƒÂ³TESIS
<span class="nc" id="L1815">      cbi[aX_][el][hi] += pi[aX_];</span>
<span class="nc" id="L1816">      cbi[aY_][el][hi] += pi[aY_];</span>
<span class="nc" id="L1817">      cbi[aZ_][el][hi] += pi[aZ_];</span>
<span class="nc" id="L1818">      cbi[gX_][el][hi] += pi[gX_];</span>
<span class="nc" id="L1819">      cbi[gY_][el][hi] += pi[gY_];</span>
<span class="nc" id="L1820">      cbi[gZ_][el][hi] += pi[gZ_];</span>
<span class="nc" id="L1821">      cbj[aX_][el][hi] += pj[aX_];</span>
<span class="nc" id="L1822">      cbj[aY_][el][hi] += pj[aY_];</span>
<span class="nc" id="L1823">      cbj[aZ_][el][hi] += pj[aZ_];</span>
<span class="nc" id="L1824">      cbj[gX_][el][hi] += pj[gX_];</span>
<span class="nc" id="L1825">      cbj[gY_][el][hi] += pj[gY_];</span>
<span class="nc" id="L1826">      cbj[gZ_][el][hi] += pj[gZ_];</span>

    }

<span class="nc" id="L1830">  }</span>

  public void EBEsWeightDistributedUniformly(int el, double[] LoadInElement_) throws JMetalException{

    //nQ: numero de carga
    //referida al sistema de ejes globales
    //con sentidos y direcciones acordes a los tres ejes X Y Z
    //Qi() cargas equivalentes aplicadas en el extremo i de la barra con sentido y direcciÃƒÂ³n del sistema GLOBAL
    //Qj() cargas equivalentes aplicadas en el extremo j de la barra con sentido y direcciÃƒÂ³n del sistema GLOBAL
    //pi() cargas equivalentes aplicadas en el extremo i con sentido y direcciÃƒÂ³n del sistema LOCAL de cada barra
    //pj() cargas equivalentes aplicadas en el extremo j con sentido y direcciÃƒÂ³n del sistema LOCAL de cada barra

    int vi, vj;
    double xi, xj, yi, yj, zi, zj;
<span class="nc" id="L1844">    double [][]R = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>

    //longitud de la barra en coordenadas locales
    // double lij = Math.sqrt(Math.pow((xj - xi), 2.0) + Math.pow((yj - yi), 2.0) + Math.pow((zj - zi), 2.0));
    //longitudes de la barra en coordenadas locales
    //vinculaciÃƒÂ³n de los extremos
<span class="nc bnc" id="L1850" title="All 5 branches missed.">    switch ((int)Element_[el][Vij_]){</span>
<span class="nc" id="L1851">      case 00: {vi=0; vj=0; break;}</span>
<span class="nc" id="L1852">      case 01: {vi=0; vj=1; break;}</span>
<span class="nc" id="L1853">      case 10: {vi=1; vj=0; break;}</span>
<span class="nc" id="L1854">      case 11: {vi=1; vj=1; break;}</span>
<span class="nc" id="L1855">      default: System.out.println(&quot;invalid link&quot;);return;</span>
    } // end switch

<span class="nc" id="L1858">    int ni = (int)Element_[el][i_];</span>
<span class="nc" id="L1859">    int nj = (int)Element_[el][j_];</span>
    //coordenadas de los extremso de la barra
<span class="nc" id="L1861">    xi=Node_[ni][aX_];</span>
<span class="nc" id="L1862">    yi=Node_[ni][aY_];</span>
<span class="nc" id="L1863">    zi=Node_[ni][aZ_];</span>
<span class="nc" id="L1864">    xj=Node_[nj][aX_];</span>
<span class="nc" id="L1865">    yj=Node_[nj][aY_];</span>
<span class="nc" id="L1866">    zj=Node_[nj][aZ_];</span>

<span class="nc" id="L1868">    double A1 = Math.asin((xi - xj) / Element_[el][L_]);</span>
<span class="nc" id="L1869">    double lx = Element_[el][L_] * Math.cos(A1);</span>
<span class="nc" id="L1870">    double B1 = Math.asin((yi - yj) / Element_[el][L_]);</span>
<span class="nc" id="L1871">    double ly = Element_[el][L_] * Math.cos(B1);</span>
<span class="nc" id="L1872">    double G1 = Math.asin((zi - zj) / Element_[el][L_]);</span>
<span class="nc" id="L1873">    double lz = Element_[el][L_] * Math.cos(G1);</span>

<span class="nc bnc" id="L1875" title="All 4 branches missed.">    if (vi == 0 &amp;&amp; vj == 0) {</span>
      //EMP-EMP, debe multiplicarse por la matriz de rotaciÃƒÂ³n para

      //fuerza en sentido Global X
<span class="nc bnc" id="L1879" title="All 6 branches missed.">      if (Math.abs(lx) &lt; 0.0000001 &amp;&amp; ly != 0 &amp;&amp; lz != 0.0){</span>
<span class="nc" id="L1880">        Qi[aX_] = LoadInElement_[QAx_] * Math.abs((xi - xj)) / 2.0;</span>
<span class="nc" id="L1881">        Qj[aX_] = Qi[aX_];</span>
      }
      else{
<span class="nc" id="L1884">        Qi[aX_] = LoadInElement_[QAx_] * lx / 2.0;</span>
<span class="nc" id="L1885">        Qj[aX_] = Qi[aX_];</span>
      }
      //fuerza sentido Global Y
<span class="nc bnc" id="L1888" title="All 4 branches missed.">      if((xi - xj) == 0 &amp;&amp; (zi - zj) == 0.0 ){</span>
<span class="nc" id="L1889">        Qi[aY_] = LoadInElement_[QAy_] * Math.abs((yi - yj)) / 2.0;</span>
<span class="nc" id="L1890">        Qj[aY_] = Qi[aY_];</span>
      }
      else{
<span class="nc" id="L1893">        Qi[aY_] = LoadInElement_[QAy_] * ly / 2.0;</span>
<span class="nc" id="L1894">        Qj[aY_] = Qi[aY_];</span>
      }
      //fuerza sentido Global Z
<span class="nc bnc" id="L1897" title="All 6 branches missed.">      if(Math.abs(lz) &lt; 0.0000001 &amp;&amp; lx != 0 &amp;&amp; ly != 0.0){</span>
<span class="nc" id="L1898">        Qi[aZ_] = LoadInElement_[QAz_] * Math.abs((zi - zj)) / 2.0;</span>
<span class="nc" id="L1899">        Qj[aZ_] = Qi[aZ_];</span>
      }
      else{
<span class="nc" id="L1902">        Qi[aZ_] = LoadInElement_[QAz_] * lz / 2.0;</span>
<span class="nc" id="L1903">        Qj[aZ_] = Qi[aZ_];</span>
      }
      //momento rotaciÃƒÂ³n en Global X
<span class="nc" id="L1906">      Qi[gX_] = (LoadInElement_[QAy_] * ly * (zi - zj) - LoadInElement_[QAz_] * lz * (yi - yj)) / 12.0;</span>
<span class="nc" id="L1907">      Qj[gX_] = -Qi[gX_];</span>
      //momento rotaciÃƒÂ³n en Global Y
<span class="nc" id="L1909">      Qi[gY_] = (LoadInElement_[QAz_] * lz * (xi - xj) - LoadInElement_[QAx_] * lx * (zi - zj)) / 12.0;</span>
<span class="nc" id="L1910">      Qj[gY_] = -Qi[gY_];</span>
      //momento rotaciÃƒÂ³n en Global Z
<span class="nc" id="L1912">      Qi[gZ_] = (LoadInElement_[QAx_] * lx * (yi - yj) - LoadInElement_[QAy_] * ly * (xi - xj)) / 12.0;</span>
<span class="nc" id="L1913">      Qj[gZ_] = -Qi[gZ_];</span>
    }
<span class="nc bnc" id="L1915" title="All 4 branches missed.">    else if (vi == 1 &amp;&amp; vj == 1){</span>
      //ART-ART
      //fuerza en sentido Global X
<span class="nc bnc" id="L1918" title="All 6 branches missed.">      if(Math.abs(lx) &lt; 0.0000001 &amp;&amp; ly != 0 &amp;&amp; lz != 0.0){</span>
<span class="nc" id="L1919">        Qi[aX_] = LoadInElement_[QAx_] * Math.abs((xi - xj)) / 2.0;</span>
<span class="nc" id="L1920">        Qj[aX_] = Qi[aX_];</span>
      }
      else{
<span class="nc" id="L1923">        Qi[aX_] = LoadInElement_[QAx_] * lx / 2.0;</span>
<span class="nc" id="L1924">        Qj[aX_] = Qi[aX_];</span>
      }

      //fuerza sentido Global Y
<span class="nc bnc" id="L1928" title="All 4 branches missed.">      if ((xi - xj) == 0 &amp;&amp; (zi - zj) == 0.0){</span>
<span class="nc" id="L1929">        Qi[aY_] = LoadInElement_[QAy_] * Math.abs((yi - yj)) / 2.0;</span>
<span class="nc" id="L1930">        Qj[aY_] = Qi[aY_];</span>
      }
      else{
<span class="nc" id="L1933">        Qi[aY_] = LoadInElement_[QAy_] * ly / 2.0;</span>
<span class="nc" id="L1934">        Qj[aY_] = Qi[aY_];</span>
      }

      //fuerza sentido Global Z
<span class="nc bnc" id="L1938" title="All 6 branches missed.">      if (Math.abs(lz) &lt; 0.0000001 &amp;&amp; lx != 0 &amp;&amp; ly != 0.0){</span>
<span class="nc" id="L1939">        Qi[aZ_] = LoadInElement_[QAz_] * Math.abs((zi - zj)) / 2.0;</span>
<span class="nc" id="L1940">        Qj[aY_] = Qi[aY_];</span>
      }
      else{
        //fuerza sentido Global Z
<span class="nc" id="L1944">        Qi[aY_] = LoadInElement_[QAz_] * lz / 2.0;</span>
<span class="nc" id="L1945">        Qj[aY_] = Qi[aY_];</span>
      }

      //momento rotaciÃƒÂ³n en x local
<span class="nc" id="L1949">      Qi[gX_] = 0.0;</span>
<span class="nc" id="L1950">      Qj[gX_] = 0.0;</span>
      //momento rotaciÃƒÂ³n en y local
<span class="nc" id="L1952">      Qi[gY_] = 0.0;</span>
<span class="nc" id="L1953">      Qj[gY_] = 0.0;</span>
      //momento rotaciÃƒÂ³n en z local
<span class="nc" id="L1955">      Qi[gZ_] = 0.0;</span>
<span class="nc" id="L1956">      Qj[gZ_] = 0.0;</span>
    }

<span class="nc bnc" id="L1959" title="All 4 branches missed.">    else if (vi == 1 &amp;&amp; vj == 0){</span>
      //ART-EMP
      //fuerza en sentido Global X
<span class="nc bnc" id="L1962" title="All 6 branches missed.">      if(Math.abs(lx) &lt; 0.0000001 &amp;&amp; ly != 0 &amp;&amp; lz != 0) {</span>
<span class="nc" id="L1963">        Qi[aX_] = LoadInElement_[QAx_] * Math.abs((xi - xj)) / 2.0;</span>
<span class="nc" id="L1964">        Qj[aX_] = Qi[aX_];</span>
      }
      else{
<span class="nc" id="L1967">        Qi[aX_] = LoadInElement_[QAx_] * lx / 2.0;</span>
<span class="nc" id="L1968">        Qj[aX_] = Qi[aX_];</span>
      }

      //fuerza sentido y local
<span class="nc bnc" id="L1972" title="All 4 branches missed.">      if((xi - xj) == 0.0 &amp;&amp; (zi - zj) == 0.0){</span>
<span class="nc" id="L1973">        Qi[aY_] = 3.0 / 8.0 * LoadInElement_[QAy_] * Math.abs((yi - yj));</span>
<span class="nc" id="L1974">        Qj[aY_] = 5.0 / 8.0 * LoadInElement_[QAy_] * Math.abs((yi - yj));</span>
      }
      else{
<span class="nc" id="L1977">        Qi[aY_] = 3.0 / 8.0 * LoadInElement_[QAy_] * ly;</span>
<span class="nc" id="L1978">        Qj[aY_] = 5.0 / 8.0 * LoadInElement_[QAy_] * ly;</span>
      }

      //fuerza sentido Global Z
<span class="nc bnc" id="L1982" title="All 6 branches missed.">      if(Math.abs(lz) &lt; 0.0000001 &amp;&amp; lx != 0 &amp;&amp; ly != 0.0){</span>
<span class="nc" id="L1983">        Qi[aZ_] = LoadInElement_[QAz_] * Math.abs((zi - zj)) / 2.0;</span>
<span class="nc" id="L1984">        Qj[aZ_] = Qi[2];</span>
      }
      else{
<span class="nc" id="L1987">        Qi[aZ_] = 3.0 / 8.0 * LoadInElement_[QAz_] * lz;</span>
<span class="nc" id="L1988">        Qj[aZ_] = 5.0 / 8.0 * LoadInElement_[QAz_] * lz;</span>
      }

      //momento rotaciÃƒÂ³n en x local
<span class="nc" id="L1992">      Qi[gX_] = 0.0;</span>
<span class="nc" id="L1993">      Qj[gX_] = -(LoadInElement_[QAy_] * ly * (zi - zj) - LoadInElement_[QAz_] * lz * (yi - yj)) / 8.0;</span>
      //momento rotaciÃƒÂ³n en y local
<span class="nc" id="L1995">      Qi[gY_] = 0.0;</span>
<span class="nc" id="L1996">      Qj[gY_] = -(LoadInElement_[QAz_] * lz * (xi - xj) - LoadInElement_[QAx_] * lx * (zi - zj)) / 8.0;</span>
      //momento rotaciÃƒÂ³n en z local
<span class="nc" id="L1998">      Qi[gZ_] = 0.0;</span>
<span class="nc" id="L1999">      Qj[gZ_] = -(LoadInElement_[QAx_] * lx * (yi - yj) - LoadInElement_[QAy_] * ly * (xi - xj)) / 8.0;</span>
    }

<span class="nc bnc" id="L2002" title="All 4 branches missed.">    else if (vi == 0 &amp;&amp; vj == 1){</span>
      //EMP-ART
      //fuerza en sentido Global X
<span class="nc bnc" id="L2005" title="All 6 branches missed.">      if(Math.abs(lx) &lt; 0.0000001 &amp;&amp; ly != 0 &amp;&amp; lz != 0){</span>
<span class="nc" id="L2006">        Qi[aX_] = LoadInElement_[QAx_] * Math.abs((xi - xj)) / 2.0;</span>
<span class="nc" id="L2007">        Qj[aX_] = Qi[aX_];</span>
      }
      else{
<span class="nc" id="L2010">        Qi[aX_] = LoadInElement_[QAx_] * lx / 2.0;</span>
<span class="nc" id="L2011">        Qj[aX_] = Qi[aX_];</span>
      }

      //fuerza sentido y local
<span class="nc bnc" id="L2015" title="All 4 branches missed.">      if((xi - xj) == 0.0 &amp;&amp; (zi - zj) == 0.0){</span>
<span class="nc" id="L2016">        Qi[aY_] = 5.0 / 8.0 * LoadInElement_[QAy_] * Math.abs((yi - yj));</span>
<span class="nc" id="L2017">        Qj[aY_] = 3.0 / 8.0 * LoadInElement_[QAy_] * Math.abs((yi - yj));</span>
      }
      else{
<span class="nc" id="L2020">        Qi[aY_] = 5.0 / 8.0 * LoadInElement_[QAy_] * ly;</span>
<span class="nc" id="L2021">        Qj[aY_] = 3.0 / 8.0 * LoadInElement_[QAy_] * ly;</span>
      }
      //fuerza sentido Global Z
<span class="nc bnc" id="L2024" title="All 6 branches missed.">      if(Math.abs(lz) &lt; 0.0000001 &amp;&amp; lx != 0.0 &amp;&amp; ly != 0.0){</span>
<span class="nc" id="L2025">        Qi[aZ_] = LoadInElement_[QAz_] * Math.abs((zi - zj)) / 2.0;</span>
<span class="nc" id="L2026">        Qj[aZ_] = Qi[aZ_];</span>
      }
      else{
<span class="nc" id="L2029">        Qi[aZ_] = 5.0 / 8.0 * LoadInElement_[QAz_] * lz / 2.0;</span>
<span class="nc" id="L2030">        Qj[aZ_] = 3.0 / 8.0 * LoadInElement_[QAz_] * lz / 2.0;</span>
      }
      //momento rotaciÃƒÂ³n en x local
<span class="nc" id="L2033">      Qi[gX_] = (LoadInElement_[QAy_] * ly * (zi - zj) - LoadInElement_[QAz_] * lz * (yi - yj)) / 8.0;</span>
<span class="nc" id="L2034">      Qj[gX_] = 0.0;</span>
      //momento rotaciÃƒÂ³n en y local
<span class="nc" id="L2036">      Qi[gY_] = (LoadInElement_[QAz_] * lz * (xi - xj) - LoadInElement_[QAx_] * lx * (zi - zj)) / 8.0;</span>
<span class="nc" id="L2037">      Qj[gY_] = 0.0;</span>
      //momento rotaciÃƒÂ³n en z local
<span class="nc" id="L2039">      Qi[gZ_] = (LoadInElement_[QAx_] * lx * (yi - yj) - LoadInElement_[QAy_] * ly * (xi - xj)) / 8.0;</span>
<span class="nc" id="L2040">      Qj[gZ_] = 0.0;</span>
    }

<span class="nc bnc" id="L2043" title="All 4 branches missed.">    else if (vi == 0 &amp;&amp; vj == 9){</span>
      //EMP_LIB
      //fuerza en sentido Global X
<span class="nc bnc" id="L2046" title="All 6 branches missed.">      if (Math.abs(lx) &lt; 0.0000001 &amp;&amp; ly != 0.0 &amp;&amp; lz != 0.0){</span>
<span class="nc" id="L2047">        Qi[aX_] = LoadInElement_[QAx_] * Math.abs((xi - xj)) / 2.0;</span>
<span class="nc" id="L2048">        Qj[aX_] = Qi[aX_];</span>
      }
      else{
<span class="nc" id="L2051">        Qi[aX_] = LoadInElement_[QAx_] * lx;</span>
<span class="nc" id="L2052">        Qj[aX_] = 0.0;</span>
      }
      //fuerza sentido Global Y
<span class="nc bnc" id="L2055" title="All 4 branches missed.">      if((xi - xj) == 0.0 &amp;&amp; (zi - zj) == 0.0){</span>
<span class="nc" id="L2056">        Qi[aY_] = LoadInElement_[QAy_] * Math.abs((yi - yj));</span>
<span class="nc" id="L2057">        Qj[aY_] = 0.0;</span>
      }
      else{
<span class="nc" id="L2060">        Qi[aY_] = LoadInElement_[QAy_] * ly;</span>
<span class="nc" id="L2061">        Qj[aY_] = 0.0;</span>
      }
      //fuerza sentido Global Z
<span class="nc bnc" id="L2064" title="All 6 branches missed.">      if(Math.abs(lz) &lt; 0.0000001 &amp;&amp; lx != 0.0 &amp;&amp; ly != 0.0){</span>
<span class="nc" id="L2065">        Qi[aZ_] = LoadInElement_[QAz_] * Math.abs((zi - zj)) / 2.0;</span>
<span class="nc" id="L2066">        Qj[aZ_] = Qi[aZ_];</span>
      }
      else{
<span class="nc" id="L2069">        Qi[aZ_] = LoadInElement_[QAz_] * lz;</span>
<span class="nc" id="L2070">        Qj[aZ_] = 0.0;</span>
      }
      //momento rotaciÃƒÂ³n en Global X
<span class="nc" id="L2073">      Qi[gX_] = (LoadInElement_[QAy_] * ly * (zi - zj) - LoadInElement_[QAz_] * lz * (yi - yj)) / 2.0;</span>
<span class="nc" id="L2074">      Qj[gX_] = 0.0;</span>
      //momento rotaciÃƒÂ³n en Global Y
<span class="nc" id="L2076">      Qi[gY_] = (LoadInElement_[QAz_] * lz * (xi - xj) - LoadInElement_[QAx_] * lx * (zi - zj)) / 2.0;</span>
<span class="nc" id="L2077">      Qj[gY_] = 0.0;</span>
      //momento rotaciÃƒÂ³n en Global Z
<span class="nc" id="L2079">      Qi[gZ_] = (LoadInElement_[QAx_] * lx * (yi - yj) - LoadInElement_[QAy_] * ly * (xi - xj)) / 2.0;</span>
<span class="nc" id="L2080">      Qj[gZ_] = 0.0;</span>
    }

<span class="nc bnc" id="L2083" title="All 4 branches missed.">    else if (vi == 9 &amp;&amp; vj == 0){</span>
      //LIB_EMP
      //fuerza en sentido Global X
<span class="nc bnc" id="L2086" title="All 6 branches missed.">      if(Math.abs(lx) &lt; 0.0000001 &amp;&amp; ly != 0.0 &amp;&amp; lz != 0){</span>
<span class="nc" id="L2087">        Qi[aX_] = LoadInElement_[QAx_] * Math.abs((xi - xj)) / 2.0;</span>
<span class="nc" id="L2088">        Qj[aX_] = Qi[aX_];</span>
      }
      else{
<span class="nc" id="L2091">        Qi[aX_] = 0;</span>
<span class="nc" id="L2092">        Qj[aX_] = LoadInElement_[QAx_] * lx;</span>
      }
      //fuerza sentido Global Y
<span class="nc bnc" id="L2095" title="All 4 branches missed.">      if((xi - xj) == 0.0 &amp;&amp; (zi - zj) == 0.0){</span>
<span class="nc" id="L2096">        Qi[aY_] = 0;</span>
<span class="nc" id="L2097">        Qj[aY_] = LoadInElement_[QAy_] * Math.abs((yi - yj));</span>
      }
      else{
<span class="nc" id="L2100">        Qi[aY_] = 0.0;</span>
<span class="nc" id="L2101">        Qj[aY_] = LoadInElement_[QAy_] * ly;</span>
      }
      //fuerza sentido Global Z
<span class="nc bnc" id="L2104" title="All 6 branches missed.">      if(Math.abs(lz) &lt; 0.0000001 &amp;&amp; lx != 0.0 &amp;&amp; ly != 0.0){</span>
<span class="nc" id="L2105">        Qi[aZ_] = LoadInElement_[QAz_] * Math.abs((zi - zj)) / 2.0;</span>
<span class="nc" id="L2106">        Qj[aZ_] = Qi[aZ_];</span>
      }
      else{
<span class="nc" id="L2109">        Qi[aZ_] = 0.0;</span>
<span class="nc" id="L2110">        Qj[aZ_] = LoadInElement_[QAz_] * lz;</span>
      }
      //momento rotaciÃƒÂ³n en Global X
<span class="nc" id="L2113">      Qi[gX_] = 0.0;</span>
<span class="nc" id="L2114">      Qj[gX_] = -(LoadInElement_[QAy_] * ly * (zi - zj) - LoadInElement_[QAz_] * lz * (yi - yj)) / 2.0;</span>
      //momento rotaciÃƒÂ³n en Global Y
<span class="nc" id="L2116">      Qi[gY_] = 0.0;</span>
<span class="nc" id="L2117">      Qj[gY_] = -(LoadInElement_[QAz_] * lz * (xi - xj) - LoadInElement_[QAx_] * lx * (zi - zj)) / 2.0;</span>
      //momento rotaciÃƒÂ³n en Global Z
<span class="nc" id="L2119">      Qi[gZ_] = 0.0;</span>
<span class="nc" id="L2120">      Qj[gZ_] = -(LoadInElement_[QAx_] * lx * (yi - yj) - LoadInElement_[QAy_] * ly * (xi - xj)) / 2.0;</span>
    }

<span class="nc bnc" id="L2123" title="All 8 branches missed.">    else if ((vi == 0 &amp;&amp; vj == 2) || (vi == 2 &amp;&amp; vj == 0)){</span>
<span class="nc" id="L2124">      System.out.println(&quot;invalid link&quot;);</span>
    }

<span class="nc bnc" id="L2127" title="All 8 branches missed.">    else if ((vi == 1 &amp;&amp; vj == 2) || (vi == 2 &amp;&amp; vj == 1)){</span>
<span class="nc" id="L2128">      System.out.println(&quot;invalid link&quot;);</span>
    }

<span class="nc bnc" id="L2131" title="All 8 branches missed.">    else if ((vi == 2 &amp;&amp; vj == 3) || (vi == 3 &amp;&amp; vj == 2)){</span>
<span class="nc" id="L2132">      System.out.println(&quot;invalid link&quot;);</span>
    }


    //matriz de rotaciÃƒÂ³n de la barra del sistema principal al local
<span class="nc" id="L2137">    EBEsMatRot3DLpSaL(el);</span>

    //matriz de rotaciÃƒÂ³n de la barra del local al global
<span class="nc" id="L2140">    EBEsMatRot3DLaG(el);</span>

    //para el extremo ii
    //pi = (Rpij * Rij) * Qi
<span class="nc" id="L2144">    R = EBEsMatrizMultiplicar(Rpij, Rij);</span>
<span class="nc" id="L2145">    pi = EBEsMatrizVectorMultiplicar(R, Qi);</span>

    //para el extremo jj
    //pj = ( Rpji * Rji) * Qj
<span class="nc" id="L2149">    R = EBEsMatrizMultiplicar(Rpji, Rji);</span>
<span class="nc" id="L2150">    pj= EBEsMatrizVectorMultiplicar(R, Qj);</span>
<span class="nc" id="L2151">  }</span>

  public void EBEsMatRot3DLpSaL(int e){
    //matriz de rotaciÃƒÂ³n 3D en ejes principales &quot;yp,zp&quot; de la secciÃƒÂ³n &quot;S&quot; a ejes LOCALES &quot;y,z&quot;
    //cuando los ejes principales de la secciÃƒÂ³n estÃƒÂ¡n rotados un ÃƒÂ¡ngulo Beta respecto al sistema global

    int i , j;
    //cosenos directores de x local respecto al sistema global
    double lx; // cosenos directo respecto del eje local x (coincidente con el eje de la barra) y el eje X Global
    double mx; // cosenos directo respecto del eje local x (coincidente con el eje de la barra) y el eje Y Global
    double nx; // cosenos directo respecto del eje local x (coincidente con el eje de la barra) y el eje Z Global
    //cosenos directores de y local respecto al sistema global
    double ly; // cosenos directo respecto del eje local y (coincidente con el eje de la barra) y el eje X Global
    double my; // cosenos directo respecto del eje local y (coincidente con el eje de la barra) y el eje Y Global
    double ny; // cosenos directo respecto del eje local y (coincidente con el eje de la barra) y el eje Z Global
    //cosenos directores de z local respecto al sistema global
    double lz; // cosenos directo respecto del eje local z (coincidente con el eje de la barra) y el eje X Global
    double mz; // cosenos directo respecto del eje local z (coincidente con el eje de la barra) y el eje Y Global
    double nz; // cosenos directo respecto del eje local z (coincidente con el eje de la barra) y el eje Z Global

<span class="nc" id="L2171">    int idx = (int)Element_[e][INDEX_];</span>
<span class="nc" id="L2172">    double  beta =Groups_[idx][BETA];</span>
    //cosenos directores de x local respecto al sistema global XYZ
<span class="nc" id="L2174">    lx = 1.0;</span>
<span class="nc" id="L2175">    mx = 0.0;</span>
<span class="nc" id="L2176">    nx = 0.0;</span>
    //cosenos directores de y local respecto al sistema global XYZ
<span class="nc" id="L2178">    ly = 0.0;</span>
<span class="nc" id="L2179">    my = Math.cos(beta * Math.PI / 180.0);</span>
<span class="nc" id="L2180">    ny = Math.sin(beta * Math.PI / 180.0);</span>
    //cosenos directores de z local respecto al sistema global XYZ
<span class="nc" id="L2182">    lz = 0.0;</span>
<span class="nc" id="L2183">    mz = -Math.sin(beta * Math.PI / 180.0);</span>
<span class="nc" id="L2184">    nz = Math.cos(beta * Math.PI / 180.0);</span>

    //matriz de rotaciÃƒÂ³n de desplazamientos locales a ejes globales XYZ si los ejes principales de la
    //secciÃƒÂ³n &quot;yp,zp&quot; coinciden con los ejes locales &quot;y,z&quot; de la barra
    //para el nudo i de la barra ij
<span class="nc" id="L2189">    Rpij[0][0] = lx; Rpij[0][1] = mx; Rpij[0][2] = nx;</span>
<span class="nc" id="L2190">    Rpij[1][0] = ly; Rpij[1][1] = my; Rpij[1][2] = ny;</span>
<span class="nc" id="L2191">    Rpij[2][0] = lz; Rpij[2][1] = mz; Rpij[2][2] = nz;</span>
<span class="nc bnc" id="L2192" title="All 2 branches missed.">    for( i = 0; i&lt;3; i++){</span>
<span class="nc bnc" id="L2193" title="All 2 branches missed.">      for(j = 3; j&lt;6; j++){</span>
<span class="nc" id="L2194">        Rpij[i][j] = 0.0;</span>
      }
    }
<span class="nc bnc" id="L2197" title="All 2 branches missed.">    for(i = 3; i&lt;6 ; i++){</span>
<span class="nc bnc" id="L2198" title="All 2 branches missed.">      for(j = 0; j&lt;3; j++){</span>
<span class="nc" id="L2199">        Rpij[i][j] = 0.0;</span>
      }
    }
<span class="nc" id="L2202">    Rpij[3][3] = lx; Rpij[3][4] = mx; Rpij[3][5] = nx;</span>
<span class="nc" id="L2203">    Rpij[4][3] = ly; Rpij[4][4] = my; Rpij[4][5] = ny;</span>
<span class="nc" id="L2204">    Rpij[5][3] = lz; Rpij[5][4] = mz; Rpij[5][5] = nz;</span>

    //trasponer la matriz de rotaciÃƒÂ³n
<span class="nc" id="L2207">    RpTij = EBEsMatrizTraspuesta(Rpij);</span>

    //para el nudo j de la barra ij
<span class="nc" id="L2210">    lx = 1.0;</span>
<span class="nc" id="L2211">    mx = 0.0;</span>
<span class="nc" id="L2212">    nx = 0.0;</span>
    //cosenos directores de y local respecto al sistema global XYZ
<span class="nc" id="L2214">    ly = 0.0;</span>
<span class="nc" id="L2215">    my = Math.cos(beta * Math.PI / 180.0);</span>
<span class="nc" id="L2216">    ny = -Math.sin(beta * Math.PI / 180.0);</span>
    //cosenos directores de z local respecto al sistema global XYZ
<span class="nc" id="L2218">    lz = 0.0;</span>
<span class="nc" id="L2219">    mz = Math.sin(beta * Math.PI / 180.0);</span>
<span class="nc" id="L2220">    nz = Math.cos(beta * Math.PI / 180.0);</span>

<span class="nc" id="L2222">    Rpji[0][0] = lx; Rpji[0][1] = mx; Rpji[0][2] = nx;</span>
<span class="nc" id="L2223">    Rpji[1][0] = ly; Rpji[1][1] = my; Rpji[1][2] = ny;</span>
<span class="nc" id="L2224">    Rpji[2][0] = lz; Rpji[2][1] = mz; Rpji[2][2] = nz;</span>
<span class="nc bnc" id="L2225" title="All 2 branches missed.">    for(i = 0; i&lt;3; i++){</span>
<span class="nc bnc" id="L2226" title="All 2 branches missed.">      for(j = 3; j&lt;6; j++){</span>
<span class="nc" id="L2227">        Rpji[i][j] = 0.0;</span>
      }
    }
<span class="nc bnc" id="L2230" title="All 2 branches missed.">    for(i = 3; i&lt;6 ; i++){</span>
<span class="nc bnc" id="L2231" title="All 2 branches missed.">      for(j = 0; j&lt;3; j++){</span>
<span class="nc" id="L2232">        Rpji[i][j] = 0.0;</span>
      }
    }
<span class="nc" id="L2235">    Rpji[3][3] = lx; Rpji[3][4] = mx; Rpji[3][5] = nx;</span>
<span class="nc" id="L2236">    Rpji[4][3] = ly; Rpji[4][4] = my; Rpji[4][5] = ny;</span>
<span class="nc" id="L2237">    Rpji[5][3] = lz; Rpji[5][4] = mz; Rpji[5][5] = nz;</span>

    //trasponer la matriz de rotaciÃƒÂ³n
<span class="nc" id="L2240">    RpTji = EBEsMatrizTraspuesta(Rpji);</span>

<span class="nc" id="L2242">  }</span>

  public double [][]EBEsMatrizTraspuesta(double m[][]){

<span class="nc" id="L2246">    int row=m.length;</span>
<span class="nc" id="L2247">    int col=m[0].length;</span>
<span class="nc" id="L2248">    double[][] mt = new double [row][col];</span>

<span class="nc bnc" id="L2250" title="All 2 branches missed.">    for(int i = 0; i&lt; row; i++){</span>
      // cantidad de elementos de la 1ra dimensiÃƒÂ³n
<span class="nc bnc" id="L2252" title="All 2 branches missed.">      for(int j = 0; j&lt; col;j++){</span>
        // cantidad de elementos de la 2ra dimensiÃƒÂ³n
<span class="nc" id="L2254">        mt[j][i] = m[i][j];</span>
      }
    }

<span class="nc" id="L2258">    return mt;</span>
  }

  public void EBEsEcuationSolution(int hi) throws JMetalException{

    // Formacion del sistema de ecuaciones
    // adaptive method of book
    // LA ESTRUCTURA METÃƒï¿½LICA HOY
    // PROGRAMACIÃƒâ€œNN TOMO III
    // RamÃƒÂ³n Arguellez Ãƒï¿½lvarez

    int i, j;
<span class="nc" id="L2270">    int s1 = 1;</span>
    int s2, l5, l6, ln, r;
<span class="nc" id="L2272">    double det = 1.0;</span>
<span class="nc" id="L2273">    double ff=0.0, t;</span>

<span class="nc" id="L2275">    int n2 = numberOfLibertyDegree_ * numberOfNodes;</span>

<span class="nc bnc" id="L2277" title="All 2 branches missed.">    for(i=1; i&lt;n2 ;i++){</span>
<span class="nc bnc" id="L2278" title="All 2 branches missed.">      if(MatrixStiffness_[s1 - 1] &gt;= 1.0E+25){</span>
<span class="nc" id="L2279">        s1 = s1 + matrixWidthBand_;</span>
<span class="nc" id="L2280">        continue;  // Salto1:</span>
      }
<span class="nc" id="L2282">      ln = i + 1;</span>
<span class="nc" id="L2283">      l5 = s1 + 1;</span>
<span class="nc bnc" id="L2284" title="All 2 branches missed.">      for(j=2; j&lt;matrixWidthBand_+1; j++){</span>
<span class="nc bnc" id="L2285" title="All 2 branches missed.">        if(ln - n2 &gt; 0){</span>
<span class="nc" id="L2286">          break; // Salto2:</span>
        }
<span class="nc bnc" id="L2288" title="All 2 branches missed.">        if(MatrixStiffness_[s1 - 1] == 0){</span>
<span class="nc" id="L2289">          ln = ln + 1;</span>
<span class="nc" id="L2290">          l5 = l5 + 1;</span>
<span class="nc" id="L2291">          continue; // Salto3;</span>
        }
<span class="nc" id="L2293">        t = MatrixStiffness_[l5 - 1] / MatrixStiffness_[s1 - 1];</span>
<span class="nc" id="L2294">        l6 = (ln - 1) * matrixWidthBand_ + 1;</span>
<span class="nc" id="L2295">        s2 = s1 + j - 1;</span>
<span class="nc bnc" id="L2296" title="All 2 branches missed.">        for(r = j; r&lt;matrixWidthBand_+1; r++){</span>
<span class="nc" id="L2297">          MatrixStiffness_[l6 - 1] = MatrixStiffness_[l6 - 1] - t * MatrixStiffness_[s2 - 1];</span>
<span class="nc" id="L2298">          l6 = l6 + 1;</span>
<span class="nc" id="L2299">          s2 = s2 + 1;</span>
        } // next r
<span class="nc" id="L2301">        DisplacementNodes_[ln - 1][hi] = DisplacementNodes_[ln - 1][hi] - t * DisplacementNodes_[i - 1][hi];</span>
<span class="nc" id="L2302">        ln = ln + 1;</span>
<span class="nc" id="L2303">        l5 = l5 + 1;</span>
        // Salto3:
      } // next j
      // Salto2:
<span class="nc" id="L2307">      s1 = s1 + matrixWidthBand_;</span>
      //Salto1:
    } // next i

    // ResoluciÃƒÂ³n del sistema
<span class="nc" id="L2312">    i = n2 + 1;</span>
<span class="nc bnc" id="L2313" title="All 2 branches missed.">    for(int s3=1; s3&lt;n2+1; s3++){</span>
<span class="nc" id="L2314">      i = i - 1;</span>
<span class="nc" id="L2315">      ff = 0.0;</span>

<span class="nc" id="L2317">      ln = i + 1;</span>
<span class="nc" id="L2318">      l5 = s1 + 1;</span>
<span class="nc bnc" id="L2319" title="All 2 branches missed.">      for(j = 2; j&lt;matrixWidthBand_+1; j++){</span>
<span class="nc bnc" id="L2320" title="All 2 branches missed.">        if(ln - n2 &gt; 0){</span>
<span class="nc" id="L2321">          break; // Salto4:</span>
        }
<span class="nc" id="L2323">        ff = ff + DisplacementNodes_[ln-1][hi] * MatrixStiffness_[l5-1];</span>
<span class="nc" id="L2324">        ln = ln + 1;</span>
<span class="nc" id="L2325">        l5 = l5 + 1;</span>
      } // Next j
      // Salto4:
<span class="nc bnc" id="L2328" title="All 2 branches missed.">      if(Math.abs(MatrixStiffness_[s1-1])&lt;=1.0E-35){</span>
<span class="nc" id="L2329">        DisplacementNodes_[i-1][hi]=1.0E-35;</span>
      }
      else{
<span class="nc" id="L2332">        DisplacementNodes_[i-1][hi]=(DisplacementNodes_[i-1][hi]-ff)/MatrixStiffness_[s1 - 1];</span>
      }

<span class="nc bnc" id="L2335" title="All 2 branches missed.">      if(MatrixStiffness_[s1 - 1] &lt; 9.899999E+15){</span>
<span class="nc" id="L2336">        det = det * MatrixStiffness_[s1 - 1] / 100000.0;</span>
      }
<span class="nc" id="L2338">      s1 = s1 - matrixWidthBand_;</span>
    } // Next s3


<span class="nc" id="L2342">  }// end EcuationSolution</span>

  public void EBEsMat3DL_iRig_jRig(int e) throws JMetalException{
    // The element element 3D than form rigid matrix in the local coordinates
    // i: rigid
    // j: rigid
    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i + esfuerzo en i
    // double [][]Kii = new double [5][5];
    // Elements
    // the Element long
<span class="nc" id="L2352">    double Lij=Element_[e][L_];</span>
    // Secction
<span class="nc" id="L2354">    int idx = (int)Element_[e][INDEX_];</span>
<span class="nc" id="L2355">    double S=Groups_[idx][AREA];</span>
    // inertia in axis local z
<span class="nc" id="L2357">    double Iz=Groups_[idx][Iz_];</span>
    // inertia in axis local y
<span class="nc" id="L2359">    double Iy=Groups_[idx][Iy_];</span>
    // inertia torsion
<span class="nc" id="L2361">    double Ip=Groups_[idx][It_];</span>
    // elastic modulus (Young)
<span class="nc" id="L2363">    double E=Groups_[idx][E_];</span>
    //  elastic transversal modulus
<span class="nc" id="L2365">    double G=Groups_[idx][G_];</span>
    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i + esfuerzo en i
<span class="nc" id="L2367">    Kii[0][0] = E * S / Lij;</span>
<span class="nc" id="L2368">    Kii[0][1] = 0;</span>
<span class="nc" id="L2369">    Kii[0][2] = 0;</span>
<span class="nc" id="L2370">    Kii[0][3] = 0;</span>
<span class="nc" id="L2371">    Kii[0][4] = 0;</span>
<span class="nc" id="L2372">    Kii[0][5] = 0;</span>
<span class="nc" id="L2373">    Kii[1][0] = 0;</span>
<span class="nc" id="L2374">    Kii[1][1] = 12 * E * Iz / Math.pow(Lij, 3);</span>
<span class="nc" id="L2375">    Kii[1][2] = 0;</span>
<span class="nc" id="L2376">    Kii[1][3] = 0;</span>
<span class="nc" id="L2377">    Kii[1][4] = 0;</span>
<span class="nc" id="L2378">    Kii[1][5] = -6 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2379">    Kii[2][0] = 0;</span>
<span class="nc" id="L2380">    Kii[2][1] = 0;</span>
<span class="nc" id="L2381">    Kii[2][2] = 12 * E * Iy / Math.pow(Lij, 3);</span>
<span class="nc" id="L2382">    Kii[2][3] = 0;</span>
<span class="nc" id="L2383">    Kii[2][4] = 6 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2384">    Kii[2][5] = 0;</span>
<span class="nc" id="L2385">    Kii[3][0] = 0;</span>
<span class="nc" id="L2386">    Kii[3][1] = 0;</span>
<span class="nc" id="L2387">    Kii[3][2] = 0;</span>
<span class="nc" id="L2388">    Kii[3][3] = G * Ip / Lij;</span>
<span class="nc" id="L2389">    Kii[3][4] = 0;</span>
<span class="nc" id="L2390">    Kii[3][5] = 0;</span>
<span class="nc" id="L2391">    Kii[4][0] = 0;</span>
<span class="nc" id="L2392">    Kii[4][1] = 0;</span>
<span class="nc" id="L2393">    Kii[4][2] = 6 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2394">    Kii[4][3] = 0;</span>
<span class="nc" id="L2395">    Kii[4][4] = 4 * E * Iy / Lij;</span>
<span class="nc" id="L2396">    Kii[4][5] = 0;</span>
<span class="nc" id="L2397">    Kii[5][0] = 0;</span>
<span class="nc" id="L2398">    Kii[5][1] = -6 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2399">    Kii[5][2] = 0;</span>
<span class="nc" id="L2400">    Kii[5][3] = 0;</span>
<span class="nc" id="L2401">    Kii[5][4] = 0;</span>
<span class="nc" id="L2402">    Kii[5][5] = 4 * E * Iz / Lij;</span>

    // esfuerzos en nudo i por reacciÃƒÂ³n de desplazamientos en j
<span class="nc" id="L2405">    Kij[0][0] = E * S / Lij;</span>
<span class="nc" id="L2406">    Kij[0][1] = 0;</span>
<span class="nc" id="L2407">    Kij[0][2] = 0;</span>
<span class="nc" id="L2408">    Kij[0][3] = 0;</span>
<span class="nc" id="L2409">    Kij[0][4] = 0;</span>
<span class="nc" id="L2410">    Kij[0][5] = 0;</span>
<span class="nc" id="L2411">    Kij[1][0] = 0;</span>
<span class="nc" id="L2412">    Kij[1][1] = 12 * E * Iz / Math.pow(Lij, 3);</span>
<span class="nc" id="L2413">    Kij[1][2] = 0;</span>
<span class="nc" id="L2414">    Kij[1][3] = 0;</span>
<span class="nc" id="L2415">    Kij[1][4] = 0;</span>
<span class="nc" id="L2416">    Kij[1][5] = -6 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2417">    Kij[2][0] = 0;</span>
<span class="nc" id="L2418">    Kij[2][1] = 0;</span>
<span class="nc" id="L2419">    Kij[2][2] = -12 * E * Iy / Math.pow(Lij, 3);</span>
<span class="nc" id="L2420">    Kij[2][3] = 0;</span>
<span class="nc" id="L2421">    Kij[2][4] = -6 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2422">    Kij[2][5] = 0;</span>
<span class="nc" id="L2423">    Kij[3][0] = 0;</span>
<span class="nc" id="L2424">    Kij[3][1] = 0;</span>
<span class="nc" id="L2425">    Kij[3][2] = 0;</span>
<span class="nc" id="L2426">    Kij[3][3] = G * Ip / Lij;</span>
<span class="nc" id="L2427">    Kij[3][4] = 0;</span>
<span class="nc" id="L2428">    Kij[3][5] = 0;</span>
<span class="nc" id="L2429">    Kij[4][0] = 0;</span>
<span class="nc" id="L2430">    Kij[4][1] = 0;</span>
<span class="nc" id="L2431">    Kij[4][2] = -6 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2432">    Kij[4][3] = 0;</span>
<span class="nc" id="L2433">    Kij[4][4] = -2 * E * Iy / Lij;</span>
<span class="nc" id="L2434">    Kij[4][5] = 0;</span>
<span class="nc" id="L2435">    Kij[5][0] = 0;</span>
<span class="nc" id="L2436">    Kij[5][1] = -6 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2437">    Kij[5][2] = 0;</span>
<span class="nc" id="L2438">    Kij[5][3] = 0;</span>
<span class="nc" id="L2439">    Kij[5][4] = 0;</span>
<span class="nc" id="L2440">    Kij[5][5] = 2 * E * Iz / Lij;</span>

    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i
<span class="nc" id="L2443">    Kji[0][0] = E * S / Lij;</span>
<span class="nc" id="L2444">    Kji[0][1] = 0;</span>
<span class="nc" id="L2445">    Kji[0][2] = 0;</span>
<span class="nc" id="L2446">    Kji[0][3] = 0;</span>
<span class="nc" id="L2447">    Kji[0][4] = 0;</span>
<span class="nc" id="L2448">    Kji[0][5] = 0;</span>
<span class="nc" id="L2449">    Kji[1][0] = 0;</span>
<span class="nc" id="L2450">    Kji[1][1] = 12 * E * Iz / Math.pow(Lij, 3);</span>
<span class="nc" id="L2451">    Kji[1][2] = 0;</span>
<span class="nc" id="L2452">    Kji[1][3] = 0;</span>
<span class="nc" id="L2453">    Kji[1][4] = 0;</span>
<span class="nc" id="L2454">    Kji[1][5] = -6 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2455">    Kji[2][0] = 0;</span>
<span class="nc" id="L2456">    Kji[2][1] = 0;</span>
<span class="nc" id="L2457">    Kji[2][2] = -12 * E * Iy / Math.pow(Lij, 3);</span>
<span class="nc" id="L2458">    Kji[2][3] = 0;</span>
<span class="nc" id="L2459">    Kji[2][4] = -6 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2460">    Kji[2][5] = 0;</span>
<span class="nc" id="L2461">    Kji[3][0] = 0;</span>
<span class="nc" id="L2462">    Kji[3][1] = 0;</span>
<span class="nc" id="L2463">    Kji[3][2] = 0;</span>
<span class="nc" id="L2464">    Kji[3][3] = G * Ip / Lij;</span>
<span class="nc" id="L2465">    Kji[3][4] = 0;</span>
<span class="nc" id="L2466">    Kji[3][5] = 0;</span>
<span class="nc" id="L2467">    Kji[4][0] = 0;</span>
<span class="nc" id="L2468">    Kji[4][1] = 0;</span>
<span class="nc" id="L2469">    Kji[4][2] = -6 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2470">    Kji[4][3] = 0;</span>
<span class="nc" id="L2471">    Kji[4][4] = -2 * E * Iy / Lij;</span>
<span class="nc" id="L2472">    Kji[4][5] = 0;</span>
<span class="nc" id="L2473">    Kji[5][0] = 0;</span>
<span class="nc" id="L2474">    Kji[5][1] = -6 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2475">    Kji[5][2] = 0;</span>
<span class="nc" id="L2476">    Kji[5][3] = 0;</span>
<span class="nc" id="L2477">    Kji[5][4] = 0;</span>
<span class="nc" id="L2478">    Kji[5][5] = 2 * E * Iz / Lij;</span>

    // esfuerzos en nudo i por reacciÃƒÂ³n de desplazamientos en j + esfuerzo en j
<span class="nc" id="L2481">    Kjj[0][0] = E * S / Lij;</span>
<span class="nc" id="L2482">    Kjj[0][1] = 0;</span>
<span class="nc" id="L2483">    Kjj[0][2] = 0;</span>
<span class="nc" id="L2484">    Kjj[0][3] = 0;</span>
<span class="nc" id="L2485">    Kjj[0][4] = 0;</span>
<span class="nc" id="L2486">    Kjj[0][5] = 0;</span>
<span class="nc" id="L2487">    Kjj[1][0] = 0;</span>
<span class="nc" id="L2488">    Kjj[1][1] = 12 * E * Iz / Math.pow(Lij, 3);</span>
<span class="nc" id="L2489">    Kjj[1][2] = 0;</span>
<span class="nc" id="L2490">    Kjj[1][3] = 0;</span>
<span class="nc" id="L2491">    Kjj[1][4] = 0;</span>
<span class="nc" id="L2492">    Kjj[1][5] = -6 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2493">    Kjj[2][0] = 0;</span>
<span class="nc" id="L2494">    Kjj[2][1] = 0;</span>
<span class="nc" id="L2495">    Kjj[2][2] = 12 * E * Iy / Math.pow(Lij, 3);</span>
<span class="nc" id="L2496">    Kjj[2][3] = 0;</span>
<span class="nc" id="L2497">    Kjj[2][4] = 6 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2498">    Kjj[2][5] = 0;</span>
<span class="nc" id="L2499">    Kjj[3][0] = 0;</span>
<span class="nc" id="L2500">    Kjj[3][1] = 0;</span>
<span class="nc" id="L2501">    Kjj[3][2] = 0;</span>
<span class="nc" id="L2502">    Kjj[3][3] = G * Ip / Lij;</span>
<span class="nc" id="L2503">    Kjj[3][4] = 0;</span>
<span class="nc" id="L2504">    Kjj[3][5] = 0;</span>
<span class="nc" id="L2505">    Kjj[4][0] = 0;</span>
<span class="nc" id="L2506">    Kjj[4][1] = 0;</span>
<span class="nc" id="L2507">    Kjj[4][2] = 6 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2508">    Kjj[4][3] = 0;</span>
<span class="nc" id="L2509">    Kjj[4][4] = 4 * E * Iy / Lij;</span>
<span class="nc" id="L2510">    Kjj[4][5] = 0;</span>
<span class="nc" id="L2511">    Kjj[5][0] = 0;</span>
<span class="nc" id="L2512">    Kjj[5][1] = -6 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2513">    Kjj[5][2] = 0;</span>
<span class="nc" id="L2514">    Kjj[5][3] = 0;</span>
<span class="nc" id="L2515">    Kjj[5][4] = 0;</span>
<span class="nc" id="L2516">    Kjj[5][5] = 4 * E * Iz / Lij;</span>

    // PrintArchTxtMKLB(e);

<span class="nc" id="L2520">  }</span>

  public void EBEsMat3DL_iArt_jRig(int e) throws JMetalException{
    // The element element 3D than form rigid matrix in the local coordinates
    // i: rigid
    // j: rigid
    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i + esfuerzo en i
    // double [][]Kii = new double [5][5];
    // Elements
    // the Element long
<span class="nc" id="L2530">    double Lij=Element_[e][L_];</span>
    // index gropus
<span class="nc" id="L2532">    int idx = (int)Element_[e][INDEX_];</span>
    // Secction
<span class="nc" id="L2534">    double S=Groups_[idx][AREA];</span>
    // inertia in axis local z
<span class="nc" id="L2536">    double Iz=Groups_[idx][Iz_];</span>
    // inertia in axis local y
<span class="nc" id="L2538">    double Iy=Groups_[idx][Iy_];</span>
    // elastic modulus (Young)
<span class="nc" id="L2540">    double E=Groups_[idx][E_];</span>
    //  elastic transversal modulus

    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i + esfuerzo en i
<span class="nc" id="L2544">    Kii[0][0] = E * S / Lij;</span>
<span class="nc" id="L2545">    Kii[0][1] = 0;</span>
<span class="nc" id="L2546">    Kii[0][2] = 0;</span>
<span class="nc" id="L2547">    Kii[0][3] = 0;</span>
<span class="nc" id="L2548">    Kii[0][4] = 0;</span>
<span class="nc" id="L2549">    Kii[0][5] = 0;</span>
<span class="nc" id="L2550">    Kii[1][0] = 0;</span>
<span class="nc" id="L2551">    Kii[1][1] = 3 * E * Iz / Math.pow(Lij, 3);</span>
<span class="nc" id="L2552">    Kii[1][2] = 0;</span>
<span class="nc" id="L2553">    Kii[1][3] = 0;</span>
<span class="nc" id="L2554">    Kii[1][4] = 0;</span>
<span class="nc" id="L2555">    Kii[1][5] = 0;</span>
<span class="nc" id="L2556">    Kii[2][0] = 0;</span>
<span class="nc" id="L2557">    Kii[2][1] = 0;</span>
<span class="nc" id="L2558">    Kii[2][2] = 3 * E * Iy / Math.pow(Lij, 3);</span>
<span class="nc" id="L2559">    Kii[2][3] = 0;</span>
<span class="nc" id="L2560">    Kii[2][4] = 0;</span>
<span class="nc" id="L2561">    Kii[2][5] = 0;</span>
<span class="nc" id="L2562">    Kii[3][0] = 0;</span>
<span class="nc" id="L2563">    Kii[3][1] = 0;</span>
<span class="nc" id="L2564">    Kii[3][2] = 0;</span>
<span class="nc" id="L2565">    Kii[3][3] = 0;</span>
<span class="nc" id="L2566">    Kii[3][4] = 0;</span>
<span class="nc" id="L2567">    Kii[3][5] = 0;</span>
<span class="nc" id="L2568">    Kii[4][0] = 0;</span>
<span class="nc" id="L2569">    Kii[4][1] = 0;</span>
<span class="nc" id="L2570">    Kii[4][2] = 0;</span>
<span class="nc" id="L2571">    Kii[4][3] = 0;</span>
<span class="nc" id="L2572">    Kii[4][4] = 0;</span>
<span class="nc" id="L2573">    Kii[4][5] = 0;</span>
<span class="nc" id="L2574">    Kii[5][0] = 0;</span>
<span class="nc" id="L2575">    Kii[5][1] = 0;</span>
<span class="nc" id="L2576">    Kii[5][2] = 0;</span>
<span class="nc" id="L2577">    Kii[5][3] = 0;</span>
<span class="nc" id="L2578">    Kii[5][4] = 0;</span>
<span class="nc" id="L2579">    Kii[5][5] = 0;</span>

    // esfuerzos en nudo i por reacciÃƒÂ³n de desplazamientos en j
<span class="nc" id="L2582">    Kij[0][0] = E * S / Lij;</span>
<span class="nc" id="L2583">    Kij[0][1] = 0;</span>
<span class="nc" id="L2584">    Kij[0][2] = 0;</span>
<span class="nc" id="L2585">    Kij[0][3] = 0;</span>
<span class="nc" id="L2586">    Kij[0][4] = 0;</span>
<span class="nc" id="L2587">    Kij[0][5] = 0;</span>
<span class="nc" id="L2588">    Kij[1][0] = 0;</span>
<span class="nc" id="L2589">    Kij[1][1] = 3 * E * Iz / Math.pow(Lij, 3);</span>
<span class="nc" id="L2590">    Kij[1][2] = 0;</span>
<span class="nc" id="L2591">    Kij[1][3] = 0;</span>
<span class="nc" id="L2592">    Kij[1][4] = 0;</span>
<span class="nc" id="L2593">    Kij[1][5] = -3 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2594">    Kij[2][0] = 0;</span>
<span class="nc" id="L2595">    Kij[2][1] = 0;</span>
<span class="nc" id="L2596">    Kij[2][2] = -3 * E * Iy / Math.pow(Lij, 3);</span>
<span class="nc" id="L2597">    Kij[2][3] = 0;</span>
<span class="nc" id="L2598">    Kij[2][4] = -3 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2599">    Kij[2][5] = 0;</span>
<span class="nc" id="L2600">    Kij[3][0] = 0;</span>
<span class="nc" id="L2601">    Kij[3][1] = 0;</span>
<span class="nc" id="L2602">    Kij[3][2] = 0;</span>
<span class="nc" id="L2603">    Kij[3][3] = 0;</span>
<span class="nc" id="L2604">    Kij[3][4] = 0;</span>
<span class="nc" id="L2605">    Kij[3][5] = 0;</span>
<span class="nc" id="L2606">    Kij[4][0] = 0;</span>
<span class="nc" id="L2607">    Kij[4][1] = 0;</span>
<span class="nc" id="L2608">    Kij[4][2] = 0;</span>
<span class="nc" id="L2609">    Kij[4][3] = 0;</span>
<span class="nc" id="L2610">    Kij[4][4] = 0;</span>
<span class="nc" id="L2611">    Kij[4][5] = 0;</span>
<span class="nc" id="L2612">    Kij[5][0] = 0;</span>
<span class="nc" id="L2613">    Kij[5][1] = 0;</span>
<span class="nc" id="L2614">    Kij[5][2] = 0;</span>
<span class="nc" id="L2615">    Kij[5][3] = 0;</span>
<span class="nc" id="L2616">    Kij[5][4] = 0;</span>
<span class="nc" id="L2617">    Kij[5][5] = 0;</span>

    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i
<span class="nc" id="L2620">    Kji[0][0] = E * S / Lij;</span>
<span class="nc" id="L2621">    Kji[0][1] = 0;</span>
<span class="nc" id="L2622">    Kji[0][2] = 0;</span>
<span class="nc" id="L2623">    Kji[0][3] = 0;</span>
<span class="nc" id="L2624">    Kji[0][4] = 0;</span>
<span class="nc" id="L2625">    Kji[0][5] = 0;</span>
<span class="nc" id="L2626">    Kji[1][0] = 0;</span>
<span class="nc" id="L2627">    Kji[1][1] = 3 * E * Iz / Math.pow(Lij, 3);</span>
<span class="nc" id="L2628">    Kji[1][2] = 0;</span>
<span class="nc" id="L2629">    Kji[1][3] = 0;</span>
<span class="nc" id="L2630">    Kji[1][4] = 0;</span>
<span class="nc" id="L2631">    Kji[1][5] = 0;</span>
<span class="nc" id="L2632">    Kji[2][0] = 0;</span>
<span class="nc" id="L2633">    Kji[2][1] = 0;</span>
<span class="nc" id="L2634">    Kji[2][2] = -3 * E * Iy / Math.pow(Lij, 3);</span>
<span class="nc" id="L2635">    Kji[2][3] = 0;</span>
<span class="nc" id="L2636">    Kji[2][4] = 0;</span>
<span class="nc" id="L2637">    Kji[2][5] = 0;</span>
<span class="nc" id="L2638">    Kji[3][0] = 0;</span>
<span class="nc" id="L2639">    Kji[3][1] = 0;</span>
<span class="nc" id="L2640">    Kji[3][2] = 0;</span>
<span class="nc" id="L2641">    Kji[3][3] = 0;</span>
<span class="nc" id="L2642">    Kji[3][4] = 0;</span>
<span class="nc" id="L2643">    Kji[3][5] = 0;</span>
<span class="nc" id="L2644">    Kji[4][0] = 0;</span>
<span class="nc" id="L2645">    Kji[4][1] = 0;</span>
<span class="nc" id="L2646">    Kji[4][2] = -3 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2647">    Kji[4][3] = 0;</span>
<span class="nc" id="L2648">    Kji[4][4] = 0;</span>
<span class="nc" id="L2649">    Kji[4][5] = 0;</span>
<span class="nc" id="L2650">    Kji[5][0] = 0;</span>
<span class="nc" id="L2651">    Kji[5][1] = -3 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2652">    Kji[5][2] = 0;</span>
<span class="nc" id="L2653">    Kji[5][3] = 0;</span>
<span class="nc" id="L2654">    Kji[5][4] = 0;</span>
<span class="nc" id="L2655">    Kji[5][5] = 0;</span>

    // esfuerzos en nudo i por reacciÃƒÂ³n de desplazamientos en j + esfuerzo en j
<span class="nc" id="L2658">    Kjj[0][0] = E * S / Lij;</span>
<span class="nc" id="L2659">    Kjj[0][1] = 0;</span>
<span class="nc" id="L2660">    Kjj[0][2] = 0;</span>
<span class="nc" id="L2661">    Kjj[0][3] = 0;</span>
<span class="nc" id="L2662">    Kjj[0][4] = 0;</span>
<span class="nc" id="L2663">    Kjj[0][5] = 0;</span>
<span class="nc" id="L2664">    Kjj[1][0] = 0;</span>
<span class="nc" id="L2665">    Kjj[1][1] = 3 * E * Iz / Math.pow(Lij, 3);</span>
<span class="nc" id="L2666">    Kjj[1][2] = 0;</span>
<span class="nc" id="L2667">    Kjj[1][3] = 0;</span>
<span class="nc" id="L2668">    Kjj[1][4] = 0;</span>
<span class="nc" id="L2669">    Kjj[1][5] = -3 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2670">    Kjj[2][0] = 0;</span>
<span class="nc" id="L2671">    Kjj[2][1] = 0;</span>
<span class="nc" id="L2672">    Kjj[2][2] = 3 * E * Iy / Math.pow(Lij, 3);</span>
<span class="nc" id="L2673">    Kjj[2][3] = 0;</span>
<span class="nc" id="L2674">    Kjj[2][4] = 3 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2675">    Kjj[2][5] = 0;</span>
<span class="nc" id="L2676">    Kjj[3][0] = 0;</span>
<span class="nc" id="L2677">    Kjj[3][1] = 0;</span>
<span class="nc" id="L2678">    Kjj[3][2] = 0;</span>
<span class="nc" id="L2679">    Kjj[3][3] = 0;</span>
<span class="nc" id="L2680">    Kjj[3][4] = 0;</span>
<span class="nc" id="L2681">    Kjj[3][5] = 0;</span>
<span class="nc" id="L2682">    Kjj[4][0] = 0;</span>
<span class="nc" id="L2683">    Kjj[4][1] = 0;</span>
<span class="nc" id="L2684">    Kjj[4][2] = 3 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2685">    Kjj[4][3] = 0;</span>
<span class="nc" id="L2686">    Kjj[4][4] = 3 * E * Iy / Lij;</span>
<span class="nc" id="L2687">    Kjj[4][5] = 0;</span>
<span class="nc" id="L2688">    Kjj[5][0] = 0;</span>
<span class="nc" id="L2689">    Kjj[5][1] = -3 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2690">    Kjj[5][2] = 0;</span>
<span class="nc" id="L2691">    Kjj[5][3] = 0;</span>
<span class="nc" id="L2692">    Kjj[5][4] = 0;</span>
<span class="nc" id="L2693">    Kjj[5][5] = 3 * E * Iz / Lij;</span>

    // PrintArchTxtMKLB(e);

<span class="nc" id="L2697">  }</span>

  public void EBEsMat3DL_iRig_jArt(int e) throws JMetalException{
    // The element element 3D than form rigid matrix in the local coordinates
    // i: rigid
    // j: rigid
    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i + esfuerzo en i
    // double [][]Kii = new double [5][5];
    // Elements
    // the Element long
<span class="nc" id="L2707">    double Lij=Element_[e][L_];</span>
    // index gropus
<span class="nc" id="L2709">    int idx = (int)Element_[e][INDEX_];</span>
    // angle beta
<span class="nc" id="L2711">    double S=Groups_[idx][AREA];</span>
    // inertia in axis local z
<span class="nc" id="L2713">    double Iz=Groups_[idx][Iz_];</span>
    // inertia in axis local y
<span class="nc" id="L2715">    double Iy=Groups_[idx][Iy_];</span>
    // inertia torsion
    // elastic modulus (Young)
<span class="nc" id="L2718">    double E=Groups_[idx][E_];</span>
    //  elastic transversal modulus

    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i + esfuerzo en i
<span class="nc" id="L2722">    Kii[0][0] = E * S / Lij;</span>
<span class="nc" id="L2723">    Kii[0][1] = 0;</span>
<span class="nc" id="L2724">    Kii[0][2] = 0;</span>
<span class="nc" id="L2725">    Kii[0][3] = 0;</span>
<span class="nc" id="L2726">    Kii[0][4] = 0;</span>
<span class="nc" id="L2727">    Kii[0][5] = 0;</span>
<span class="nc" id="L2728">    Kii[1][0] = 0;</span>
<span class="nc" id="L2729">    Kii[1][1] = 3 * E * Iz / Math.pow(Lij, 3);</span>
<span class="nc" id="L2730">    Kii[1][2] = 0;</span>
<span class="nc" id="L2731">    Kii[1][3] = 0;</span>
<span class="nc" id="L2732">    Kii[1][4] = 0;</span>
<span class="nc" id="L2733">    Kii[1][5] = -3 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2734">    Kii[2][0] = 0;</span>
<span class="nc" id="L2735">    Kii[2][1] = 0;</span>
<span class="nc" id="L2736">    Kii[2][2] = 3 * E * Iy / Math.pow(Lij, 3);</span>
<span class="nc" id="L2737">    Kii[2][3] = 0;</span>
<span class="nc" id="L2738">    Kii[2][4] = 3 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2739">    Kii[2][5] = 0;</span>
<span class="nc" id="L2740">    Kii[3][0] = 0;</span>
<span class="nc" id="L2741">    Kii[3][1] = 0;</span>
<span class="nc" id="L2742">    Kii[3][2] = 0;</span>
<span class="nc" id="L2743">    Kii[3][3] = 0;</span>
<span class="nc" id="L2744">    Kii[3][4] = 0;</span>
<span class="nc" id="L2745">    Kii[3][5] = 0;</span>
<span class="nc" id="L2746">    Kii[4][0] = 0;</span>
<span class="nc" id="L2747">    Kii[4][1] = 0;</span>
<span class="nc" id="L2748">    Kii[4][2] = 3 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2749">    Kii[4][3] = 0;</span>
<span class="nc" id="L2750">    Kii[4][4] = 3 * E * Iy / Lij;</span>
<span class="nc" id="L2751">    Kii[4][5] = 0;</span>
<span class="nc" id="L2752">    Kii[5][0] = 0;</span>
<span class="nc" id="L2753">    Kii[5][1] = -3 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2754">    Kii[5][2] = 0;</span>
<span class="nc" id="L2755">    Kii[5][3] = 0;</span>
<span class="nc" id="L2756">    Kii[5][4] = 0;</span>
<span class="nc" id="L2757">    Kii[5][5] = 3 * E * Iz / Lij;</span>

    // esfuerzos en nudo i por reacciÃƒÂ³n de desplazamientos en j
<span class="nc" id="L2760">    Kij[0][0] = E * S / Lij;</span>
<span class="nc" id="L2761">    Kij[0][1] = 0;</span>
<span class="nc" id="L2762">    Kij[0][2] = 0;</span>
<span class="nc" id="L2763">    Kij[0][3] = 0;</span>
<span class="nc" id="L2764">    Kij[0][4] = 0;</span>
<span class="nc" id="L2765">    Kij[0][5] = 0;</span>
<span class="nc" id="L2766">    Kij[1][0] = 0;</span>
<span class="nc" id="L2767">    Kij[1][1] = 3 * E * Iz / Math.pow(Lij, 3);</span>
<span class="nc" id="L2768">    Kij[1][2] = 0;</span>
<span class="nc" id="L2769">    Kij[1][3] = 0;</span>
<span class="nc" id="L2770">    Kij[1][4] = 0;</span>
<span class="nc" id="L2771">    Kij[1][5] = 0;</span>
<span class="nc" id="L2772">    Kij[2][0] = 0;</span>
<span class="nc" id="L2773">    Kij[2][1] = 0;</span>
<span class="nc" id="L2774">    Kij[2][2] = -3 * E * Iy / Math.pow(Lij, 3);</span>
<span class="nc" id="L2775">    Kij[2][3] = 0;</span>
<span class="nc" id="L2776">    Kij[2][4] = 0;</span>
<span class="nc" id="L2777">    Kij[2][5] = 0;</span>
<span class="nc" id="L2778">    Kij[3][0] = 0;</span>
<span class="nc" id="L2779">    Kij[3][1] = 0;</span>
<span class="nc" id="L2780">    Kij[3][2] = 0;</span>
<span class="nc" id="L2781">    Kij[3][3] = 0;</span>
<span class="nc" id="L2782">    Kij[3][4] = 0;</span>
<span class="nc" id="L2783">    Kij[3][5] = 0;</span>
<span class="nc" id="L2784">    Kij[4][0] = 0;</span>
<span class="nc" id="L2785">    Kij[4][1] = 0;</span>
<span class="nc" id="L2786">    Kij[4][2] = -3 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2787">    Kij[4][3] = 0;</span>
<span class="nc" id="L2788">    Kij[4][4] = 0;</span>
<span class="nc" id="L2789">    Kij[4][5] = 0;</span>
<span class="nc" id="L2790">    Kij[5][0] = 0;</span>
<span class="nc" id="L2791">    Kij[5][1] = -3 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2792">    Kij[5][2] = 0;</span>
<span class="nc" id="L2793">    Kij[5][3] = 0;</span>
<span class="nc" id="L2794">    Kij[5][4] = 0;</span>
<span class="nc" id="L2795">    Kij[5][5] = 0;</span>

    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i
<span class="nc" id="L2798">    Kji[0][0] = E * S / Lij;</span>
<span class="nc" id="L2799">    Kji[0][1] = 0;</span>
<span class="nc" id="L2800">    Kji[0][2] = 0;</span>
<span class="nc" id="L2801">    Kji[0][3] = 0;</span>
<span class="nc" id="L2802">    Kji[0][4] = 0;</span>
<span class="nc" id="L2803">    Kji[0][5] = 0;</span>
<span class="nc" id="L2804">    Kji[1][0] = 0;</span>
<span class="nc" id="L2805">    Kji[1][1] = 3 * E * Iz / Math.pow(Lij, 3);</span>
<span class="nc" id="L2806">    Kji[1][2] = 0;</span>
<span class="nc" id="L2807">    Kji[1][3] = 0;</span>
<span class="nc" id="L2808">    Kji[1][4] = 0;</span>
<span class="nc" id="L2809">    Kji[1][5] = -3 * E * Iz / Math.pow(Lij, 2);</span>
<span class="nc" id="L2810">    Kji[2][0] = 0;</span>
<span class="nc" id="L2811">    Kji[2][1] = 0;</span>
<span class="nc" id="L2812">    Kji[2][2] = -3 * E * Iy / Math.pow(Lij, 3);</span>
<span class="nc" id="L2813">    Kji[2][3] = 0;</span>
<span class="nc" id="L2814">    Kji[2][4] = -3 * E * Iy / Math.pow(Lij, 2);</span>
<span class="nc" id="L2815">    Kji[2][5] = 0;</span>
<span class="nc" id="L2816">    Kji[3][0] = 0;</span>
<span class="nc" id="L2817">    Kji[3][1] = 0;</span>
<span class="nc" id="L2818">    Kji[3][2] = 0;</span>
<span class="nc" id="L2819">    Kji[3][3] = 0;</span>
<span class="nc" id="L2820">    Kji[3][4] = 0;</span>
<span class="nc" id="L2821">    Kji[3][5] = 0;</span>
<span class="nc" id="L2822">    Kji[4][0] = 0;</span>
<span class="nc" id="L2823">    Kji[4][1] = 0;</span>
<span class="nc" id="L2824">    Kji[4][2] = 0;</span>
<span class="nc" id="L2825">    Kji[4][3] = 0;</span>
<span class="nc" id="L2826">    Kji[4][4] = 0;</span>
<span class="nc" id="L2827">    Kji[4][5] = 0;</span>
<span class="nc" id="L2828">    Kji[5][0] = 0;</span>
<span class="nc" id="L2829">    Kji[5][1] = 0;</span>
<span class="nc" id="L2830">    Kji[5][2] = 0;</span>
<span class="nc" id="L2831">    Kji[5][3] = 0;</span>
<span class="nc" id="L2832">    Kji[5][4] = 0;</span>
<span class="nc" id="L2833">    Kji[5][5] = 0;</span>

<span class="nc" id="L2835">    Kjj[0][0] = E * S / Lij;</span>
<span class="nc" id="L2836">    Kjj[0][1] = 0;</span>
<span class="nc" id="L2837">    Kjj[0][2] = 0;</span>
<span class="nc" id="L2838">    Kjj[0][3] = 0;</span>
<span class="nc" id="L2839">    Kjj[0][4] = 0;</span>
<span class="nc" id="L2840">    Kjj[0][5] = 0;</span>
<span class="nc" id="L2841">    Kjj[1][0] = 0;</span>
<span class="nc" id="L2842">    Kjj[1][1] = 3 * E * Iz / Math.pow(Lij, 3);</span>
<span class="nc" id="L2843">    Kjj[1][2] = 0;</span>
<span class="nc" id="L2844">    Kjj[1][3] = 0;</span>
<span class="nc" id="L2845">    Kjj[1][4] = 0;</span>
<span class="nc" id="L2846">    Kjj[1][5] = 0;</span>
<span class="nc" id="L2847">    Kjj[2][0] = 0;</span>
<span class="nc" id="L2848">    Kjj[2][1] = 0;</span>
<span class="nc" id="L2849">    Kjj[2][2] = 3 * E * Iy / Math.pow(Lij, 3);</span>
<span class="nc" id="L2850">    Kjj[2][3] = 0;</span>
<span class="nc" id="L2851">    Kjj[2][4] = 0;</span>
<span class="nc" id="L2852">    Kjj[2][5] = 0;</span>
<span class="nc" id="L2853">    Kjj[3][0] = 0;</span>
<span class="nc" id="L2854">    Kjj[3][1] = 0;</span>
<span class="nc" id="L2855">    Kjj[3][2] = 0;</span>
<span class="nc" id="L2856">    Kjj[3][3] = 0;</span>
<span class="nc" id="L2857">    Kjj[3][4] = 0;</span>
<span class="nc" id="L2858">    Kjj[3][5] = 0;</span>
<span class="nc" id="L2859">    Kjj[4][0] = 0;</span>
<span class="nc" id="L2860">    Kjj[4][1] = 0;</span>
<span class="nc" id="L2861">    Kjj[4][2] = 0;</span>
<span class="nc" id="L2862">    Kjj[4][3] = 0;</span>
<span class="nc" id="L2863">    Kjj[4][4] = 0;</span>
<span class="nc" id="L2864">    Kjj[4][5] = 0;</span>
<span class="nc" id="L2865">    Kjj[5][0] = 0;</span>
<span class="nc" id="L2866">    Kjj[5][1] = 0;</span>
<span class="nc" id="L2867">    Kjj[5][2] = 0;</span>
<span class="nc" id="L2868">    Kjj[5][3] = 0;</span>
<span class="nc" id="L2869">    Kjj[5][4] = 0;</span>
<span class="nc" id="L2870">    Kjj[5][5] = 0;</span>

    // PrintArchTxtMKLB(e);

<span class="nc" id="L2874">  }</span>

  public void EBEsMat3DL_iArt_jArt(int e) throws JMetalException{
    // The element element 3D than form rigid matrix in the local coordinates
    // i: rigid
    // j: rigid
    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i + esfuerzo en i
    // double [][]Kii = new double [5][5];
    // Elements
    // the Element long
    // the Element long
<span class="nc" id="L2885">    double Lij=Element_[e][L_];</span>
    // index gropus
<span class="nc" id="L2887">    int idx = (int)Element_[e][INDEX_];</span>
    // Secction
<span class="nc" id="L2889">    double S=Groups_[idx][AREA];</span>
    // inertia in axis local z
    // elastic modulus (Young)
<span class="nc" id="L2892">    double E=Groups_[idx][E_];</span>
    //  elastic transversal modulus

    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i + esfuerzo en i
<span class="nc" id="L2896">    Kii[0][0] = E * S / Lij;</span>
<span class="nc" id="L2897">    Kii[0][1] = 0;</span>
<span class="nc" id="L2898">    Kii[0][2] = 0;</span>
<span class="nc" id="L2899">    Kii[0][3] = 0;</span>
<span class="nc" id="L2900">    Kii[0][4] = 0;</span>
<span class="nc" id="L2901">    Kii[0][5] = 0;</span>
<span class="nc" id="L2902">    Kii[1][0] = 0;</span>
<span class="nc" id="L2903">    Kii[1][1] = 0;</span>
<span class="nc" id="L2904">    Kii[1][2] = 0;</span>
<span class="nc" id="L2905">    Kii[1][3] = 0;</span>
<span class="nc" id="L2906">    Kii[1][4] = 0;</span>
<span class="nc" id="L2907">    Kii[1][5] = 0;</span>
<span class="nc" id="L2908">    Kii[2][0] = 0;</span>
<span class="nc" id="L2909">    Kii[2][1] = 0;</span>
<span class="nc" id="L2910">    Kii[2][2] = 0;</span>
<span class="nc" id="L2911">    Kii[2][3] = 0;</span>
<span class="nc" id="L2912">    Kii[2][4] = 0;</span>
<span class="nc" id="L2913">    Kii[2][5] = 0;</span>
<span class="nc" id="L2914">    Kii[3][0] = 0;</span>
<span class="nc" id="L2915">    Kii[3][1] = 0;</span>
<span class="nc" id="L2916">    Kii[3][2] = 0;</span>
<span class="nc" id="L2917">    Kii[3][3] = 0;</span>
<span class="nc" id="L2918">    Kii[3][4] = 0;</span>
<span class="nc" id="L2919">    Kii[3][5] = 0;</span>
<span class="nc" id="L2920">    Kii[4][0] = 0;</span>
<span class="nc" id="L2921">    Kii[4][1] = 0;</span>
<span class="nc" id="L2922">    Kii[4][2] = 0;</span>
<span class="nc" id="L2923">    Kii[4][3] = 0;</span>
<span class="nc" id="L2924">    Kii[4][4] = 0;</span>
<span class="nc" id="L2925">    Kii[4][5] = 0;</span>
<span class="nc" id="L2926">    Kii[5][0] = 0;</span>
<span class="nc" id="L2927">    Kii[5][1] = 0;</span>
<span class="nc" id="L2928">    Kii[5][2] = 0;</span>
<span class="nc" id="L2929">    Kii[5][3] = 0;</span>
<span class="nc" id="L2930">    Kii[5][4] = 0;</span>
<span class="nc" id="L2931">    Kii[5][5] = 0;</span>

    // esfuerzos en nudo i por reacciÃƒÂ³n de desplazamientos en j
<span class="nc" id="L2934">    Kij[0][0] = E * S / Lij;</span>
<span class="nc" id="L2935">    Kij[0][1] = 0;</span>
<span class="nc" id="L2936">    Kij[0][2] = 0;</span>
<span class="nc" id="L2937">    Kij[0][3] = 0;</span>
<span class="nc" id="L2938">    Kij[0][4] = 0;</span>
<span class="nc" id="L2939">    Kij[0][5] = 0;</span>
<span class="nc" id="L2940">    Kij[1][0] = 0;</span>
<span class="nc" id="L2941">    Kij[1][1] = 0;</span>
<span class="nc" id="L2942">    Kij[1][2] = 0;</span>
<span class="nc" id="L2943">    Kij[1][3] = 0;</span>
<span class="nc" id="L2944">    Kij[1][4] = 0;</span>
<span class="nc" id="L2945">    Kij[1][5] = 0;</span>
<span class="nc" id="L2946">    Kij[2][0] = 0;</span>
<span class="nc" id="L2947">    Kij[2][1] = 0;</span>
<span class="nc" id="L2948">    Kij[2][2] = 0;</span>
<span class="nc" id="L2949">    Kij[2][3] = 0;</span>
<span class="nc" id="L2950">    Kij[2][4] = 0;</span>
<span class="nc" id="L2951">    Kij[2][5] = 0;</span>
<span class="nc" id="L2952">    Kij[3][0] = 0;</span>
<span class="nc" id="L2953">    Kij[3][1] = 0;</span>
<span class="nc" id="L2954">    Kij[3][2] = 0;</span>
<span class="nc" id="L2955">    Kij[3][3] = 0;</span>
<span class="nc" id="L2956">    Kij[3][4] = 0;</span>
<span class="nc" id="L2957">    Kij[3][5] = 0;</span>
<span class="nc" id="L2958">    Kij[4][0] = 0;</span>
<span class="nc" id="L2959">    Kij[4][1] = 0;</span>
<span class="nc" id="L2960">    Kij[4][2] = 0;</span>
<span class="nc" id="L2961">    Kij[4][3] = 0;</span>
<span class="nc" id="L2962">    Kij[4][4] = 0;</span>
<span class="nc" id="L2963">    Kij[4][5] = 0;</span>
<span class="nc" id="L2964">    Kij[5][0] = 0;</span>
<span class="nc" id="L2965">    Kij[5][1] = 0;</span>
<span class="nc" id="L2966">    Kij[5][2] = 0;</span>
<span class="nc" id="L2967">    Kij[5][3] = 0;</span>
<span class="nc" id="L2968">    Kij[5][4] = 0;</span>
<span class="nc" id="L2969">    Kij[5][5] = 0;</span>

    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i
<span class="nc" id="L2972">    Kji[0][0] = E * S / Lij;</span>
<span class="nc" id="L2973">    Kji[0][1] = 0;</span>
<span class="nc" id="L2974">    Kji[0][2] = 0;</span>
<span class="nc" id="L2975">    Kji[0][3] = 0;</span>
<span class="nc" id="L2976">    Kji[0][4] = 0;</span>
<span class="nc" id="L2977">    Kji[0][5] = 0;</span>
<span class="nc" id="L2978">    Kji[1][0] = 0;</span>
<span class="nc" id="L2979">    Kji[1][1] = 0;</span>
<span class="nc" id="L2980">    Kji[1][2] = 0;</span>
<span class="nc" id="L2981">    Kji[1][3] = 0;</span>
<span class="nc" id="L2982">    Kji[1][4] = 0;</span>
<span class="nc" id="L2983">    Kji[1][5] = 0;</span>
<span class="nc" id="L2984">    Kji[2][0] = 0;</span>
<span class="nc" id="L2985">    Kji[2][1] = 0;</span>
<span class="nc" id="L2986">    Kji[2][2] = 0;</span>
<span class="nc" id="L2987">    Kji[2][3] = 0;</span>
<span class="nc" id="L2988">    Kji[2][4] = 0;</span>
<span class="nc" id="L2989">    Kji[2][5] = 0;</span>
<span class="nc" id="L2990">    Kji[3][0] = 0;</span>
<span class="nc" id="L2991">    Kji[3][1] = 0;</span>
<span class="nc" id="L2992">    Kji[3][2] = 0;</span>
<span class="nc" id="L2993">    Kji[3][3] = 0;</span>
<span class="nc" id="L2994">    Kji[3][4] = 0;</span>
<span class="nc" id="L2995">    Kji[3][5] = 0;</span>
<span class="nc" id="L2996">    Kji[4][0] = 0;</span>
<span class="nc" id="L2997">    Kji[4][1] = 0;</span>
<span class="nc" id="L2998">    Kji[4][2] = 0;</span>
<span class="nc" id="L2999">    Kji[4][3] = 0;</span>
<span class="nc" id="L3000">    Kji[4][4] = 0;</span>
<span class="nc" id="L3001">    Kji[4][5] = 0;</span>
<span class="nc" id="L3002">    Kji[5][0] = 0;</span>
<span class="nc" id="L3003">    Kji[5][1] = 0;</span>
<span class="nc" id="L3004">    Kji[5][2] = 0;</span>
<span class="nc" id="L3005">    Kji[5][3] = 0;</span>
<span class="nc" id="L3006">    Kji[5][4] = 0;</span>
<span class="nc" id="L3007">    Kji[5][5] = 0;</span>

    // esfuerzos en nudo i por reacciÃƒÂ³n de desplazamientos en j + esfuerzo en j
<span class="nc" id="L3010">    Kjj[0][0] = E * S / Lij;</span>
<span class="nc" id="L3011">    Kjj[0][1] = 0;</span>
<span class="nc" id="L3012">    Kjj[0][2] = 0;</span>
<span class="nc" id="L3013">    Kjj[0][3] = 0;</span>
<span class="nc" id="L3014">    Kjj[0][4] = 0;</span>
<span class="nc" id="L3015">    Kjj[0][5] = 0;</span>
<span class="nc" id="L3016">    Kjj[1][0] = 0;</span>
<span class="nc" id="L3017">    Kjj[1][1] = 0;</span>
<span class="nc" id="L3018">    Kjj[1][2] = 0;</span>
<span class="nc" id="L3019">    Kjj[1][3] = 0;</span>
<span class="nc" id="L3020">    Kjj[1][4] = 0;</span>
<span class="nc" id="L3021">    Kjj[1][5] = 0;</span>
<span class="nc" id="L3022">    Kjj[2][0] = 0;</span>
<span class="nc" id="L3023">    Kjj[2][1] = 0;</span>
<span class="nc" id="L3024">    Kjj[2][2] = 0;</span>
<span class="nc" id="L3025">    Kjj[2][3] = 0;</span>
<span class="nc" id="L3026">    Kjj[2][4] = 0;</span>
<span class="nc" id="L3027">    Kjj[2][5] = 0;</span>
<span class="nc" id="L3028">    Kjj[3][0] = 0;</span>
<span class="nc" id="L3029">    Kjj[3][1] = 0;</span>
<span class="nc" id="L3030">    Kjj[3][2] = 0;</span>
<span class="nc" id="L3031">    Kjj[3][3] = 0;</span>
<span class="nc" id="L3032">    Kjj[3][4] = 0;</span>
<span class="nc" id="L3033">    Kjj[3][5] = 0;</span>
<span class="nc" id="L3034">    Kjj[4][0] = 0;</span>
<span class="nc" id="L3035">    Kjj[4][1] = 0;</span>
<span class="nc" id="L3036">    Kjj[4][2] = 0;</span>
<span class="nc" id="L3037">    Kjj[4][3] = 0;</span>
<span class="nc" id="L3038">    Kjj[4][4] = 0;</span>
<span class="nc" id="L3039">    Kjj[4][5] = 0;</span>
<span class="nc" id="L3040">    Kjj[5][0] = 0;</span>
<span class="nc" id="L3041">    Kjj[5][1] = 0;</span>
<span class="nc" id="L3042">    Kjj[5][2] = 0;</span>
<span class="nc" id="L3043">    Kjj[5][3] = 0;</span>
<span class="nc" id="L3044">    Kjj[5][4] = 0;</span>
<span class="nc" id="L3045">    Kjj[5][5] = 0;</span>

    // PrintArchTxtMKLB(e);

<span class="nc" id="L3049">  }</span>

  public void EBEsMat3DL_SOG(int e) throws JMetalException{
    // The element element 3D than form rigid matrix in the local coordinates
    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i + esfuerzo en i
    // double [][]KiiSOG = new double [5][5];
    // Elements
    // the Element long
<span class="nc" id="L3057">    double l=Element_[e][L_];</span>
<span class="nc" id="L3058">    double Ni=AxialForcei_[e];</span>
<span class="nc" id="L3059">    double Nj=AxialForcej_[e];</span>

<span class="nc" id="L3061">    KiiSOG[0][0] = 0.0;</span>
<span class="nc" id="L3062">    KiiSOG[0][1] = 0.0;</span>
<span class="nc" id="L3063">    KiiSOG[0][2] = 0.0;</span>
<span class="nc" id="L3064">    KiiSOG[0][3] = 0.0;</span>
<span class="nc" id="L3065">    KiiSOG[0][4] = 0.0;</span>
<span class="nc" id="L3066">    KiiSOG[0][5] = 0.0;</span>
<span class="nc" id="L3067">    KiiSOG[1][0] = 0.0;</span>
<span class="nc" id="L3068">    KiiSOG[1][1] = Ni * 6.0 / (5.0 * l);</span>
<span class="nc" id="L3069">    KiiSOG[1][2] = 0.0;</span>
<span class="nc" id="L3070">    KiiSOG[1][3] = 0.0;</span>
<span class="nc" id="L3071">    KiiSOG[1][4] = 0.0;</span>
<span class="nc" id="L3072">    KiiSOG[1][5] = -Ni / 10.0;</span>
<span class="nc" id="L3073">    KiiSOG[2][0] = 0.0;</span>
<span class="nc" id="L3074">    KiiSOG[2][1] = 0.0;</span>
<span class="nc" id="L3075">    KiiSOG[2][2] = Ni * 6.0 / (5.0 * l);</span>
<span class="nc" id="L3076">    KiiSOG[2][3] = 0.0;</span>
<span class="nc" id="L3077">    KiiSOG[2][4] = Ni / 10.0;</span>
<span class="nc" id="L3078">    KiiSOG[2][5] = 0.0;</span>
<span class="nc" id="L3079">    KiiSOG[3][0] = 0.0;</span>
<span class="nc" id="L3080">    KiiSOG[3][1] = 0.0;</span>
<span class="nc" id="L3081">    KiiSOG[3][2] = 0.0;</span>
<span class="nc" id="L3082">    KiiSOG[3][3] = 0.0;</span>
<span class="nc" id="L3083">    KiiSOG[3][4] = 0.0;</span>
<span class="nc" id="L3084">    KiiSOG[3][5] = 0.0;</span>
<span class="nc" id="L3085">    KiiSOG[4][0] = 0.0;</span>
<span class="nc" id="L3086">    KiiSOG[4][1] = 0.0;</span>
<span class="nc" id="L3087">    KiiSOG[4][2] = Ni / 10.0;</span>
<span class="nc" id="L3088">    KiiSOG[4][3] = 0.0;</span>
<span class="nc" id="L3089">    KiiSOG[4][4] = Ni * 2.0 * l / 15.0;</span>
<span class="nc" id="L3090">    KiiSOG[4][5] = 0.0;</span>
<span class="nc" id="L3091">    KiiSOG[5][0] = 0.0;</span>
<span class="nc" id="L3092">    KiiSOG[5][1] = -Ni / 10.0;</span>
<span class="nc" id="L3093">    KiiSOG[5][2] = 0.0;</span>
<span class="nc" id="L3094">    KiiSOG[5][3] = 0.0;</span>
<span class="nc" id="L3095">    KiiSOG[5][4] = 0.0;</span>
<span class="nc" id="L3096">    KiiSOG[5][5] = Ni * 2.0 * l / 15.0;</span>

    // esfuerzos en nudo j por reacciÃƒÂ³n de desplazamientos en i + esfuerzo en i
<span class="nc" id="L3099">    KijSOG[0][0] = 0.0;</span>
<span class="nc" id="L3100">    KijSOG[0][1] = 0.0;</span>
<span class="nc" id="L3101">    KijSOG[0][2] = 0.0;</span>
<span class="nc" id="L3102">    KijSOG[0][3] = 0.0;</span>
<span class="nc" id="L3103">    KijSOG[0][4] = 0.0;</span>
<span class="nc" id="L3104">    KijSOG[0][5] = 0.0;</span>
<span class="nc" id="L3105">    KijSOG[1][0] = 0.0;</span>
<span class="nc" id="L3106">    KijSOG[1][1] = Ni * 6.0 / (5.0 * l);</span>
<span class="nc" id="L3107">    KijSOG[1][2] = 0.0;</span>
<span class="nc" id="L3108">    KijSOG[1][3] = 0.0;</span>
<span class="nc" id="L3109">    KijSOG[1][4] = 0.0;</span>
<span class="nc" id="L3110">    KijSOG[1][5] = -Ni / 10.0; // - original</span>
<span class="nc" id="L3111">    KijSOG[2][0] = 0.0;</span>
<span class="nc" id="L3112">    KijSOG[2][1] = 0.0;</span>
<span class="nc" id="L3113">    KijSOG[2][2] = -Ni * 6.0 / (5.0 * l);</span>
<span class="nc" id="L3114">    KijSOG[2][3] = 0.0;</span>
<span class="nc" id="L3115">    KijSOG[2][4] = -Ni / 10.0; // - original</span>
<span class="nc" id="L3116">    KijSOG[2][5] = 0.0;</span>
<span class="nc" id="L3117">    KijSOG[3][0] = 0.0;</span>
<span class="nc" id="L3118">    KijSOG[3][1] = 0.0;</span>
<span class="nc" id="L3119">    KijSOG[3][2] = 0.0;</span>
<span class="nc" id="L3120">    KijSOG[3][3] = 0.0;</span>
<span class="nc" id="L3121">    KijSOG[3][4] = 0.0;</span>
<span class="nc" id="L3122">    KijSOG[3][5] = 0.0;</span>
<span class="nc" id="L3123">    KijSOG[4][0] = 0.0;</span>
<span class="nc" id="L3124">    KijSOG[4][1] = 0.0;</span>
<span class="nc" id="L3125">    KijSOG[4][2] = -Ni / l;</span>
<span class="nc" id="L3126">    KijSOG[4][3] = 0.0;</span>
<span class="nc" id="L3127">    KijSOG[4][4] = Ni * l / 30.0; // - original</span>
<span class="nc" id="L3128">    KijSOG[4][5] = 0.0;</span>
<span class="nc" id="L3129">    KijSOG[5][0] = 0.0;</span>
<span class="nc" id="L3130">    KijSOG[5][1] = -Ni / 10.0;</span>
<span class="nc" id="L3131">    KijSOG[5][2] = 0.0;</span>
<span class="nc" id="L3132">    KijSOG[5][3] = 0.0;</span>
<span class="nc" id="L3133">    KijSOG[5][4] = 0.0;</span>
<span class="nc" id="L3134">    KijSOG[5][5] = -Ni * l / 30.0; // + original</span>

<span class="nc" id="L3136">    KjiSOG[0][0] = 0.0;</span>
<span class="nc" id="L3137">    KjiSOG[0][1] = 0.0;</span>
<span class="nc" id="L3138">    KjiSOG[0][2] = 0.0;</span>
<span class="nc" id="L3139">    KjiSOG[0][3] = 0.0;</span>
<span class="nc" id="L3140">    KjiSOG[0][4] = 0.0;</span>
<span class="nc" id="L3141">    KjiSOG[0][5] = 0.0;</span>
<span class="nc" id="L3142">    KjiSOG[1][0] = 0.0;</span>
<span class="nc" id="L3143">    KjiSOG[1][1] = Nj * 6.0 / (5.0 * l);</span>
<span class="nc" id="L3144">    KjiSOG[1][2] = 0.0;</span>
<span class="nc" id="L3145">    KjiSOG[1][3] = 0.0;</span>
<span class="nc" id="L3146">    KjiSOG[1][4] = 0.0;</span>
<span class="nc" id="L3147">    KjiSOG[1][5] = -Nj / 10.0;</span>
<span class="nc" id="L3148">    KjiSOG[2][0] = 0.0;</span>
<span class="nc" id="L3149">    KjiSOG[2][1] = 0.0;</span>
<span class="nc" id="L3150">    KjiSOG[2][2] = -Nj * 6.0 / (5.0 * l);</span>
<span class="nc" id="L3151">    KjiSOG[2][3] = 0.0;</span>
<span class="nc" id="L3152">    KjiSOG[2][4] = -Nj / 10.0;</span>
<span class="nc" id="L3153">    KjiSOG[2][5] = 0.0;</span>
<span class="nc" id="L3154">    KjiSOG[3][0] = 0.0;</span>
<span class="nc" id="L3155">    KjiSOG[3][1] = 0.0;</span>
<span class="nc" id="L3156">    KjiSOG[3][2] = 0.0;</span>
<span class="nc" id="L3157">    KjiSOG[3][3] = 0.0;</span>
<span class="nc" id="L3158">    KjiSOG[3][4] = 0.0;</span>
<span class="nc" id="L3159">    KjiSOG[3][5] = 0.0;</span>
<span class="nc" id="L3160">    KjiSOG[4][0] = 0.0;</span>
<span class="nc" id="L3161">    KjiSOG[4][1] = 0.0;</span>
<span class="nc" id="L3162">    KjiSOG[4][2] = -Nj / 10.0; // - original</span>
<span class="nc" id="L3163">    KjiSOG[4][3] = 0.0;</span>
<span class="nc" id="L3164">    KjiSOG[4][4] = Nj * l / 30.0; // - original</span>
<span class="nc" id="L3165">    KjiSOG[4][5] = 0.0;</span>
<span class="nc" id="L3166">    KjiSOG[5][0] = 0.0;</span>
<span class="nc" id="L3167">    KjiSOG[5][1] = -Nj / 10.0; // - original</span>
<span class="nc" id="L3168">    KjiSOG[5][2] = 0.0;</span>
<span class="nc" id="L3169">    KjiSOG[5][3] = 0.0;</span>
<span class="nc" id="L3170">    KjiSOG[5][4] = 0.0;</span>
<span class="nc" id="L3171">    KjiSOG[5][5] = -Nj * l / 30.0; // + origianl</span>

<span class="nc" id="L3173">    KjjSOG[0][0] = 0.0;</span>
<span class="nc" id="L3174">    KjjSOG[0][1] = 0.0;</span>
<span class="nc" id="L3175">    KjjSOG[0][2] = 0.0;</span>
<span class="nc" id="L3176">    KjjSOG[0][3] = 0.0;</span>
<span class="nc" id="L3177">    KjjSOG[0][4] = 0.0;</span>
<span class="nc" id="L3178">    KjjSOG[0][5] = 0.0;</span>
<span class="nc" id="L3179">    KjjSOG[1][0] = 0.0;</span>
<span class="nc" id="L3180">    KjjSOG[1][1] = Nj * 6.0 / (5.0 * l);</span>
<span class="nc" id="L3181">    KjjSOG[1][2] = 0.0;</span>
<span class="nc" id="L3182">    KjjSOG[1][3] = 0.0;</span>
<span class="nc" id="L3183">    KjjSOG[1][4] = 0.0;</span>
<span class="nc" id="L3184">    KjjSOG[1][5] = -Nj / 10.0;</span>
<span class="nc" id="L3185">    KjjSOG[2][0] = 0.0;</span>
<span class="nc" id="L3186">    KjjSOG[2][1] = 0.0;</span>
<span class="nc" id="L3187">    KjjSOG[2][2] = Nj * 6.0 / (5.0 * l);</span>
<span class="nc" id="L3188">    KjjSOG[2][3] = 0.0;</span>
<span class="nc" id="L3189">    KjjSOG[2][4] = Nj / 10.0;</span>
<span class="nc" id="L3190">    KjjSOG[2][5] = 0.0;</span>
<span class="nc" id="L3191">    KjjSOG[3][0] = 0.0;</span>
<span class="nc" id="L3192">    KjjSOG[3][1] = 0.0;</span>
<span class="nc" id="L3193">    KjjSOG[3][2] = 0.0;</span>
<span class="nc" id="L3194">    KjjSOG[3][3] = 0.0;</span>
<span class="nc" id="L3195">    KjjSOG[3][4] = 0.0;</span>
<span class="nc" id="L3196">    KjjSOG[3][5] = 0.0;</span>
<span class="nc" id="L3197">    KjjSOG[4][0] = 0.0;</span>
<span class="nc" id="L3198">    KjjSOG[4][1] = 0.0;</span>
<span class="nc" id="L3199">    KjjSOG[4][2] = Nj / 10.0;</span>
<span class="nc" id="L3200">    KjjSOG[4][3] = 0.0;</span>
<span class="nc" id="L3201">    KjjSOG[4][4] = Nj * 2.0 * l / 15.0;</span>
<span class="nc" id="L3202">    KjjSOG[4][5] = 0.0;</span>
<span class="nc" id="L3203">    KjjSOG[5][0] = 0.0;</span>
<span class="nc" id="L3204">    KjjSOG[5][1] = -Nj / 10.0;</span>
<span class="nc" id="L3205">    KjjSOG[5][2] = 0.0;</span>
<span class="nc" id="L3206">    KjjSOG[5][3] = 0.0;</span>
<span class="nc" id="L3207">    KjjSOG[5][4] = 0.0;</span>
<span class="nc" id="L3208">    KjjSOG[5][5] = Nj * 2.0 * l / 15.0;</span>

    // PrintArchTxtMKLB(e);
<span class="nc" id="L3211">  }</span>


  public void EBEsMatRot3DLaG(int e) throws JMetalException{
    // matriz de rotaciÃƒÂ³n 3D de desplazamientos de ejes Locales a Generales
    int i, j;
    // cosenos directores de x local respecto al sistema global
    double lx; // cosenos directo respecto del eje local x (coincidente con el eje de la barra) y el eje X Global
    double mx; // cosenos directo respecto del eje local x (coincidente con el eje de la barra) y el eje Y Global
    double nx; //cosenos directo respecto del eje local x (coincidente con el eje de la barra) y el eje Z Global
    //cosenos directores de y local respecto al sistema global
    double D;
    double ly; // cosenos directo respecto del eje local y (coincidente con el eje de la barra) y el eje X Global
    double my; // Single 'cosenos directo respecto del eje local y (coincidente con el eje de la barra) y el eje Y Global
    double ny; // cosenos directo respecto del eje local y (coincidente con el eje de la barra) y el eje Z Global
    // cosenos directores de z local respecto al sistema global
    double lz; // cosenos directo respecto del eje local z (coincidente con el eje de la barra) y el eje X Global
    double mz; // cosenos directo respecto del eje local z (coincidente con el eje de la barra) y el eje Y Global
    double nz; //cosenos directo respecto del eje local z (coincidente con el eje de la barra) y el eje Z Global
    int sgn;

    // cosenos directores de x local respecto al sistema global XYZ
<span class="nc" id="L3233">    int ni=(int)Element_[e][i_];</span>
<span class="nc" id="L3234">    int nj=(int)Element_[e][j_];</span>
<span class="nc" id="L3235">    lx = (Node_[ni][aX_]-Node_[nj][aX_])/Element_[e][L_];</span>
<span class="nc" id="L3236">    mx = (Node_[ni][aY_]-Node_[nj][aY_])/Element_[e][L_];</span>
<span class="nc" id="L3237">    nx = (Node_[ni][aZ_]-Node_[nj][aZ_])/Element_[e][L_];</span>
<span class="nc" id="L3238">    D = Math.sqrt(Math.pow(lx, 2.0) + Math.pow(mx, 2.0));</span>
<span class="nc bnc" id="L3239" title="All 4 branches missed.">    if(lx == 0 &amp;&amp; mx == 0){</span>
      // indeterminaciÃƒÂ³n por ser la barra con eje local x // al eje global z
      // cosenos directores de x local respecto al sistema global XYZ
<span class="nc" id="L3242">      sgn=(int)Math.signum(Node_[ni][aZ_]-Node_[nj][aZ_]);</span>
<span class="nc" id="L3243">      lx = 0;</span>
<span class="nc" id="L3244">      mx = 0;</span>
<span class="nc" id="L3245">      nx = sgn;</span>
      //cosenos directores de y local respecto al sistema global XYZ
<span class="nc" id="L3247">      ly = 0;</span>
<span class="nc" id="L3248">      my = sgn;</span>
<span class="nc" id="L3249">      ny = 0;</span>
      // cosenos directores de z local respecto al sistema global XYZ
<span class="nc" id="L3251">      lz = -1;</span>
<span class="nc" id="L3252">      mz = 0;</span>
<span class="nc" id="L3253">      nz = 0;</span>
<span class="nc" id="L3254">      D = 0;</span>
    }
    else{
      // la barra con eje local x no es // al eje global z
      // cosenos directores de y local respecto al sistema global XYZ
<span class="nc" id="L3259">      ly = -mx/D;</span>
<span class="nc" id="L3260">      my = lx/D;</span>
<span class="nc" id="L3261">      ny = 0;</span>
      // cosenos directores de z local respecto al sistema global XYZ
<span class="nc" id="L3263">      lz = -lx*nx/D;</span>
<span class="nc" id="L3264">      mz = -mx*nx/D;</span>
<span class="nc" id="L3265">      nz = D;</span>
    }

    // matriz de rotaciÃƒÂ³n de desplazamientos locales a ejes globales XYZ si los ejes principales de la
    // secciÃƒÂ³n &quot;yp,zp&quot; coinciden con los ejes locales &quot;y,z&quot; de la barra
    // para el nudo i de la barra ij
<span class="nc" id="L3271">    Rij[0][0]=lx; Rij[0][1]=mx; Rij[0][2]=nx;</span>
<span class="nc" id="L3272">    Rij[1][0]=ly; Rij[1][1]=my; Rij[1][2]=ny;</span>
<span class="nc" id="L3273">    Rij[2][0]=lz; Rij[2][1]=mz; Rij[2][2]=nz;</span>
<span class="nc bnc" id="L3274" title="All 2 branches missed.">    for(i=0; i&lt;3; i++){</span>
<span class="nc bnc" id="L3275" title="All 2 branches missed.">      for(j=3; j&lt;6; j++){</span>
<span class="nc" id="L3276">        Rij[i][j]=0.0;</span>
      } // next j
    } //next i
<span class="nc bnc" id="L3279" title="All 2 branches missed.">    for(i=3; i&lt;6; i++){</span>
<span class="nc bnc" id="L3280" title="All 2 branches missed.">      for(j=0; j&lt;3; j++){</span>
<span class="nc" id="L3281">        Rij[i][j]=0.0;</span>
      } // next j
    } //next i
<span class="nc" id="L3284">    Rij[3][3] = lx; Rij[3][4] = mx; Rij[3][5] = nx;</span>
<span class="nc" id="L3285">    Rij[4][3] = ly; Rij[4][4] = my; Rij[4][5] = ny;</span>
<span class="nc" id="L3286">    Rij[5][3] = lz; Rij[5][4] = mz; Rij[5][5] = nz;</span>

    // trasponer la matriz de rotaciÃƒÂ³n
<span class="nc" id="L3289">    RTij = EBEsMatrizTraspuesta(Rij);</span>

    // matriz de rotaciÃƒÂ³n de desplazamientos locales a ejes globales XYZ si los ejes principales de la
    // secciÃƒÂ³n &quot;yp,zp&quot; coinciden con los ejes locales &quot;y,z&quot; de la barra
    // para el nudo j de la barra ij
<span class="nc" id="L3294">    Rji[0][0]=-lx; Rji[0][1]=-mx; Rji[0][2]=-nx;</span>
<span class="nc" id="L3295">    Rji[1][0]=-ly; Rji[1][1]=-my; Rji[1][2]= ny;</span>
<span class="nc" id="L3296">    Rji[2][0]= lz; Rji[2][1]= mz; Rji[2][2]= nz;</span>
<span class="nc bnc" id="L3297" title="All 2 branches missed.">    for(i=0; i&lt;3; i++){</span>
<span class="nc bnc" id="L3298" title="All 2 branches missed.">      for(j=3; j&lt;6; j++){</span>
<span class="nc" id="L3299">        Rji[i][j]=0.0;</span>
      } // next j
    } //next i
<span class="nc bnc" id="L3302" title="All 2 branches missed.">    for(i=3; i&lt;6; i++){</span>
<span class="nc bnc" id="L3303" title="All 2 branches missed.">      for(j=0; j&lt;3; j++){</span>
<span class="nc" id="L3304">        Rji[i][j]=0.0;</span>
      } // next j
    } //next i
<span class="nc" id="L3307">    Rji[3][3]=-lx; Rji[3][4]=-mx; Rji[3][5]=-nx;</span>
<span class="nc" id="L3308">    Rji[4][3]=-ly; Rji[4][4]=-my; Rji[4][5]= ny;</span>
<span class="nc" id="L3309">    Rji[5][3]= lz; Rji[5][4]= mz; Rji[5][5]= nz;</span>

    // trasponer la matriz de rotaciÃƒÂ³n
<span class="nc" id="L3312">    RTji=EBEsMatrizTraspuesta(Rji);</span>

<span class="nc" id="L3314">  }</span>

  public void EBEsMat3DGij() throws JMetalException{
    // CONSTRUYE LA MATRIZ DE RIGIDEZ DE UNA BARRA EN COORDENADAS GLOBALES

<span class="nc" id="L3319">    double [][]r=new double[numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L3320">    double [][]s=new double[numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L3321">    double [][]t=new double[numberOfLibertyDegree_][numberOfLibertyDegree_];</span>

    // para el extremo ii
    // KGii = RTij * RpTij * KjjSOGSOGSOG * Rpij * Rij
<span class="nc" id="L3325">    r=EBEsMatrizMultiplicar(Rpij, Rij);</span>
<span class="nc" id="L3326">    s=EBEsMatrizMultiplicar(Kii, r);</span>
<span class="nc" id="L3327">    t=EBEsMatrizMultiplicar(RpTij, s);</span>
<span class="nc" id="L3328">    KGii=EBEsMatrizMultiplicar(RTij, t);</span>

    // para el extremo ij
    // KGij = RTij * RpTij * Kij * Rpji * Rji
<span class="nc" id="L3332">    r=EBEsMatrizMultiplicar(Rpji, Rji);</span>
<span class="nc" id="L3333">    s=EBEsMatrizMultiplicar(Kij, r);</span>
<span class="nc" id="L3334">    t=EBEsMatrizMultiplicar(RpTij, s);</span>
<span class="nc" id="L3335">    KGij=EBEsMatrizMultiplicar(RTij, t);</span>

    // para el extremo ji
    // KGji = RTji * RpTji * Kji * Rpij * Rij
<span class="nc" id="L3339">    r=EBEsMatrizMultiplicar(Rpij, Rij);</span>
<span class="nc" id="L3340">    s=EBEsMatrizMultiplicar(Kji, r);</span>
<span class="nc" id="L3341">    t=EBEsMatrizMultiplicar(RpTji, s);</span>
<span class="nc" id="L3342">    KGji=EBEsMatrizMultiplicar(RTji, t);</span>

    // para el extremo jj
    // KGjj = RTji * RpTji * Kjj* Rpji * Rji
<span class="nc" id="L3346">    r=EBEsMatrizMultiplicar(Rpji, Rji);</span>
<span class="nc" id="L3347">    s=EBEsMatrizMultiplicar(Kjj, r);</span>
<span class="nc" id="L3348">    t=EBEsMatrizMultiplicar(RpTji, s);</span>
<span class="nc" id="L3349">    KGjj=EBEsMatrizMultiplicar(RTji, t);</span>

<span class="nc" id="L3351">  } // end module</span>

  public void EBEsMat3DG(int e)throws JMetalException{

    // ELEMENTO DE BARRA 3D QUE FORMA LA MATRIZ DE RIGIDEZ EN COORDENADAS GLOBALES
    // i: rÃƒÂ­gido
    // j: rÃƒÂ­gido
    int ni, nj;
    int p;
    int p1;
    int p2;
    int p3;
    int p4;
    int p5;
    int p6;
    int r;
    int r1;
    int r2;
    int r3;
    int r4;
    int r5;
    int r6;

    // ELEMENTOS DE LA MATRIZ QUE CORRESPONDEN AL ELEMENTO i
<span class="nc" id="L3375">    ni=(int)Element_[e][i_];</span>
<span class="nc" id="L3376">    nj=(int)Element_[e][j_];</span>
<span class="nc" id="L3377">    p = numberOfLibertyDegree_ * ni;</span>
<span class="nc" id="L3378">    r = numberOfLibertyDegree_ * nj;</span>
<span class="nc" id="L3379">    p1 = matrixWidthBand_ * p;</span>
<span class="nc" id="L3380">    p2 = matrixWidthBand_ * (p + 1);</span>
<span class="nc" id="L3381">    p3 = matrixWidthBand_ * (p + 2);</span>
<span class="nc" id="L3382">    p4 = matrixWidthBand_ * (p + 3);</span>
<span class="nc" id="L3383">    p5 = matrixWidthBand_ * (p + 4);</span>
<span class="nc" id="L3384">    p6 = matrixWidthBand_ * (p + 5);</span>
    // ELEMENTOS DE LA MATRIZ QUE QUE CORRESPONDEN AL ELEMENTO j
<span class="nc" id="L3386">    r1 = matrixWidthBand_ * r;</span>
<span class="nc" id="L3387">    r2 = matrixWidthBand_ * (r + 1);</span>
<span class="nc" id="L3388">    r3 = matrixWidthBand_ * (r + 2);</span>
<span class="nc" id="L3389">    r4 = matrixWidthBand_ * (r + 3);</span>
<span class="nc" id="L3390">    r5 = matrixWidthBand_ * (r + 4);</span>
<span class="nc" id="L3391">    r6 = matrixWidthBand_ * (r + 5);</span>

    // ELEMENTOS DE LA MATRIZ QUE CORRESPONDEN AL EXTREMO j
    // 0Ã‚Â° fila
<span class="nc" id="L3395">    MatrixStiffness_[p1] = MatrixStiffness_[p1] + KGii[0][0]; // 0</span>
<span class="nc" id="L3396">    MatrixStiffness_[p1 + 1] = MatrixStiffness_[p1 + 1] + KGii[0][1]; // 1</span>
<span class="nc" id="L3397">    MatrixStiffness_[p1 + 2] = MatrixStiffness_[p1 + 2] + KGii[0][2]; // 2</span>
<span class="nc" id="L3398">    MatrixStiffness_[p1 + 3] = MatrixStiffness_[p1 + 3] + KGii[0][3]; // 3</span>
<span class="nc" id="L3399">    MatrixStiffness_[p1 + 4] = MatrixStiffness_[p1 + 4] + KGii[0][4]; // 4</span>
<span class="nc" id="L3400">    MatrixStiffness_[p1 + 5] = MatrixStiffness_[p1 + 5] + KGii[0][5]; // 5</span>
<span class="nc" id="L3401">    MatrixStiffness_[p1 + r - p] = KGij[0][0]; // 6</span>
<span class="nc" id="L3402">    MatrixStiffness_[p1 + 1 + r - p] = KGij[0][1]; // 7</span>
<span class="nc" id="L3403">    MatrixStiffness_[p1 + 2 + r - p] = KGij[0][2]; // 8</span>
<span class="nc" id="L3404">    MatrixStiffness_[p1 + 3 + r - p] = KGij[0][3]; // 9</span>
<span class="nc" id="L3405">    MatrixStiffness_[p1 + 4 + r - p] = KGij[0][4]; // 10</span>
<span class="nc" id="L3406">    MatrixStiffness_[p1 + 5 + r - p] = KGij[0][5]; // 11</span>
    // 1Ã‚Â° fila
<span class="nc" id="L3408">    MatrixStiffness_[p2] = MatrixStiffness_[p2] + KGii[1][1]; // 12</span>
<span class="nc" id="L3409">    MatrixStiffness_[p2 + 1] = MatrixStiffness_[p2 + 1] + KGii[1][2]; // 13</span>
<span class="nc" id="L3410">    MatrixStiffness_[p2 + 2] = MatrixStiffness_[p2 + 2] + KGii[1][3]; // 14</span>
<span class="nc" id="L3411">    MatrixStiffness_[p2 + 3] = MatrixStiffness_[p2 + 3] + KGii[1][4]; // 15</span>
<span class="nc" id="L3412">    MatrixStiffness_[p2 + 4] = MatrixStiffness_[p2 + 4] + KGii[1][5]; // 16</span>
<span class="nc" id="L3413">    MatrixStiffness_[p2 + r - p - 1] = KGij[1][0]; // 17</span>
<span class="nc" id="L3414">    MatrixStiffness_[p2 + r - p] = KGij[1][1]; // 18</span>
<span class="nc" id="L3415">    MatrixStiffness_[p2 + r - p + 1] = KGij[1][2]; // 19</span>
<span class="nc" id="L3416">    MatrixStiffness_[p2 + r - p + 2] = KGij[1][3]; // 20</span>
<span class="nc" id="L3417">    MatrixStiffness_[p2 + r - p + 3] = KGij[1][4]; // 21</span>
<span class="nc" id="L3418">    MatrixStiffness_[p2 + r - p + 4] = KGij[1][5]; // 22</span>
    // 2Ã‚Â° fila
<span class="nc" id="L3420">    MatrixStiffness_[p3] = MatrixStiffness_[p3] + KGii[2][2]; // 24</span>
<span class="nc" id="L3421">    MatrixStiffness_[p3 + 1] = MatrixStiffness_[p3 + 1] + KGii[2][3]; // 25</span>
<span class="nc" id="L3422">    MatrixStiffness_[p3 + 2] = MatrixStiffness_[p3 + 2] + KGii[2][4]; // 26</span>
<span class="nc" id="L3423">    MatrixStiffness_[p3 + 3] = MatrixStiffness_[p3 + 3] + KGii[2][5]; // 27</span>
<span class="nc" id="L3424">    MatrixStiffness_[p3 + r - p - 2] = KGij[2][0]; // 28</span>
<span class="nc" id="L3425">    MatrixStiffness_[p3 + r - p - 1] = KGij[2][1]; // 29</span>
<span class="nc" id="L3426">    MatrixStiffness_[p3 + r - p] = KGij[2][2]; // 30</span>
<span class="nc" id="L3427">    MatrixStiffness_[p3 + r - p + 1] = KGij[2][3]; // 31</span>
<span class="nc" id="L3428">    MatrixStiffness_[p3 + r - p + 2] = KGij[2][4]; // 32</span>
<span class="nc" id="L3429">    MatrixStiffness_[p3 + r - p + 3] = KGij[2][5]; // 33</span>
    // 3Ã‚Â° fila
<span class="nc" id="L3431">    MatrixStiffness_[p4] = MatrixStiffness_[p4] + KGii[3][3]; // 36</span>
<span class="nc" id="L3432">    MatrixStiffness_[p4 + 1] = MatrixStiffness_[p4 + 1] + KGii[3][4]; // 37</span>
<span class="nc" id="L3433">    MatrixStiffness_[p4 + 2] = MatrixStiffness_[p4 + 2] + KGii[3][5]; // 38</span>
<span class="nc" id="L3434">    MatrixStiffness_[p4 + r - p - 3] = KGij[3][0]; // 39</span>
<span class="nc" id="L3435">    MatrixStiffness_[p4 + r - p - 2] = KGij[3][1]; // 40</span>
<span class="nc" id="L3436">    MatrixStiffness_[p4 + r - p - 1] = KGij[3][2]; // 41</span>
<span class="nc" id="L3437">    MatrixStiffness_[p4 + r - p] = KGij[3][3]; // 42</span>
<span class="nc" id="L3438">    MatrixStiffness_[p4 + r - p + 1] = KGij[3][4]; // 43</span>
<span class="nc" id="L3439">    MatrixStiffness_[p4 + r - p + 2] = KGij[3][5]; // 44</span>
    // 4Ã‚Â° fila
<span class="nc" id="L3441">    MatrixStiffness_[p5] = MatrixStiffness_[p5] + KGii[4][4]; // 48</span>
<span class="nc" id="L3442">    MatrixStiffness_[p5 + 1] = MatrixStiffness_[p5 + 1] + KGii[4][5]; //49</span>
<span class="nc" id="L3443">    MatrixStiffness_[p5 + r - p - 4] = KGij[4][0]; // 50</span>
<span class="nc" id="L3444">    MatrixStiffness_[p5 + r - p - 3] = KGij[4][1]; // 51</span>
<span class="nc" id="L3445">    MatrixStiffness_[p5 + r - p - 2] = KGij[4][2]; // 52</span>
<span class="nc" id="L3446">    MatrixStiffness_[p5 + r - p - 1] = KGij[4][3]; // 53</span>
<span class="nc" id="L3447">    MatrixStiffness_[p5 + r - p] = KGij[4][4]; // 54</span>
<span class="nc" id="L3448">    MatrixStiffness_[p5 + r - p + 1] = KGij[4][5]; // 55</span>
    // 5Ã‚Â° fila
<span class="nc" id="L3450">    MatrixStiffness_[p6] = MatrixStiffness_[p6] + KGii[5][5]; // 60</span>
<span class="nc" id="L3451">    MatrixStiffness_[p6 + r - p - 5] = KGij[5][0]; // 61</span>
<span class="nc" id="L3452">    MatrixStiffness_[p6 + r - p - 4] = KGij[5][1]; // 62</span>
<span class="nc" id="L3453">    MatrixStiffness_[p6 + r - p - 3] = KGij[5][2]; // 63</span>
<span class="nc" id="L3454">    MatrixStiffness_[p6 + r - p - 2] = KGij[5][3]; // 64</span>
<span class="nc" id="L3455">    MatrixStiffness_[p6 + r - p - 1] = KGij[5][4]; // 65</span>
<span class="nc" id="L3456">    MatrixStiffness_[p6 + r - p] = KGij[5][5]; // 66</span>
    // ELEMENTOS DE LA MATRIZ QUE CORRESPONDEN AL EXTREMO i
    // 6Ã‚Â° fila
<span class="nc" id="L3459">    MatrixStiffness_[r1] = MatrixStiffness_[r1] + KGjj[0][0]; // 72</span>
<span class="nc" id="L3460">    MatrixStiffness_[r1 + 1] = MatrixStiffness_[r1 + 1] + KGjj[0][1]; // 73</span>
<span class="nc" id="L3461">    MatrixStiffness_[r1 + 2] = MatrixStiffness_[r1 + 2] + KGjj[0][2]; // 74</span>
<span class="nc" id="L3462">    MatrixStiffness_[r1 + 3] = MatrixStiffness_[r1 + 3] + KGjj[0][3]; // 75</span>
<span class="nc" id="L3463">    MatrixStiffness_[r1 + 4] = MatrixStiffness_[r1 + 4] + KGjj[0][4]; // 76</span>
<span class="nc" id="L3464">    MatrixStiffness_[r1 + 5] = MatrixStiffness_[r1 + 5] + KGjj[0][5]; // 77</span>
    // 7Ã‚Â° fila
<span class="nc" id="L3466">    MatrixStiffness_[r2] = MatrixStiffness_[r2] + KGjj[1][1]; // 84</span>
<span class="nc" id="L3467">    MatrixStiffness_[r2 + 1] = MatrixStiffness_[r2 + 1] + KGjj[1][2]; // 85</span>
<span class="nc" id="L3468">    MatrixStiffness_[r2 + 2] = MatrixStiffness_[r2 + 2] + KGjj[1][3]; // 86</span>
<span class="nc" id="L3469">    MatrixStiffness_[r2 + 3] = MatrixStiffness_[r2 + 3] + KGjj[1][4]; // 87</span>
<span class="nc" id="L3470">    MatrixStiffness_[r2 + 4] = MatrixStiffness_[r2 + 4] + KGjj[1][5]; // 88</span>
    // 8Ã‚Â° fila
<span class="nc" id="L3472">    MatrixStiffness_[r3] = MatrixStiffness_[r3] + KGjj[2][2]; // 96</span>
<span class="nc" id="L3473">    MatrixStiffness_[r3 + 1] = MatrixStiffness_[r3 + 1] + KGjj[2][3]; // 97</span>
<span class="nc" id="L3474">    MatrixStiffness_[r3 + 2] = MatrixStiffness_[r3 + 2] + KGjj[2][4]; // 98</span>
<span class="nc" id="L3475">    MatrixStiffness_[r3 + 3] = MatrixStiffness_[r3 + 3] + KGjj[2][5]; // 99</span>
    // 9Ã‚Â° fila
<span class="nc" id="L3477">    MatrixStiffness_[r4] = MatrixStiffness_[r4] + KGjj[3][3]; // 108</span>
<span class="nc" id="L3478">    MatrixStiffness_[r4 + 1] = MatrixStiffness_[r4 + 1] + KGjj[3][4]; // 109</span>
<span class="nc" id="L3479">    MatrixStiffness_[r4 + 2] = MatrixStiffness_[r4 + 2] + KGjj[3][5]; // 110</span>
    // 10Ã‚Â° fila
<span class="nc" id="L3481">    MatrixStiffness_[r5] = MatrixStiffness_[r5] + KGjj[4][4]; // 120</span>
<span class="nc" id="L3482">    MatrixStiffness_[r5 + 1] = MatrixStiffness_[r5 + 1] + KGjj[4][5]; // 121</span>
    // 11Ã‚Â° fila
<span class="nc" id="L3484">    MatrixStiffness_[r6] = MatrixStiffness_[r6] + KGjj[5][5]; // 132</span>

<span class="nc" id="L3486">  }</span>

  public double []EBEsMatrizVectorMultiplicar(double [][]s, double[]t) throws JMetalException{

    int f, c;
<span class="nc" id="L3491">    double []r = new double [t.length];</span>

<span class="nc bnc" id="L3493" title="All 2 branches missed.">    for(f =0; f&lt;s.length; f++){ // cantidad de elementos de la 1ra dimensiÃƒÂ³n</span>
<span class="nc" id="L3494">      r[f] = 0;</span>
<span class="nc bnc" id="L3495" title="All 2 branches missed.">      for(c=0; c&lt;t.length; c++){ // cantidad de elementos de la 2ra dimensiÃƒÂ³n</span>
<span class="nc" id="L3496">        r[f] = r[f] + s[f][c] * t[c];</span>
      } // next c
    }// next f

<span class="nc" id="L3500">    return r;</span>

  } // end module

  public double [][]EBEsMatrizMultiplicar(double [][]s, double[][]t) throws JMetalException{

    int f, c, q;
<span class="nc" id="L3507">    double [][]r = new double [s.length][t[0].length];</span>

<span class="nc bnc" id="L3509" title="All 2 branches missed.">    for(f=0; f&lt;s.length; f++){ // cantidad de elementos de la 1ra dimensiÃƒÂ³n</span>
<span class="nc bnc" id="L3510" title="All 2 branches missed.">      for(c=0; c&lt;s[f].length; c++){ //cantidad de elementos de la 2ra dimensiÃƒÂ³n</span>
<span class="nc" id="L3511">        r[f][c]=0;</span>
<span class="nc bnc" id="L3512" title="All 2 branches missed.">        for(q=0; q&lt;s[f].length; q++){ //cantidad de elementos de la 2ra dimensiÃƒÂ³n</span>
<span class="nc" id="L3513">          r[f][c] = r[f][c] + s[f][q] * t[q][c];</span>
        } // Next q
      } // Next c
    } // Next f

<span class="nc" id="L3518">    return r;</span>

  } // end module

  public double [][]EBEsMatrixAdd(double [][]s, double[][]t) throws JMetalException{

<span class="nc" id="L3524">    double [][]r = new double [s.length][t[0].length];</span>

<span class="nc bnc" id="L3526" title="All 2 branches missed.">    for(int f=0; f&lt;s.length; f++){ // cantidad de elementos de la 1ra dimensiÃƒÂ³n</span>
<span class="nc bnc" id="L3527" title="All 2 branches missed.">      for(int c=0; c&lt;t.length; c++){ //cantidad de elementos de la 2ra dimensiÃƒÂ³n</span>
<span class="nc" id="L3528">        r[f][c] = s[f][c] + t[f][c];</span>
      } // Next c
    } // Next f

<span class="nc" id="L3532">    return r;</span>

  } // end module

  public double [][]EBEsMatrixSubtractions(double [][]s, double[][]t) throws JMetalException{

<span class="nc" id="L3538">    double [][]r = new double [s.length][t[0].length];</span>

<span class="nc bnc" id="L3540" title="All 2 branches missed.">    for(int f=0; f&lt;s.length; f++){ // cantidad de elementos de la 1ra dimensiÃƒÂ³n</span>
<span class="nc bnc" id="L3541" title="All 2 branches missed.">      for(int c=0; c&lt;t.length; c++){ //cantidad de elementos de la 2ra dimensiÃƒÂ³n</span>
<span class="nc" id="L3542">        r[f][c] = s[f][c] - t[f][c];</span>
      } // Next c
    } // Next f

<span class="nc" id="L3546">    return r;</span>

  } // end module

  public void EBEsNodesEquilibrium3D(int hi) throws JMetalException{

<span class="nc bnc" id="L3552" title="All 2 branches missed.">    for(int ba=0; ba&lt;Element_.length;ba++){</span>

<span class="nc" id="L3554">      double[][] ri = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L3555">      double[][] rj = new double [numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L3556">      double[] ei = new double [numberOfLibertyDegree_];</span>
<span class="nc" id="L3557">      double[] ej = new double [numberOfLibertyDegree_];</span>
<span class="nc" id="L3558">      double[] egi = new double [numberOfLibertyDegree_];</span>
<span class="nc" id="L3559">      double[] egj = new double [numberOfLibertyDegree_];</span>

      //carga en barra
      // i inode
<span class="nc" id="L3563">      ei[aX_] = Efforti_[aX_][ba][hi];</span>
<span class="nc" id="L3564">      ei[aY_] = Efforti_[aY_][ba][hi];</span>
<span class="nc" id="L3565">      ei[aZ_] = Efforti_[aZ_][ba][hi];</span>
<span class="nc" id="L3566">      ei[gX_] = Efforti_[gX_][ba][hi];</span>
<span class="nc" id="L3567">      ei[gY_] = Efforti_[gY_][ba][hi];</span>
<span class="nc" id="L3568">      ei[gZ_] = Efforti_[gZ_][ba][hi];</span>
      // j node
<span class="nc" id="L3570">      ej[aX_] = Effortj_[aX_][ba][hi];</span>
<span class="nc" id="L3571">      ej[aY_] = Effortj_[aY_][ba][hi];</span>
<span class="nc" id="L3572">      ej[aZ_] = Effortj_[aZ_][ba][hi];</span>
<span class="nc" id="L3573">      ej[gX_] = Effortj_[gX_][ba][hi];</span>
<span class="nc" id="L3574">      ej[gY_] = Effortj_[gY_][ba][hi];</span>
<span class="nc" id="L3575">      ej[gZ_] = Effortj_[gZ_][ba][hi];</span>

      //ProyecciÃƒÂ³n de los esfuerzos de barras sobre los ejes generales
      //en el nudo i
<span class="nc" id="L3579">      ri = EBEsMatrizMultiplicar(RTij, RpTij);</span>
<span class="nc" id="L3580">      egi = EBEsMatrizVectorMultiplicar(ri, ei);</span>

      //ProyecciÃƒÂ³n de los esfuerzos de barras sobre los ejes generales
      //en el nudo j
<span class="nc" id="L3584">      rj = EBEsMatrizMultiplicar(RTji, RpTji);</span>
<span class="nc" id="L3585">      egj = EBEsMatrizVectorMultiplicar(rj, ej);</span>

      //sumatoria de esfuerzos concurrentes al nudo
<span class="nc" id="L3588">      int ni = (int)Element_[ba][i_];</span>
<span class="nc" id="L3589">      Reaction_[numberOfLibertyDegree_ * ni + aX_][hi] += egi[aX_];</span>
<span class="nc" id="L3590">      Reaction_[numberOfLibertyDegree_ * ni + aY_][hi] += egi[aY_];</span>
<span class="nc" id="L3591">      Reaction_[numberOfLibertyDegree_ * ni + aZ_][hi] += egi[aZ_];</span>
<span class="nc" id="L3592">      Reaction_[numberOfLibertyDegree_ * ni + gX_][hi] += egi[gX_];</span>
<span class="nc" id="L3593">      Reaction_[numberOfLibertyDegree_ * ni + gY_][hi] += egi[gY_];</span>
<span class="nc" id="L3594">      Reaction_[numberOfLibertyDegree_ * ni + gZ_][hi] += egi[gZ_];</span>

      //sumatoria de esfuerzos concurrentes al nudo
<span class="nc" id="L3597">      int nj = (int)Element_[ba][j_];</span>
<span class="nc" id="L3598">      Reaction_[numberOfLibertyDegree_ * nj + aX_][hi] += egj[aX_];</span>
<span class="nc" id="L3599">      Reaction_[numberOfLibertyDegree_ * nj + aY_][hi] += egj[aY_];</span>
<span class="nc" id="L3600">      Reaction_[numberOfLibertyDegree_ * nj + aZ_][hi] += egj[aZ_];</span>
<span class="nc" id="L3601">      Reaction_[numberOfLibertyDegree_ * nj + gX_][hi] += egj[gX_];</span>
<span class="nc" id="L3602">      Reaction_[numberOfLibertyDegree_ * nj + gY_][hi] += egj[gY_];</span>
<span class="nc" id="L3603">      Reaction_[numberOfLibertyDegree_ * nj + gZ_][hi] += egj[gZ_];</span>
    } //ba
<span class="nc" id="L3605">  }</span>

  public void EBEsEffortsElements3D(int hi, int countIter, double Slip[][]) throws JMetalException{
    // ESFUERZOS EN EXTREMOS DE BARRA 3D EN COORDENADAS LOCALES
    // i: rÃƒÂ­gido
    // j: rÃƒÂ­gido
    int i, ni, nj;

<span class="nc bnc" id="L3613" title="All 2 branches missed.">    for(int ba=0; ba&lt;numberOfElements_; ba++){</span>

<span class="nc bnc" id="L3615" title="All 5 branches missed.">      switch((int)Element_[ba][Vij_]){</span>
<span class="nc" id="L3616">        case 00: EBEsMat3DL_iRig_jRig(ba); break;</span>
<span class="nc" id="L3617">        case 01: EBEsMat3DL_iRig_jArt(ba); break;</span>
<span class="nc" id="L3618">        case 10: EBEsMat3DL_iArt_jRig(ba); break;</span>
<span class="nc" id="L3619">        case 11: EBEsMat3DL_iArt_jArt(ba); break;</span>
<span class="nc" id="L3620">        default: System.out.println(&quot;invalid link&quot;);return;</span>
      }

<span class="nc bnc" id="L3623" title="All 4 branches missed.">      if(lSecondOrderGeometric &amp;&amp; countIter==1){</span>
<span class="nc" id="L3624">        EBEsMat3DL_SOG(ba);</span>
<span class="nc" id="L3625">        Kii=EBEsMatrixAdd(Kii, KiiSOG);</span>
<span class="nc" id="L3626">        Kij=EBEsMatrixAdd(Kij, KijSOG);</span>
<span class="nc" id="L3627">        Kji=EBEsMatrixAdd(Kji, KjiSOG);</span>
<span class="nc" id="L3628">        Kjj=EBEsMatrixAdd(Kjj, KjjSOG);</span>
      }

<span class="nc" id="L3631">      double [][] r  = new double[numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L3632">      double [][] s  = new double[numberOfLibertyDegree_][numberOfLibertyDegree_];</span>
<span class="nc" id="L3633">      double   []di  = new double[numberOfLibertyDegree_];</span>
<span class="nc" id="L3634">      double   []dj  = new double[numberOfLibertyDegree_];</span>
<span class="nc" id="L3635">      double   []eii = new double[numberOfLibertyDegree_];</span>
<span class="nc" id="L3636">      double   []eij = new double[numberOfLibertyDegree_];</span>
<span class="nc" id="L3637">      double   []eji = new double[numberOfLibertyDegree_];</span>
<span class="nc" id="L3638">      double   []ejj = new double[numberOfLibertyDegree_];</span>

      // matriz de rotaciÃƒÂ³n de la barra del sistema principal al local
<span class="nc" id="L3641">      EBEsMatRot3DLpSaL(ba);</span>
      // matriz de rotaciÃƒÂ³n de la barra del local al global
<span class="nc" id="L3643">      EBEsMatRot3DLaG(ba);</span>

      // desplazamientos calculados
<span class="nc bnc" id="L3646" title="All 2 branches missed.">      for(i=0; i&lt;numberOfLibertyDegree_; i++){</span>
<span class="nc" id="L3647">        ni=(int)Element_[ba][i_];</span>
<span class="nc" id="L3648">        nj=(int)Element_[ba][j_];</span>
<span class="nc" id="L3649">        di[i] = Slip[numberOfLibertyDegree_ * ni + i][hi];</span>
<span class="nc" id="L3650">        dj[i] = Slip[numberOfLibertyDegree_ * nj + i][hi];</span>
      } //Next i

      // para el extremo ii
      // eii = (Kii * Rpij * Rij) * Di
<span class="nc" id="L3655">      r=EBEsMatrizMultiplicar(Rpij, Rij);</span>
<span class="nc" id="L3656">      s=EBEsMatrizMultiplicar(Kii, r);</span>
<span class="nc" id="L3657">      eii=EBEsMatrizVectorMultiplicar(s, di);</span>

      // para el extremo ij
      // eij = (Kij * Rpji * Rji) * Dj
<span class="nc" id="L3661">      r=EBEsMatrizMultiplicar(Rpji, Rji);</span>
<span class="nc" id="L3662">      s=EBEsMatrizMultiplicar(Kij, r);</span>
<span class="nc" id="L3663">      eij=EBEsMatrizVectorMultiplicar(s, dj);</span>

      // para el extremo ji
      // eji =(Kji * Rpij * Rij) * Di
<span class="nc" id="L3667">      r=EBEsMatrizMultiplicar(Rpij, Rij);</span>
<span class="nc" id="L3668">      s=EBEsMatrizMultiplicar(Kji, r);</span>
<span class="nc" id="L3669">      eji=EBEsMatrizVectorMultiplicar(s, di);</span>

      // para el extremo jj
      // ejj= (Kjj * Rpji * Rji) * Dj
<span class="nc" id="L3673">      r=EBEsMatrizMultiplicar(Rpji, Rji);</span>
<span class="nc" id="L3674">      s=EBEsMatrizMultiplicar(Kjj, r);</span>
<span class="nc" id="L3675">      ejj=EBEsMatrizVectorMultiplicar(s, dj);</span>

<span class="nc bnc" id="L3677" title="All 2 branches missed.">      for(i=0; i&lt;numberOfLibertyDegree_; i++){</span>
<span class="nc" id="L3678">        Efforti_[i][ba][hi] = eii[i] + eij[i];</span>
<span class="nc" id="L3679">        Effortj_[i][ba][hi] = eji[i] + ejj[i];</span>
      } //i
    }// ba
<span class="nc" id="L3682">  } // end module</span>

  public void EBEsReactions3D(int hi){

<span class="nc bnc" id="L3686" title="All 2 branches missed.">    for(int i = 0; i&lt;numberOfNodesRestricts_; i++){</span>

<span class="nc" id="L3688">      int no=(int)NodeRestrict_[i][0];</span>

      //trasforma el nÃƒÂºmero en cÃƒÂ³digo texto caracterizando las coacciones;
<span class="nc" id="L3691">      String strCxyz=String.valueOf((int)NodeRestrict_[i][1]);</span>
      //if(strCxyz != &quot;000000&quot;){
<span class="nc" id="L3693">      String str=&quot;&quot;;</span>
<span class="nc bnc" id="L3694" title="All 2 branches missed.">      for(int j=numberOfLibertyDegree_;j&gt;strCxyz.length();j--){</span>
<span class="nc" id="L3695">        str+=&quot;0&quot;;</span>
      }
<span class="nc" id="L3697">      strCxyz=str+strCxyz;</span>
      // penalizaciÃƒÂ³n de la matriz de rigidez

<span class="nc" id="L3700">      char w0 = strCxyz.charAt(aX_); //sentido en X</span>
<span class="nc bnc" id="L3701" title="All 2 branches missed.">      if(w0 == '1'){</span>
        //fuerza aplicada en nudo en X
<span class="nc" id="L3703">        Reaction_[numberOfLibertyDegree_ * no + aX_][hi] += -PQ[numberOfLibertyDegree_ * no + aX_][hi];</span>
      }

<span class="nc" id="L3706">      w0 = strCxyz.charAt(aY_); //sentido en Y</span>
<span class="nc bnc" id="L3707" title="All 2 branches missed.">      if(w0 == '1'){</span>
        //fuerza aplicada en nudo en Y
<span class="nc" id="L3709">        Reaction_[numberOfLibertyDegree_ * no + aY_][hi] += -PQ[numberOfLibertyDegree_ * no + aY_][hi];</span>
      }

<span class="nc" id="L3712">      w0 = strCxyz.charAt(aZ_); //sentido en Z</span>
<span class="nc bnc" id="L3713" title="All 2 branches missed.">      if(w0 == '1'){</span>
        //fuerza aplicada en nudo en Z
<span class="nc" id="L3715">        Reaction_[numberOfLibertyDegree_ * no + aZ_][hi] += -PQ[numberOfLibertyDegree_ * no + aZ_][hi];</span>
      }

<span class="nc" id="L3718">      w0 = strCxyz.charAt(gX_);</span>
<span class="nc bnc" id="L3719" title="All 2 branches missed.">      if(w0 == '1'){</span>
        //flexor moment en nudo en X
<span class="nc" id="L3721">        Reaction_[numberOfLibertyDegree_ * no + gX_][hi] += -PQ[numberOfLibertyDegree_ * no + gX_][hi];</span>
      }

<span class="nc" id="L3724">      w0 = strCxyz.charAt(gY_); //rotaciÃƒÂ³n alrededor del eje Y</span>
<span class="nc bnc" id="L3725" title="All 2 branches missed.">      if(w0 == '1'){</span>
        //flexor moment en nudo en Y
<span class="nc" id="L3727">        Reaction_[numberOfLibertyDegree_ * no + gY_][hi] += -PQ[numberOfLibertyDegree_ * no + gY_][hi];</span>
      }

<span class="nc" id="L3730">      w0 = strCxyz.charAt(gZ_); //rotaciÃƒÂ³n alrededor del eje Z</span>
<span class="nc bnc" id="L3731" title="All 2 branches missed.">      if(w0 == '1'){</span>
        //flexor moment en nudo en Z
<span class="nc" id="L3733">        Reaction_[numberOfLibertyDegree_ * no + gZ_][hi] += -PQ[numberOfLibertyDegree_ * no + gZ_][hi];</span>
      }
      // }
    } //nex i
<span class="nc" id="L3737">  }</span>

  public double [][][]EBEsStrainNode(double [][][]E) throws JMetalException{

    // [0]: TensiÃƒÂ³n normal de compresiÃƒÂ³n
    // [1]: TensiÃƒÂ³n normal de tracciÃƒÂ³n
    // [2]: TensiÃƒÂ³n tangencial
<span class="nc" id="L3744">    double [][][]Strain = new double [3][numberOfElements_][numberOfWeigthHypothesis_];</span>
    double z, y;
    //double ez, ey;
    double  A, Iz, Iy, It;
    // Effort
    double Nxx, Qxy, Qxz, Mxx, Mxy, Mxz;
    // Streins
    double Sxx, Sxzu, Sxzd, TQxy, TQxz, TTx, TTxy, TTxz;
    double Sxyl, Sxyr;

    double y1, z1, S1, S2, S3, S4;
    double Ay, Az;

<span class="nc" id="L3757">    omegaMax_  = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L3758">    NxxMin_  = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L3759">    NxxMax_  = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L3760">    MxzMin_  = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L3761">    MxzMax_  = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L3762">    MxyMin_  = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L3763">    MxyMax_  = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L3764">    StrainNxxMin_  = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L3765">    StrainNxxMax_  = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L3766">    StrainMxzMin_  = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L3767">    StrainMxzMax_  = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L3768">    StrainMxyMin_  = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>
<span class="nc" id="L3769">    StrainMxyMax_  = new double[numberOfGroupElements_][numberOfWeigthHypothesis_];</span>

    // ver CÃƒÂ¡lculo de estructuras VIII.35
<span class="nc bnc" id="L3772" title="All 2 branches missed.">    for(int hi=0; hi&lt;numberOfWeigthHypothesis_; hi++){</span>
<span class="nc bnc" id="L3773" title="All 2 branches missed.">      for(int ba=0; ba&lt;numberOfElements_; ba++){</span>

        // index gropus
<span class="nc" id="L3776">        int idx = (int)Element_[ba][INDEX_];</span>

<span class="nc" id="L3778">        y = Groups_[idx][Y_];</span>
<span class="nc" id="L3779">        z = Groups_[idx][Z_];</span>
        //ey = Groups_[idx][eY_];
        //ez = Groups_[idx][eZ_];
<span class="nc" id="L3782">        A = Groups_[idx][AREA];</span>
<span class="nc" id="L3783">        Az = Groups_[idx][Az_];</span>
<span class="nc" id="L3784">        Ay = Groups_[idx][Ay_];</span>
<span class="nc" id="L3785">        Iz = Groups_[idx][Iz_];</span>
<span class="nc" id="L3786">        Iy = Groups_[idx][Iy_];</span>
<span class="nc" id="L3787">        It = Groups_[idx][It_];</span>

        // ESFUERZOS en MN (Mega Newton = 1 kN / 1000)
        // esfuerzos axial
<span class="nc" id="L3791">        Nxx=E[aX_][ba][hi];</span>
        // esfuerzo de corte en y
<span class="nc" id="L3793">        Qxy=E[aY_][ba][hi];</span>
        // esfuerzo de corte en z
<span class="nc" id="L3795">        Qxz=E[aZ_][ba][hi];</span>
        // momento torsor en x
<span class="nc" id="L3797">        Mxx=E[gX_][ba][hi];</span>
        // momento flexor en y
<span class="nc" id="L3799">        Mxy=E[gY_][ba][hi];</span>
        //momento flexor en z
<span class="nc" id="L3801">        Mxz=E[gZ_][ba][hi];</span>

        //TENSIONES NORMALES en MPa (Mega Pascal = 1.000.000 Pa = 1.000 kN/m2, [1.0 Pa = 1.0 N/mm2] )
        //TensiÃƒÂ³n normal en x debido a esf. axial x
        // Buckling coeficient omega
        // coeficiente de mayoraciÃ³n de Pandeo
<span class="nc" id="L3807">        double omega  = BucklingOmega(Nxx, Groups_[idx], Element_[ba]);</span>
<span class="nc" id="L3808">        Sxx=omega*Nxx/A;</span>
<span class="nc" id="L3809">        omegaMax_[idx][hi] = Math.max(omega, omegaMax_[idx][hi]);</span>

<span class="nc bnc" id="L3811" title="All 2 branches missed.">        if(Math.signum(Sxx)&gt;0) {</span>
<span class="nc" id="L3812">          NxxMax_[idx][hi] = Math.max(E[aX_][ba][hi], Nxx);</span>
<span class="nc" id="L3813">          StrainNxxMax_[idx][hi] = Math.max(Sxx, StrainNxxMax_[idx][hi]);</span>
        }
        else {
<span class="nc" id="L3816">          NxxMin_[idx][hi] = Math.min(E[aX_][ba][hi], Nxx);</span>
<span class="nc" id="L3817">          StrainNxxMin_[idx][hi] = Math.min(Sxx, StrainNxxMin_[idx][hi]);</span>
        }

<span class="nc bnc" id="L3820" title="All 2 branches missed.">        if(Element_[ba][Vij_] != 11)</span>
        {
          //tensiones de flexiÃƒÂ³n alrededor del eje z
          //fibra superior e inferior
<span class="nc" id="L3824">          y1=Groups_[idx][uY_];</span>
<span class="nc" id="L3825">          Sxzu=Mxz*y1/Iz;</span>
<span class="nc" id="L3826">          Sxzd=-Sxzu;</span>

          //tensiones normales de flexiÃƒÂ³n alrededor del eje y
          //fibra izquierda y derecha
<span class="nc" id="L3830">          z1=Groups_[idx][lZ_];</span>
<span class="nc" id="L3831">          Sxyl=Mxy*z1/Iy;</span>
<span class="nc" id="L3832">          Sxyr=-Sxyl;</span>

          // con momentos (-)
<span class="nc" id="L3835">          S3=Sxzu;</span>
<span class="nc" id="L3836">          StrainMxzMin_ [idx][hi]=Math.min(S3, StrainMxzMin_[idx][hi]);</span>
<span class="nc bnc" id="L3837" title="All 2 branches missed.">          if(S3 &gt; Sxzd){</span>
<span class="nc" id="L3838">            S3=Sxzd;</span>
<span class="nc" id="L3839">            StrainMxzMin_ [idx][hi]=Math.min(S3, StrainMxzMin_[idx][hi]);</span>
<span class="nc" id="L3840">            MxzMin_[idx][hi]=Math.min(-Mxz, MxzMin_[idx][hi]);</span>
          }
<span class="nc" id="L3842">          S4=Sxyl;</span>
<span class="nc" id="L3843">          StrainMxyMin_[idx][hi]=Math.min(S4, StrainMxyMin_[idx][hi]);</span>
<span class="nc bnc" id="L3844" title="All 2 branches missed.">          if(S4 &gt; Sxyr){</span>
<span class="nc" id="L3845">            S4=Sxyr;</span>
<span class="nc" id="L3846">            StrainMxyMin_[idx][hi]=Math.min(S4, StrainMxyMin_ [idx][hi]);</span>
<span class="nc" id="L3847">            MxyMin_[idx][hi]=Math.min(-Mxy, MxyMin_[idx][hi]);</span>
          }
          // tensiones negativas
<span class="nc" id="L3850">          Strain[STRAIN_COMPRESS][ba][hi]=Sxx+S3+S4;</span>

          //con momentos +
<span class="nc" id="L3853">          S1=Sxzu;</span>
<span class="nc" id="L3854">          StrainMxzMax_[idx][hi]=Math.max(S1, StrainMxzMax_[idx][hi]);</span>
<span class="nc bnc" id="L3855" title="All 2 branches missed.">          if (S1 &lt; Sxzd){</span>
<span class="nc" id="L3856">            S1=Sxzd;</span>
<span class="nc" id="L3857">            StrainMxzMax_[idx][hi]=Math.max(S1, StrainMxzMax_[idx][hi]);</span>
<span class="nc" id="L3858">            MxzMax_[idx][hi]=Math.max(Mxz, MxzMax_[idx][hi]);</span>
          }
<span class="nc" id="L3860">          S2=Sxyl;</span>
<span class="nc" id="L3861">          StrainMxyMax_[idx][hi]=Math.max(S2, StrainMxyMax_ [idx][hi]);</span>
<span class="nc bnc" id="L3862" title="All 2 branches missed.">          if(S2 &lt; Sxyr){</span>
<span class="nc" id="L3863">            S2=Sxyr;</span>
<span class="nc" id="L3864">            StrainMxyMax_[idx][hi]=Math.max(S2, StrainMxyMax_[idx][hi]);</span>
<span class="nc" id="L3865">            MxyMax_[idx][hi]=Math.max(Mxy, MxyMax_[idx][hi]);</span>
          }
          // tensiones positivas
<span class="nc" id="L3868">          Strain[STRAIN_TRACTION][ba][hi]=Sxx+S1+S2;</span>

          //momento estÃƒÂ¡tico respecto a z
          //espesores de las paredes
          //se desprecia el cordÃƒÂ³n superior, revisar
          //momento estÃƒÂ¡tico respecto a y
          //espesores de las paredes
          //se desprecia el cordÃƒÂ³n lateral

          //TENSIONES TANGENCIALES
          //tensiÃƒÂ³n de corte en y
<span class="nc" id="L3879">          TQxy=Qxy*Az/(z*Iz);</span>
          // CORTE TRANSVERSAL eje Z
          // TensiÃƒÂ³n de corte en z
<span class="nc" id="L3882">          TQxz=Qxz*Ay/(y*Iy);</span>

          //tensiÃƒÂ³n de torsiÃƒÂ³n
<span class="nc bnc" id="L3885" title="All 2 branches missed.">          if(z/y&gt;=1.0){</span>
<span class="nc" id="L3886">            TTxz=Math.abs(Mxx)*y/It;</span>
<span class="nc" id="L3887">            TTxy=0.9*TTxz;</span>
          }
          else{
<span class="nc" id="L3890">            TTxy=Math.abs(Mxx)*z/It;</span>
<span class="nc" id="L3891">            TTxz=0.9*TTxy;</span>
          }
<span class="nc" id="L3893">          TTx=TTxz;</span>
<span class="nc bnc" id="L3894" title="All 2 branches missed.">          if (TTx&lt;TTxy){</span>
<span class="nc" id="L3895">            TTx=TTxy;</span>
          }

          //tensiones tangenciales totales
<span class="nc" id="L3899">          Strain[STRAIN_CUT][ba][hi]=Math.abs(TQxz)+Math.abs(TQxy)+TTx;</span>
        }
        else{
<span class="nc" id="L3902">          Strain[STRAIN_CUT][ba][hi]=0.0;</span>

<span class="nc bnc" id="L3904" title="All 2 branches missed.">          if(E[aX_][ba][hi]&lt;0.0){</span>
<span class="nc" id="L3905">            Strain[STRAIN_COMPRESS][ba][hi]=Sxx;</span>
          }
<span class="nc bnc" id="L3907" title="All 2 branches missed.">          else if (E[aX_][ba][hi]&gt;0.0){</span>
<span class="nc" id="L3908">            Strain[STRAIN_TRACTION][ba][hi]=Sxx;</span>
          }
          else{
<span class="nc" id="L3911">            Strain[STRAIN_COMPRESS][ba][hi]=0.0;</span>
<span class="nc" id="L3912">            Strain[STRAIN_TRACTION][ba][hi]=0.0;</span>
          }
<span class="nc" id="L3914">          StrainNxxMin_ [idx][hi]=Math.max(Strain[STRAIN_COMPRESS][ba][hi], StrainNxxMin_[idx][hi]);</span>
<span class="nc" id="L3915">          StrainNxxMax_ [idx][hi]=Math.max(Strain[STRAIN_TRACTION][ba][hi], StrainNxxMax_[idx][hi]);</span>
        }
      } // next ba
    } // next hi

<span class="nc" id="L3920">    return Strain;</span>
  }

  public double BucklingOmega(double Nxx, double[] G, double[] B) throws JMetalException{

<span class="nc" id="L3925">    double w = 1.0; // coeficiente de Pandeo</span>

<span class="nc bnc" id="L3927" title="All 6 branches missed.">    if(Nxx &lt; 0.0 &amp;&amp; G[AREA] &gt; 0.0 &amp;&amp; lBuckling)</span>
    {
<span class="nc bnc" id="L3929" title="All 2 branches missed.">      if (G[BLijY_] &lt;= 0.0) G[BLijY_] = 1.0;</span>
<span class="nc bnc" id="L3930" title="All 2 branches missed.">      if (G[BLijZ_] &lt;= 0.0) G[BLijZ_] = 1.0;</span>

      // radio de inercia respecto al eje y
<span class="nc" id="L3933">      double iy  = G[Iy_] / G[AREA];</span>
      // radio de inercia respecto al eje z
<span class="nc" id="L3935">      double iz = G[Iz_] / G[AREA];</span>
      //esbeltez respecto al eje y
<span class="nc" id="L3937">      double lambdao  = B[L_] * G[BLijY_] / iy;</span>
      // esbeltez maxima entre para los ejes y, z
<span class="nc" id="L3939">      lambdao = Math.min(lambdao, B[L_] * G[BLijZ_] / iz);</span>

<span class="nc bnc" id="L3941" title="All 2 branches missed.">      if(G[TypeMaterial_]== 0) {</span>
        // steel cable stress 125 MN/m2
        // System.out.println(&quot;Error in &quot; + G[INDEX_] + &quot; group, the material number &quot; + G[TypeMaterial_] + &quot; is not implemented&quot;);
      }
<span class="nc bnc" id="L3945" title="All 2 branches missed.">      else if(G[TypeMaterial_]== 1)  // F-22 steel 22 MN/m2</span>
      {
<span class="nc" id="L3947">        System.out.println(&quot;Error in &quot; + G[INDEX_] + &quot; group, the material number &quot; + G[TypeMaterial_] + &quot; is not implemented&quot;);</span>
      }
<span class="nc bnc" id="L3949" title="All 2 branches missed.">      else if(G[TypeMaterial_]== 2)  // F-24 steel 24 MN/m2</span>
      {
        // MÃ©todo Domke - Tabla Lamda0  - Lamda
        // double lambda = -2.3443 + 1.07817 * lambdao - 0.0036181 * Math.pow(lambdao, 2) + 0.000008209862 * Math.pow(lambdao, 3) - 0.00000001058458 * Math.pow(lambdao, 4) + 0.000000000007147864 * Math.pow(lambdao, 5) - 0.00000000000000196410755 * Math.pow(lambdao, 6);
        // coeficiente omega de mayoraciÃ³n por efecto de Pandeo
        // double ratio = lambdao / lambda;
        // w = Math.pow(ratio, 2.0);

        // Buckling coefficient, Table: Lamda-Omega
<span class="nc" id="L3958">        double lambda  = lambdao;</span>
<span class="nc bnc" id="L3959" title="All 2 branches missed.">        if ( lambda &lt;= 150)</span>
        {
<span class="nc" id="L3961">          w = 1.113 + 0.0070516 * lambda - 0.000132108 * Math.pow(lambda, 2.0) + 0.000002106132 * Math.pow(lambda, 3.0) - 0.00000000397368332151 * Math.pow(lambda, 4.0);</span>
        }
<span class="nc" id="L3963">        else w = 25.0;</span>
<span class="nc" id="L3964">      }</span>

<span class="nc bnc" id="L3966" title="All 2 branches missed.">      else if(G[TypeMaterial_] == 3){  // F-32 steel 320 N/mm2</span>
<span class="nc" id="L3967">        System.out.println(&quot;Error in &quot; + G[INDEX_] + &quot; group, the material number &quot; + G[TypeMaterial_] + &quot; is not implemented&quot;);</span>
      }

<span class="nc bnc" id="L3970" title="All 2 branches missed.">      else if(G[TypeMaterial_] == 10){  // reinforced concrete  7 MN/m2</span>
<span class="nc" id="L3971">        System.out.println(&quot;Error in &quot; + G[INDEX_] + &quot; group, the material number &quot; + G[TypeMaterial_] + &quot; is not implemented&quot;);</span>
      }

<span class="nc bnc" id="L3974" title="All 2 branches missed.">      else if(G[TypeMaterial_] == 12){  // H-17 reinforced concrete 17 MN/m2</span>
<span class="nc" id="L3975">        System.out.println(&quot;Error in &quot; + G[INDEX_] + &quot; group, the material number &quot; + G[TypeMaterial_] + &quot; is not implemented&quot;);</span>
      }

<span class="nc bnc" id="L3978" title="All 2 branches missed.">      else if(G[TypeMaterial_] == 14){  // H-21 reinforced concrete 21 MN/m2</span>
        //System.out.println(&quot;Error in &quot; + G[INDEX_] + &quot; group, the material number &quot; + G[TypeMaterial_] + &quot; is not implemented&quot;);
      }

<span class="nc bnc" id="L3982" title="All 2 branches missed.">      else if(G[TypeMaterial_] == 20)  // Wood hard an halt-hard</span>
      {
        // Buckling coefficient, Table: Lamda-Omega
<span class="nc" id="L3985">        double lambda  = lambdao;</span>
<span class="nc bnc" id="L3986" title="All 2 branches missed.">        if (lambda&lt;=150)</span>
        {
<span class="nc" id="L3988">          w = 1.048 + 0.005524 * lambda - 0.000101666 * Math.pow(lambda, 2.0) + 0.00000301687 * Math.pow(lambda, 3.0) - 0.000000004366246 * Math.pow(lambda, 4.0);</span>
        }
<span class="nc" id="L3990">        else w = 25.0;</span>
      }
    }
<span class="nc" id="L3993">    return w;</span>
  }

  public void EBEsTransversalSectionCircular(int gr, double d) throws JMetalException{
    // calculus of Estatic Momentum
    // distancia Y en ejes locales principales
    double r;  // radius circle
    double Am; // 1/2 area of circle
    double y;  // distance to the centroid of the circle
<span class="nc" id="L4002">    Groups_[gr][Y_] = d;</span>
    // distancia Z en ejes locales principales
<span class="nc" id="L4004">    Groups_[gr][Z_] = d;</span>
    // coeficint thickness of the axis Y -&gt;  Ay
<span class="nc" id="L4006">    Groups_[gr][eY_]=0.0;</span>
    // coeficint thickness of the axis Z -&gt;  Az
<span class="nc" id="L4008">    Groups_[gr][eZ_]=0.0;</span>

<span class="nc" id="L4010">    r= d / 2.0;</span>
<span class="nc" id="L4011">    Groups_[gr][uY_]=r;</span>
<span class="nc" id="L4012">    Groups_[gr][dY_]=r;</span>
<span class="nc" id="L4013">    Groups_[gr][lZ_]=r;</span>
<span class="nc" id="L4014">    Groups_[gr][rZ_]=r;</span>

<span class="nc" id="L4016">    y= 4.0 * r / (3.0 * Math.PI);</span>
<span class="nc" id="L4017">    Am = Math.PI * Math.pow(r, 2.0) / 2.0;</span>
    // momento estÃƒÂ¡tico respecto de Z -&gt;  Az
<span class="nc" id="L4019">    Groups_[gr][Az_] = Am * Math.pow(y, 2.0);</span>
    // momento estÃƒÂ¡tico respecto de Y -&gt;  Ay
<span class="nc" id="L4021">    Groups_[gr][Ay_]=Groups_[gr][Az_];</span>

    // section
<span class="nc" id="L4024">    Groups_[gr][AREA]=Math.PI*Math.pow(d, 2.0)/4.0;</span>
    // mementum inertia Iz
<span class="nc" id="L4026">    Groups_[gr][Iz_]=Math.PI*Math.pow(d, 4.0)/64.0;</span>
    // mementum inertia Iy
<span class="nc" id="L4028">    Groups_[gr][Iy_]=Groups_[gr][Iz_];</span>
    // momentum inertia twisting It
<span class="nc" id="L4030">    Groups_[gr][It_]=Math.PI*Math.pow(d, 4.0)/32.0;</span>
<span class="nc" id="L4031">    Groups_[gr][Iw_]=Groups_[gr][It_];</span>
<span class="nc" id="L4032">  }</span>

  public void EBEsTransversalSectionHoleCircular(int gr, double D, double e) throws JMetalException{
    // calculus of Estatic Momentum
    double d, R, r, Y, y, Am, am;
    // distancia Y en ejes locales principales
<span class="nc" id="L4038">    Groups_[gr][Y_] = D;</span>
    // distancia Z en ejes locales principales
<span class="nc" id="L4040">    Groups_[gr][Z_] = D;</span>
    // distancia Z en ejes locales principales
    // coeficint thickness of the axis Y -&gt;  Ay
<span class="nc" id="L4043">    Groups_[gr][eY_] = e;</span>
    // coeficint thickness of the axis Z -&gt;  Az
<span class="nc" id="L4045">    Groups_[gr][eZ_] = e;</span>

    // distancias a las fibras mas alejadas
<span class="nc" id="L4048">    Groups_[gr][uY_]=D/2.0;</span>
<span class="nc" id="L4049">    Groups_[gr][dY_]=D/2.0;</span>
<span class="nc" id="L4050">    Groups_[gr][lZ_]=D/2.0;</span>
<span class="nc" id="L4051">    Groups_[gr][rZ_]=D/2.0;</span>

    // diÃƒÂ¡metro interno
<span class="nc" id="L4054">    R=D/2.0;</span>
<span class="nc" id="L4055">    d=D-2.0*e;</span>
<span class="nc" id="L4056">    r=d/2.0;</span>
<span class="nc" id="L4057">    Y=4.0*R/(3.0*Math.PI);</span>
<span class="nc" id="L4058">    y=4.0*r/(3.0*Math.PI);</span>
<span class="nc" id="L4059">    Am=Math.PI*Math.pow(R, 2.0)/2.0;</span>
<span class="nc" id="L4060">    am=Math.PI*Math.pow(r, 2.0)/2.0;</span>
    // momento estÃƒÂ¡tico respecto de Z -&gt;  Az
<span class="nc" id="L4062">    Groups_[gr][Az_]=Am*Math.pow(Y, 2.0)-am*Math.pow(y, 2.0);</span>
    // momento estÃƒÂ¡tico respecto de Y -&gt;  Ay
<span class="nc" id="L4064">    Groups_[gr][Ay_]=Groups_[gr][Az_];</span>

    // section
<span class="nc" id="L4067">    Groups_[gr][AREA]=Math.PI/4.0*(Math.pow(D, 2.0)-Math.pow(d, 2.0));</span>
    // mementum inertia Iz
<span class="nc" id="L4069">    Groups_[gr][Iz_]=Math.PI/64.0*(Math.pow(D, 4.0)-Math.pow(d, 4.0));</span>
    // mementum inertia Iy
<span class="nc" id="L4071">    Groups_[gr][Iy_]=Groups_[gr][Iz_];</span>
    // momentum inertia polar or twisting It
<span class="nc" id="L4073">    Groups_[gr][It_]=Math.PI/32.0*(Math.pow(D, 4.0)-Math.pow(d, 4.0));</span>
<span class="nc" id="L4074">    Groups_[gr][Iw_]=Groups_[gr][It_];</span>
<span class="nc" id="L4075">  }</span>

  public void EBEsTransversalSectionRectangle(int gr, double y, double z) throws JMetalException{
    // calculus of Estatic Momentum
    double y1,  z1;
    // distancia Y en ejes locales principales
<span class="nc" id="L4081">    Groups_[gr][Y_]=y;</span>
    // distancia Z en ejes locales principales
<span class="nc" id="L4083">    Groups_[gr][Z_]=z;</span>
    // coeficint thickness of the axis Y -&gt;  Ay
<span class="nc" id="L4085">    Groups_[gr][eY_]=0.0;</span>
    // coeficint thickness of the axis Z -&gt;  Az
<span class="nc" id="L4087">    Groups_[gr][eZ_]=0.0;</span>
    // media distancia Z en ejes locales principales
<span class="nc" id="L4089">    z1=z/2.0;</span>
    // media distancia Y en ejes locales principales
<span class="nc" id="L4091">    y1=y/2.0;</span>

    // distancias a las fibras mas alejadas
<span class="nc" id="L4094">    Groups_[gr][uY_]=y1;</span>
<span class="nc" id="L4095">    Groups_[gr][dY_]=y1;</span>
<span class="nc" id="L4096">    Groups_[gr][lZ_]=z1;</span>
<span class="nc" id="L4097">    Groups_[gr][rZ_]=z1;</span>

    // momento estÃƒÂ¡tico respecto de Y -&gt;  Ay
<span class="nc" id="L4100">    Groups_[gr][Ay_]=y*z1*z1/2.0;</span>
    // momento estÃƒÂ¡tico respecto de Z -&gt;  Az
<span class="nc" id="L4102">    Groups_[gr][Az_]=z*y1*y1/2.0;</span>

    //z:  lado de la base del rectÃƒÂ¡ngulo
    //y:  altura del rectÃƒÂ¡ngulo
    // section
<span class="nc" id="L4107">    Groups_[gr][AREA]=z*y;</span>
    // mementum inertia Iz
<span class="nc" id="L4109">    Groups_[gr][Iz_]=z*Math.pow(y, 3.0)/12.0;</span>
    // mementum inertia Iy
<span class="nc" id="L4111">    Groups_[gr][Iy_]=y*Math.pow(z, 3.0)/12.0;</span>
    // momentum inertia polar or twisting It
<span class="nc bnc" id="L4113" title="All 2 branches missed.">    if(z/y&gt;=1.0){</span>
<span class="nc" id="L4114">      Groups_[gr][It_]=0.22*z*Math.pow(y, 3.0);</span>
    }
    else{
<span class="nc" id="L4117">      Groups_[gr][It_]=0.22*y*Math.pow(z, 3.0);</span>
    }
<span class="nc" id="L4119">    Groups_[gr][Iw_]=Groups_[gr][It_];</span>
<span class="nc" id="L4120">  }</span>

  public void EBEsTransversalSectionHoleRectangle(int gr, double y, double z, double ey, double ez) throws JMetalException{

    // ba: es la barra de referencia en sentido y
    //  y: lado de la secciÃƒÂ³n rectangular
    //  z: lado de la secciÃƒÂ³n rectangular en sentido z
    // ey: espesor de cada pared se la secciÃƒÂ³n hueca en y
    // ez: espesor de cada pared se la secciÃƒÂ³n hueca en z

    // calculus of Estatic Momentum

    double  yi, zi;
    double as, ys, es, al, yl, el;
    double zl, ae, ze, ee;

    // distancia Y en ejes locales principales
<span class="nc" id="L4137">    Groups_[gr][Y_]=y;</span>
    // distancia Z en ejes locales principales
<span class="nc" id="L4139">    Groups_[gr][Z_]=z;</span>
    //thickness principal local axis Y
<span class="nc" id="L4141">    Groups_[gr][eY_]=ey;</span>
    //thickness principal local axis Z
<span class="nc" id="L4143">    Groups_[gr][eZ_]=ez;</span>

    // distancias a las fibras mas alejadas
<span class="nc" id="L4146">    Groups_[gr][uY_]=y/2.0;</span>
<span class="nc" id="L4147">    Groups_[gr][dY_]=y/2.0;</span>
<span class="nc" id="L4148">    Groups_[gr][lZ_]=z/2.0;</span>
<span class="nc" id="L4149">    Groups_[gr][rZ_]=z/2.0;</span>

    //lados de la secciÃƒÂ³n hueca
<span class="nc" id="L4152">    yi=y-2*ey;</span>
<span class="nc" id="L4153">    zi=z-2*ez;</span>

    // momento estÃƒÂ¡tico respecto a y
    // espesores de las paredes
    // se desprecia el cordÃƒÂ³n lateral

    // area cordÃƒÂ³n lateral
<span class="nc" id="L4160">    al=y*ez;</span>
    //distancia del baricentro al centro
<span class="nc" id="L4162">    zl=zi/2.0+ez/2.0;</span>
    // momento estÃƒÂ¡tico del cordÃƒÂ³n lateral
<span class="nc" id="L4164">    el=al*Math.pow(zl, 2.0);</span>
    // area del cordon extremo sup e inferior
<span class="nc" id="L4166">    ae=ey*zi/2.0;</span>
    // distancia del baricentro al centro
<span class="nc" id="L4168">    ze=zi/4.0;</span>
    //momento estÃƒÂ¡tico de 2 cordones extremos
<span class="nc" id="L4170">    ee=2.0*ae*Math.pow(ze, 2.0);</span>

    // momento estÃƒÂ¡tico respecto de Y -&gt;  Ay
<span class="nc" id="L4173">    Groups_[gr][Ay_]=el+ee;</span>

    // area cordÃƒÂ³n superior
<span class="nc" id="L4176">    as=z*ey;</span>
    //distancia del baricentro al centro
<span class="nc" id="L4178">    ys=yi/2.0+ey/2.0;</span>
    //momento estÃƒÂ¡tico al cordÃƒÂ³n superior
<span class="nc" id="L4180">    es=as*Math.pow(ys, 2.0);</span>
    //area cordÃƒÂ³n lateral
<span class="nc" id="L4182">    al=ez*(yi/2.0);</span>
    //distancia del baricentro al centro
<span class="nc" id="L4184">    yl=yi/4.0;</span>
    //momento estÃƒÂ¡tico de 2 cordoneslaterales
<span class="nc" id="L4186">    el=2.0*al*Math.pow(yl, 2.0);</span>
    // momento estÃƒÂ¡tico respecto de Z -&gt;  Az
<span class="nc" id="L4188">    Groups_[gr][Az_]=es+el;</span>

    // area de la secciÃƒÂ³n hueca
<span class="nc" id="L4191">    double Ai=zi*yi;</span>
    // area total
<span class="nc" id="L4193">    double At=z*y;</span>
    // thw solid area A
<span class="nc" id="L4195">    Groups_[gr][AREA]=At-Ai;</span>
    // momento de inercia respecto al eje z Iz
<span class="nc" id="L4197">    double Iez=z*Math.pow(y, 3.0)/12.0;</span>
<span class="nc" id="L4198">    double Iiz=zi*Math.pow(yi, 3.0)/12.0;</span>
<span class="nc" id="L4199">    Groups_[gr][Iz_]=Iez-Iiz;</span>

    // momento de inercia respecto al eje y Iy
<span class="nc" id="L4202">    double Iey=y*Math.pow(z, 3)/12;</span>
<span class="nc" id="L4203">    double Iiy=yi*Math.pow(zi, 3)/12;</span>
<span class="nc" id="L4204">    Groups_[gr][Iy_]=Iey-Iiy;</span>

    // inercia torsional
    // perÃƒÂ­metro medio
<span class="nc" id="L4208">    double It1=1.3*1/3*(2*z*Math.pow(ey, 3)+2*yi*Math.pow(ez, 3));</span>
<span class="nc" id="L4209">    double It2=Groups_[gr][Iz_]+Groups_[gr][Iy_];</span>
<span class="nc" id="L4210">    Groups_[gr][It_]=(It1+It2)/2;</span>
<span class="nc" id="L4211">    Groups_[gr][Iw_]=Groups_[gr][It_];</span>

<span class="nc" id="L4213">  }</span>

  public void EBEsTransversalSection_I_Single(int gr, double y, double z, double ey, double ez) throws JMetalException{

    // la orientaciÃƒÂ³n del perfil es con el alma coincidente con el eje Y
    // gr: es el grupo al que pertenece la barra
    // y: longitud en sentido del eje Y princial local
    // z: longitud en sentido del eje Z princial local
    // ey: espesor en sentido eje Y, es decir coincidente con el espesor de cada ala
    // ez: espesor en sentido Z, es decir coincidente con el espesor del alma

    // calculus of Estatic Momentum

    double yi, zi;
    double as, ys, es, al, yl, el;
    double zl, ae, ze, ee;

    // distancia Y en ejes locales principales
<span class="nc" id="L4231">    Groups_[gr][Y_]=y;</span>
    // distancia Z en ejes locales principales
<span class="nc" id="L4233">    Groups_[gr][Z_]=z;</span>
    //thickness principal local axis Y
<span class="nc" id="L4235">    Groups_[gr][eY_]=ey;</span>
    //thickness principal local axis Z
<span class="nc" id="L4237">    Groups_[gr][eZ_]=ez;</span>

    // distancias a las fibras mas alejadas
<span class="nc" id="L4240">    Groups_[gr][uY_]=y/2.0;</span>
<span class="nc" id="L4241">    Groups_[gr][dY_]=y/2.0;</span>
<span class="nc" id="L4242">    Groups_[gr][lZ_]=ez/2.0;</span>
<span class="nc" id="L4243">    Groups_[gr][rZ_]=ez/2.0;</span>

    //lados de la secciÃƒÂ³n hueca virtual
<span class="nc" id="L4246">    yi=y-2*ey;</span>
<span class="nc" id="L4247">    zi=z-ez;</span>

    // MOMENTO ESTÃƒï¿½TICO RESPECTO EJE y
    // desprecio el espesor del ala
    // area del alma
<span class="nc" id="L4252">    al=yi*ez;</span>
    //distancia del baricentro del alma al baricentro de la secciÃƒÂ³n completa
<span class="nc" id="L4254">    zl=ez/2;</span>
    // momento estÃƒÂ¡tico del alma
<span class="nc" id="L4256">    el=al*Math.pow(zl, 2.0);</span>

    // area media de los dos cordon extremo sup e inferior
<span class="nc" id="L4259">    ae=ey*z; // 2 medias areas de alas</span>
    // distancia del baricentro al centro
<span class="nc" id="L4261">    ze=z/4.0;</span>
    //momento estÃƒÂ¡tico de los 2 cordones extremos
<span class="nc" id="L4263">    ee=ae*Math.pow(ze, 2.0);</span>

    // momento estÃƒÂ¡tico total respecto de Y -&gt;  Ay
<span class="nc" id="L4266">    Groups_[gr][Ay_]=el+ee;</span>

    // MOMENTO ESTÃƒï¿½TICO  RESPECTO AL EJE Z
    // area cordÃƒÂ³n superior
<span class="nc" id="L4270">    as=z*ey;</span>
    //distancia del baricentro al centro
<span class="nc" id="L4272">    ys=yi/2.0+ey/2.0;</span>
    //momento estÃƒÂ¡tico al cordÃƒÂ³n superior
<span class="nc" id="L4274">    es=as*Math.pow(ys, 2.0);</span>
    //area alma
<span class="nc" id="L4276">    al=ez*(yi/2.0);</span>
    //distancia del baricentro al centro
<span class="nc" id="L4278">    yl=yi/4.0;</span>
    //momento estÃƒÂ¡tico del alma
<span class="nc" id="L4280">    el=al*Math.pow(yl, 2.0);</span>
    // momento estÃƒÂ¡tico respecto de Z -&gt;  Az
<span class="nc" id="L4282">    Groups_[gr][Az_]=es+el;</span>

    // area de la secciÃƒÂ³n hueca
<span class="nc" id="L4285">    double Ai=zi*yi;</span>
    // area total
<span class="nc" id="L4287">    double At=z*y;</span>
    // two solid area A
<span class="nc" id="L4289">    Groups_[gr][AREA]=At-Ai;</span>
    // momento de inercia respecto al eje z Iz
<span class="nc" id="L4291">    double Iez=z*Math.pow(y, 3.0)/12.0;</span>
<span class="nc" id="L4292">    double Iiz=zi*Math.pow(yi, 3.0)/12.0;</span>
<span class="nc" id="L4293">    Groups_[gr][Iz_]=Iez-Iiz;</span>

    // momento de inercia respecto al eje y Iy
    // double Iey=y*Math.pow(z, 3)/12.0;
    // double Iiy=yi*Math.pow(zi, 3)/12.0;
<span class="nc" id="L4298">    Groups_[gr][Iy_]=y*Math.pow(ez, 3.0)/12.0;</span>

    // inercia torsional
    // perÃƒÂ­metro medio
<span class="nc" id="L4302">    Groups_[gr][It_]=(2*z*Math.pow(ey,3.0)+yi*Math.pow(ez, 3.0))/3.0;</span>
<span class="nc" id="L4303">    Groups_[gr][Iw_]= Groups_[gr][It_];</span>
<span class="nc" id="L4304">  }</span>

  public void EBEsTransversalSection_I_Double(int gr, double y, double z, double ey, double ez) throws JMetalException{
<span class="nc" id="L4307">  }</span>

  public void EBEsTransversalSection_H_Single(int gr, double y, double z, double ey, double ez) throws JMetalException{
<span class="nc" id="L4310">  }</span>

  public void EBEsTransversalSection_H_Double(int gr, double y, double z, double ey, double ez) throws JMetalException{
<span class="nc" id="L4313">  }</span>
  public void EBEsTransversalSection_L_Single(int gr, double y, double z, double ey, double ez) throws JMetalException{
<span class="nc" id="L4315">  }</span>
  public void EBEsTransversalSection_L_Double(int gr, double y, double z, double ey, double ez) throws JMetalException{

    // la orientaciÃƒÂ³n del perfil es con las almas coincidente con
    // el eje Y separados por una placa de espesor igual a eZ
    // y las alas paralelas al eje Z hacia abajo

    // gr: es el grupo al que pertenece la barra
    // y: longitud en sentido del eje Y princial local
    // z: longitud en sentido del eje Z princial local
    // ey: espesor en sentido eje Y, es decir coincidente con el espesor de cada ala
    // ez: espesor en sentido Z, es decir coincidente con el espesor del alma
    //double y1, z1, yi, zi;
    //double as, ys, es, al, yl, el;
    //double zl, ae, ze, ee;
    double yi, zi;

    // distancia Y en ejes locales principales
<span class="nc" id="L4333">    Groups_[gr][Y_]=y;</span>
    // distancia Z en ejes locales principales
<span class="nc" id="L4335">    Groups_[gr][Z_]=z;</span>
    //thickness principal local axis Y
<span class="nc" id="L4337">    Groups_[gr][eY_]=ey;</span>
    //thickness principal local axis Z
<span class="nc" id="L4339">    Groups_[gr][eZ_]=ez;</span>

    //lados de la secciÃƒÂ³n hueca
<span class="nc" id="L4342">    yi=y-ey;</span>
<span class="nc" id="L4343">    zi=z-2*ez;</span>
    // area de la secciÃƒÂ³n hueca
<span class="nc" id="L4345">    double Ai=zi*yi;</span>
    // area total
<span class="nc" id="L4347">    double At=z*y;</span>
    // thw solid area A
<span class="nc" id="L4349">    Groups_[gr][AREA]=At-Ai;</span>

    // distancias a las fibras mas alejadas desde el centro de gavedad
<span class="nc" id="L4352">    Groups_[gr][dY_]=1/2.0*(ez*Math.pow(y,2)+zi*Math.pow(ey,2))/(ez*y+zi*ey);</span>
<span class="nc" id="L4353">    Groups_[gr][uY_]=y-Groups_[gr][dY_];</span>
<span class="nc" id="L4354">    Groups_[gr][rZ_]=z/2.0;</span>
<span class="nc" id="L4355">    Groups_[gr][lZ_]=z/2.0;</span>

    // momento estÃƒÂ¡tico respecto de Y -&gt;  Ay
<span class="nc" id="L4358">    Groups_[gr][Ay_]=0;</span>
    // momento estÃƒÂ¡tico respecto de Z -&gt;  Az
<span class="nc" id="L4360">    Groups_[gr][Az_]=0;</span>

<span class="nc" id="L4362">    Groups_[gr][Iz_]=0;</span>
<span class="nc" id="L4363">    Groups_[gr][Iy_]=0;</span>
<span class="nc" id="L4364">    Groups_[gr][It_]=0;</span>
<span class="nc" id="L4365">    Groups_[gr][Iw_]=0;</span>

<span class="nc" id="L4367">  }</span>
  public void EBEsTransversalSection_T_Single(int ba, double y, double z, double ey, double ez) throws JMetalException{
<span class="nc" id="L4369">  }</span>
  public void EBEsTransversalSection_T_Double(int ba, double y, double z, double ey, double ez) throws JMetalException{
<span class="nc" id="L4371">  }</span>
/*
public void EbesMutation(int groupId, int hi, Variable[] x) {


    if (StrainNxxMin_ != null &amp;&amp; StrainNxxMax_ != null)
    {

        // alturas necearias por tres esfuerzos distintos
        double[] Y = {0.0, 0.0, 0.0};

        // Ã¡rea de la secciÃ³n por tensiÃ³n de compresiÃ³n
        // participaciones de las tensiones normales referidas al esfuerzo axil
        double ratioStrainMinNxx = StrainNxxMin_[groupId][hi] / Groups_[groupId][COMPRESSION];
        // Ã¡rea de la secciÃ³n por tensiÃ³n de compresiÃ³n
        double Ac = omegaMax_[groupId][hi] * NxxMin_[groupId][hi] / Groups_[groupId][COMPRESSION] * ratioStrainMinNxx;
        // participaciones de las tensiones normales referidas al esfuerzo axil
        double ratioStrainMaxNxx = StrainNxxMax_[groupId][hi] / Groups_[groupId][STRESS];
        // Ã¡rea de la secciÃ³n por tensiÃ³n de tracciÃ³n
        double At = omegaMax_[groupId][hi] * NxxMax_[groupId][hi] / Groups_[groupId][STRESS] * ratioStrainMaxNxx;
        // Ã¡rea mÃ¡xima necesaria
        double A = Math.max(Ac, At);
        A *=  10000;
        // altura necesaria en funciÃ³n del area y del esfuerzo normal coincidente con el eje x
        Y[0] = Interpolation_I_Single_Y_func_Area_(A);

        // participaciones de las tensiones normales mÃ­nimas referidas al momento flector respecto al eje z
        double ratioStrainMinMxz = StrainMxzMin_[groupId][hi] / Groups_[groupId][COMPRESSION];
        // mÃ³dulo resistente por tensiÃ³n de compresiÃ³n respecto al momento flector Mxz
        double Wzc = MxzMin_[groupId][hi] / Groups_[groupId][COMPRESSION] * ratioStrainMinMxz;
        // participaciones de las tensiones normales mÃ¡ximas referidas al momento flector respecto al eje z
        double ratioStrainMaxMxz = StrainMxzMax_[groupId][hi] / Groups_[groupId][STRESS];
        // mÃ³dulo resistente por tensiÃ³n de tracciÃ³n respecto al momento flector Mxz
        double Wzt = MxzMax_[groupId][hi] / Groups_[groupId][STRESS] * ratioStrainMaxMxz;
        // mÃ³dulo resistente mÃ¡ximo necesario
        double Wxz = Math.max(Wzc, Wzt);
        // conversiÃ³n de unidades de medidas a cm3
        Wxz *= 1000000;
        // altura necesaria en funciÃ³n del mÃ³dulo resistente y del momento flector respecto al eje z
        Y[1] = Interpolation_I_Single_Y_func_Wxz_(Wxz);

        // participaciones de las tensiones normales mÃ­nimas referidas al momento flector respecto al eje y
        double ratioStrainMinMxy = StrainMxyMin_[groupId][hi] / Groups_[groupId][COMPRESSION];
        // mÃ³dulo resistente por tensiÃ³n de compresiÃ³n respecto al momento flector Mxz
        double Wyc = MxyMin_[groupId][hi] / Groups_[groupId][COMPRESSION] * ratioStrainMinMxy;
        // participaciones de las tensiones normales mÃ¡ximas referidas al momento flector respecto al eje y
        double ratioStrainMaxMxy = StrainMxyMax_[groupId][hi] / Groups_[groupId][STRESS];
        // mÃ³dulo resistente por tensiÃ³n de tracciÃ³n respecto al momento flector Mxz
        double Wyt = MxyMax_[groupId][hi] / Groups_[groupId][STRESS] * ratioStrainMaxMxy;
        // mÃ³dulo resistente mÃ¡ximo necesario
        double Wxy = Math.max(Wyc, Wyt);
        // conversiÃ³n de unidades de medidas a cm3
        Wxy *= 1000000;
        // altura necesaria en funciÃ³n del mÃ³dulo resistente y del momento flector respecto al eje z
        Y[2] = Interpolation_I_Single_Y_func_Wxy_(Wxy);

        // altura mÃ¡xima necesaria
        double y = 0.0;
        for (int i = 1; i &lt; Y.length; i++) {
            y = Math.max(y, Y[i]);
        }
        double z = Interpolation_I_Single_Z_func_Y_(y);
        double ey = Interpolation_I_Single_ey_func_Y_(y);
        double ez = Interpolation_I_Single_ez_func_Y_(y);

        int variableIndex = getVariablePosition(groupId);
        // conversiÃ³n de unidades de medidas al sistema de cÃ¡lculo
        y *= 0.001;
        if (y&lt;x[variableIndex].getLowerBound())
            y=x[variableIndex].getLowerBound();

        if (y&gt;x[variableIndex].getUpperBound())
            y=x[variableIndex].getUpperBound();

        z *= 0.001;
        ey *= 0.001;
        ez *= 0.001;

        x[variableIndex].setValue(y);
        x[variableIndex+1].setValue(z);
        x[variableIndex+2].setValue(ey);
        x[variableIndex+3].setValue(ez);
    }
}
*/

  public double Interpolation_I_Single_Y_func_Area_(double A)
  {
    // A (cm2) es el area necesaria para cubrir la tensiÃ³n
    // Y (mm) es la latura relacionada al eje y
<span class="nc" id="L4461">    double Y =0;</span>
    // se limita la interpolaciÃ³n
<span class="nc bnc" id="L4463" title="All 4 branches missed.">    if( 5.0 &lt; A &amp;&amp; A &lt; 1000.0)</span>
    {
<span class="nc" id="L4465">      Y = 0.000003*Math.pow(A,3) - 0.0063*Math.pow(A,2) + 4.1118*A + 75.414;</span>
    }
<span class="nc" id="L4467">    return Y;</span>
  }

  public double Interpolation_I_Single_Y_func_Wxy_(double Wxy)
  {
    // Wxy (cm3) es el area necesaria para cubrir la tensiÃ³n
    // Y (mm) es la latura relacionada al eje y
<span class="nc" id="L4474">    double Y =0;</span>
    // se limita la interpolaciÃ³n
<span class="nc bnc" id="L4476" title="All 4 branches missed.">    if( 1.0 &lt; Wxy &amp;&amp; Wxy &lt; 400.0)</span>
    {
<span class="nc" id="L4478">      Y = 0.0003*Math.pow(Wxy,3) - 0.119*Math.pow(Wxy,2) + 16.539*Wxy +136.59;</span>
    }
<span class="nc" id="L4480">    return Y;</span>
  }

  public double Interpolation_I_Single_Y_func_Wxz_(double Wxz)
  {
    // Wxz (cm3) es el area necesaria para cubrir la tensiÃ³n
    // Y (mm) es la latura relacionada al eje y
<span class="nc" id="L4487">    double Y =0;</span>
    // se limita la interpolaciÃ³n
<span class="nc bnc" id="L4489" title="All 4 branches missed.">    if( 3.0 &lt; Wxz &amp;&amp; Wxz &lt; 3500.0)</span>
    {
<span class="nc" id="L4491">      Y= 61.9 * Math.pow(Wxz, 0.3849);</span>
    }
<span class="nc" id="L4493">    return Y;</span>
  }

  public double Interpolation_I_Single_Z_func_Y_(double Y)
  {
    // Y (mm) es la altura dela secciÃ³n en sentido del eje y
    // Z (mm) es el ancho de la secciÃ³n en sentido del eje z
<span class="nc" id="L4500">    double Z =0;</span>
    // se limita la interpolaciÃ³n
<span class="nc bnc" id="L4502" title="All 4 branches missed.">    if( 50.0 &lt; Y &amp;&amp; Y &lt; 2000.0)</span>
    {
<span class="nc" id="L4504">      Z= -0.0002 * Math.pow(Y, 2.0) + 0.4339 * Y + 29.849;</span>
    }
<span class="nc" id="L4506">    return Z;</span>
  }

  public double Interpolation_I_Single_ez_func_Y_(double Y)
  {
    // Y (mm) es la altura dela secciÃ³n en sentido del eje y
    // ez (mm) es el ancho del alma del perfil en sentido del eje z
<span class="nc" id="L4513">    double ez =0;</span>
    // se limita la interpolaciÃ³n
<span class="nc bnc" id="L4515" title="All 4 branches missed.">    if( 50.0 &lt; Y &amp;&amp; Y &lt; 2000.0)</span>
    {
<span class="nc" id="L4517">      ez= 7E-08 * Math.pow(Y, 3.0) - 0.0001 *Math.pow(Y, 2.0) + 0.0632 * Y - 3.3817;</span>
    }
<span class="nc" id="L4519">    return ez;</span>
  }

  public double Interpolation_I_Single_ey_func_Y_(double Y)
  {
    // Y es la altura dela secciÃ³n en sentido del eje y
    // ey es el ancho del alma del perfil en sentido del eje y
<span class="nc" id="L4526">    double ey =0;</span>
    // se limita la interpolaciÃ³n
<span class="nc bnc" id="L4528" title="All 4 branches missed.">    if( 50.0 &lt; Y &amp;&amp; Y &lt; 2000.0)</span>
    {
<span class="nc" id="L4530">      ey = 1E-07 * Math.pow(Y, 3.0) - 0.0002 *Math.pow(Y, 2.0) + 0.1014 * Y - 4.5708;</span>
    }
<span class="nc" id="L4532">    return ey;</span>
  }

  public void EBEsStrainMaxWhitElement() throws JMetalException{
    // determinaciÃƒÂ³n de las tensiones mÃƒÂ¡ximas entre los extremos
<span class="nc bnc" id="L4537" title="All 2 branches missed.">    for(int hi=0; hi&lt;numberOfWeigthHypothesis_; hi++){</span>

<span class="nc" id="L4539">      StrainMax_[0][hi]=Straini_[0][0][hi]; // strain compress i</span>
<span class="nc" id="L4540">      StrainCutMax_[0][hi]=Math.abs(Straini_[2][0][hi]); // strain corte i</span>

<span class="nc bnc" id="L4542" title="All 2 branches missed.">      for(int ba=0; ba&lt;numberOfElements_; ba++){</span>

        // TENSIONES NORMALES
        // en nudo menor numeraciÃƒÂ³n i
<span class="nc bnc" id="L4546" title="All 2 branches missed.">        if(StrainMax_[ba][hi]&lt;Straini_[0][ba][hi]){</span>
<span class="nc" id="L4547">          StrainMax_[ba][hi]=Straini_[0][ba][hi]; // strain compression node j</span>
        }
        // en nudo menor numeraciÃƒÂ³n i
<span class="nc bnc" id="L4550" title="All 2 branches missed.">        if(StrainMax_[ba][hi]&lt;Strainj_[0][ba][hi]){</span>
<span class="nc" id="L4551">          StrainMax_[ba][hi]=Strainj_[0][ba][hi]; // strain compression node j</span>
        }
        // en nudo mayor numeraciÃƒÂ³n j
<span class="nc bnc" id="L4554" title="All 2 branches missed.">        if(StrainMax_[ba][hi]&lt;Straini_[1][ba][hi]){</span>
<span class="nc" id="L4555">          StrainMax_[ba][hi]=Straini_[1][ba][hi]; // strain traction node j</span>
        }
<span class="nc bnc" id="L4557" title="All 2 branches missed.">        if(StrainMax_[ba][hi]&lt;Strainj_[1][ba][hi]){</span>
<span class="nc" id="L4558">          StrainMax_[ba][hi]=Strainj_[1][ba][hi]; // strain traction node j</span>
        }

        // TENSIONES TANGENCIALES
        // en nudo menor numeraciÃƒÂ³n i
<span class="nc bnc" id="L4563" title="All 2 branches missed.">        if(StrainCutMax_[ba][hi]&lt;Math.abs(Straini_[2][ba][hi])){</span>
<span class="nc" id="L4564">          StrainCutMax_[ba][hi]=Math.abs(Straini_[2][ba][hi]); // strain traction node j</span>
        }
        // en nudo mayor numeraciÃƒÂ³n j
<span class="nc bnc" id="L4567" title="All 2 branches missed.">        if (StrainCutMax_[ba][hi]&lt;Math.abs(Strainj_[2][ba][hi])){</span>
          // en nudo mayor numeraciÃƒÂ³n j
<span class="nc" id="L4569">          StrainCutMax_[ba][hi]=Math.abs(Strainj_[2][ba][hi]);</span>
        }
      }
    }
<span class="nc" id="L4573">  }</span>

  public void EBEsStrainMinWhitElement() throws JMetalException{
    // determinaciÃƒÂ³n de las tensiones minimas entre los extremos
    // de las barras para cada agrupaciÃƒÂ³n
<span class="nc bnc" id="L4578" title="All 2 branches missed.">    for(int hi=0; hi&lt;numberOfWeigthHypothesis_; hi++){</span>

      // tensiones normales mÃƒÂ­nimas
      // en nudo menor numeraciÃƒÂ³n i
<span class="nc" id="L4582">      StrainMin_[0][hi]=Straini_[0][0][hi]; // strain compress i</span>

<span class="nc bnc" id="L4584" title="All 2 branches missed.">      for(int ba=0; ba&lt;numberOfElements_; ba++){</span>

        // TENSIONES NORMALES
        // en nudo menor numeraciÃƒÂ³n i
<span class="nc bnc" id="L4588" title="All 2 branches missed.">        if(StrainMin_[ba][hi]&gt;Straini_[0][ba][hi]){</span>
<span class="nc" id="L4589">          StrainMin_[ba][hi]=Straini_[0][ba][hi]; // strain compression node j</span>
        }
        // en nudo mayor numeraciÃƒÂ³n j
<span class="nc bnc" id="L4592" title="All 2 branches missed.">        if(StrainMin_[ba][hi]&gt;Strainj_[0][ba][hi]){</span>
<span class="nc" id="L4593">          StrainMin_[ba][hi]=Strainj_[0][ba][hi]; // strain compression node j</span>
        }
        // en nudo menor numeraciÃƒÂ³n i
<span class="nc bnc" id="L4596" title="All 2 branches missed.">        if(StrainMin_[ba][hi]&gt;Straini_[1][ba][hi]){</span>
<span class="nc" id="L4597">          StrainMin_[ba][hi]=Straini_[1][ba][hi]; // strain traction node j</span>
        }
        // en nudo mayor numeraciÃƒÂ³n j
<span class="nc bnc" id="L4600" title="All 2 branches missed.">        if(StrainMin_[ba][hi]&gt;Strainj_[1][ba][hi]){</span>
<span class="nc" id="L4601">          StrainMin_[ba][hi]=Strainj_[1][ba][hi]; // strain traction node j</span>
        }
      }
    }

<span class="nc" id="L4606">  }</span>


  public void EBEsStrainMaxWhitGroup() throws JMetalException{
    // determinaciÃƒÂ³n de las tensiones mÃƒÂ¡ximas entre los extremos
    // de las barras para cada agrupaciÃƒÂ³n
<span class="nc bnc" id="L4612" title="All 2 branches missed.">    for(int hi=0; hi&lt;numberOfWeigthHypothesis_; hi++){</span>

<span class="nc" id="L4614">      StrainMax_[0][hi]=Straini_[0][0][hi]; // strain compress i</span>
<span class="nc" id="L4615">      StrainCutMax_[0][hi]=Straini_[2][0][hi]; // strain corte i</span>

<span class="nc bnc" id="L4617" title="All 2 branches missed.">      for(int ba=0; ba&lt;numberOfElements_; ba++){</span>

        // index gropus
<span class="nc" id="L4620">        int idx = (int)Element_[ba][INDEX_];</span>

        // TENSIONES NORMALES
        // en nudo menor numeraciÃƒÂ³n i
<span class="nc bnc" id="L4624" title="All 2 branches missed.">        if(StrainMax_[idx][hi]&lt;Straini_[0][ba][hi]){</span>
<span class="nc" id="L4625">          StrainMax_[idx][hi]=Straini_[0][ba][hi]; // strain compression node i</span>
        }
        // en nudo mayor numeraciÃƒÂ³n j
<span class="nc bnc" id="L4628" title="All 2 branches missed.">        if(StrainMax_[idx][hi]&lt;Strainj_[0][ba][hi]){</span>
<span class="nc" id="L4629">          StrainMax_[idx][hi]=Strainj_[0][ba][hi]; // strain compression node j</span>
        }
        // en nudo menor numeraciÃƒÂ³n i
<span class="nc bnc" id="L4632" title="All 2 branches missed.">        if(StrainMax_[idx][hi]&lt;Straini_[1][ba][hi]){</span>
<span class="nc" id="L4633">          StrainMax_[idx][hi]=Straini_[1][ba][hi]; // strain traction node i</span>
        }
        // en nudo mayor numeraciÃƒÂ³n j
<span class="nc bnc" id="L4636" title="All 2 branches missed.">        if(StrainMax_[idx][hi]&lt;Strainj_[1][ba][hi]){</span>
<span class="nc" id="L4637">          StrainMax_[idx][hi]=Strainj_[1][ba][hi]; // strain traction node j</span>
        }

        // TENSIONES TANGENCIALES
        // en nudo menor numeraciÃƒÂ³n i
<span class="nc bnc" id="L4642" title="All 2 branches missed.">        if(StrainCutMax_[idx][hi]&lt;Math.abs(Straini_[2][ba][hi])){</span>
<span class="nc" id="L4643">          StrainCutMax_[idx][hi]=Math.abs(Straini_[2][ba][hi]); // strain traction node j</span>
        }
        // en nudo mayor numeraciÃƒÂ³n j
<span class="nc bnc" id="L4646" title="All 2 branches missed.">        if (StrainCutMax_[idx][hi]&lt;Math.abs(Strainj_[2][ba][hi])){</span>
          // en nudo mayor numeraciÃƒÂ³n j
<span class="nc" id="L4648">          StrainCutMax_[idx][hi]=Math.abs(Strainj_[2][ba][hi]);</span>
        }
      }
    }
<span class="nc" id="L4652">  }</span>

  public void EBEsStrainMinWhitGroup() throws JMetalException{
    // determinaciÃƒÂ³n de las tensiones minimas entre los extremos
<span class="nc bnc" id="L4656" title="All 2 branches missed.">    for(int hi=0; hi&lt;numberOfWeigthHypothesis_; hi++){</span>

      // tensiones normales mÃƒÂ­nimas
      // en nudo menor numeraciÃƒÂ³n i
<span class="nc" id="L4660">      StrainMin_[0][hi]=Straini_[0][0][hi]; // strain compress i</span>

<span class="nc bnc" id="L4662" title="All 2 branches missed.">      for(int ba=0; ba&lt;numberOfElements_; ba++){</span>

        // index gropus
<span class="nc" id="L4665">        int idx = (int)Element_[ba][INDEX_];</span>

        // TENSIONES NORMALES
        // en nudo menor numeraciÃƒÂ³n i
<span class="nc bnc" id="L4669" title="All 2 branches missed.">        if(StrainMin_[idx][hi]&gt;Straini_[0][ba][hi]){</span>
<span class="nc" id="L4670">          StrainMin_[idx][hi]=Straini_[0][ba][hi]; // strain compression node i</span>
        }
        // en nudo mayor numeraciÃƒÂ³n j
<span class="nc bnc" id="L4673" title="All 2 branches missed.">        if(StrainMin_[idx][hi]&gt;Strainj_[0][ba][hi]){</span>
<span class="nc" id="L4674">          StrainMin_[idx][hi]=Strainj_[0][ba][hi]; // strain compression node j</span>
        }
        // en nudo menor numeraciÃƒÂ³n i
<span class="nc bnc" id="L4677" title="All 2 branches missed.">        if(StrainMin_[idx][hi]&gt;Straini_[1][ba][hi]){</span>
<span class="nc" id="L4678">          StrainMin_[idx][hi]=Straini_[1][ba][hi]; // strain traction node i</span>
        }
        // en nudo mayor numeraciÃƒÂ³n j
<span class="nc bnc" id="L4681" title="All 2 branches missed.">        if(StrainMin_[idx][hi]&gt;Strainj_[1][ba][hi]){</span>
<span class="nc" id="L4682">          StrainMin_[idx][hi]=Strainj_[1][ba][hi]; // strain traction node j</span>
        }
      }
    }

<span class="nc" id="L4687">  }</span>

  public void EBEsStrainResidualVerication() throws JMetalException{


    // [0][hi] residual strain axial
    // [1][hi] residual strain transversal

<span class="nc bnc" id="L4695" title="All 2 branches missed.">    for(int hi=0; hi&lt;numberOfWeigthHypothesis_; hi++){</span>

      // for(int ba=0; ba&lt;numberOfElements_; ba++){
<span class="nc bnc" id="L4698" title="All 2 branches missed.">      for(int gr=0; gr&lt;numberOfGroupElements_; gr++){</span>
        // residuo de tensiones normales
<span class="nc bnc" id="L4700" title="All 2 branches missed.">        if (StrainMax_[gr][hi] != 0.0)</span>
<span class="nc" id="L4701">          StrainResidualMax_[hi] += Math.sqrt(Math.pow((StrainMax_[gr][hi]-Groups_[(int)Element_[gr][INDEX_]][STRESS]), 2.0));</span>
<span class="nc bnc" id="L4702" title="All 2 branches missed.">        if (StrainMin_[gr][hi] != 0.0)</span>
<span class="nc" id="L4703">          StrainResidualMin_[hi] += Math.sqrt(Math.pow((-StrainMin_[gr][hi]+Groups_[(int)Element_[gr][INDEX_]][COMPRESSION]), 2.0));</span>
        // residuos de tensiones tangenciales
<span class="nc bnc" id="L4705" title="All 2 branches missed.">        if (StrainCutMax_[gr][hi] != 0.0)</span>
<span class="nc" id="L4706">          StrainResidualCut_[hi] += Math.sqrt(Math.pow((StrainCutMax_[gr][hi]-Groups_[(int)Element_[gr][INDEX_]][STRESS_CUT]), 2.0));</span>
      }
    }
<span class="nc" id="L4709">  }</span>


  public void EBEsPrintArchTxtElements() throws JMetalException{
    try {
<span class="nc" id="L4714">      PrintStream ps = new PrintStream(&quot;EBEs - Groups Elements.txt&quot;);</span>
      // impresion de la las caracterÃƒÂ­sticas de las barras
<span class="nc" id="L4716">      ps.printf(&quot;Groups    Y      Z      eY_     eZ_    uY    dY   lZ    rZ    A      Az    Ay    Iz      Iy      Ip&quot;);</span>
<span class="nc" id="L4717">      ps.println();</span>
<span class="nc" id="L4718">      ps.printf(&quot;-----------------------------------------------------------------------------&quot;);</span>
<span class="nc" id="L4719">      ps.println();</span>
<span class="nc bnc" id="L4720" title="All 2 branches missed.">      for(int gr=0; gr&lt;Groups_.length; gr++){</span>
<span class="nc" id="L4721">        ps.printf(&quot;%4d %6.3f %6.3f %7.4f %7.4f %6.3f %6.3f %6.3f %6.3f %9.6f %9.6f %9.6f %9.6f %9.6f&quot;, gr, Groups_[gr][Y_], Groups_[gr][Z_], Groups_[gr][eY_], Groups_[gr][eZ_], Groups_[gr][uY_], Groups_[gr][dY_], Groups_[gr][lZ_], Groups_[gr][rZ_], Groups_[gr][Az_], Groups_[gr][Ay_], Groups_[gr][Iz_], Groups_[gr][Iy_], Groups_[gr][It_]);</span>
<span class="nc" id="L4722">        ps.println();</span>
      } //Next ba
<span class="nc" id="L4724">      ps.close();</span>
    }
<span class="nc" id="L4726">    catch (Exception ex) {</span>
<span class="nc" id="L4727">      System.out.println(&quot;Grupos de barras: El archivo no pudo grabarse!&quot;);</span>
<span class="nc" id="L4728">    }</span>
<span class="nc" id="L4729">  }</span>

  public void EBEsPrintArchTxtMKLB(int e) throws JMetalException{

    try {
<span class="nc" id="L4734">      PrintStream ps = new PrintStream(&quot;EBEs-MKLB(&quot; + e + &quot;).txt&quot;);</span>
      // impresion de la matriz de rigidez penalizada
      // extremo ii
<span class="nc" id="L4737">      ps.print(&quot;kii&quot; + e + &quot;=[&quot;);</span>
<span class="nc bnc" id="L4738" title="All 2 branches missed.">      for(int o = 0; o&lt;6; o++){</span>
<span class="nc bnc" id="L4739" title="All 2 branches missed.">        for(int p = 0; p&lt;6; p++){</span>
<span class="nc" id="L4740">          ps.printf(&quot;%12.3f&quot;, Kii[o][p]);</span>
<span class="nc bnc" id="L4741" title="All 4 branches missed.">          if(o != 5 &amp;&amp; p == 5){</span>
<span class="nc" id="L4742">            ps.print(&quot;;&quot;);</span>
          }
<span class="nc bnc" id="L4744" title="All 4 branches missed.">          else if(o == 5 &amp;&amp; p == 5){</span>
<span class="nc" id="L4745">            ps.print(&quot;]&quot;);</span>
          }
          else{
<span class="nc" id="L4748">            ps.print(&quot;,&quot;);</span>
          }
        } //Next p
      } //Next o
<span class="nc" id="L4752">      ps.println();</span>
<span class="nc" id="L4753">      ps.print(&quot;kij&quot; + e + &quot;=[&quot;);</span>
<span class="nc bnc" id="L4754" title="All 2 branches missed.">      for(int o = 0; o&lt;6; o++){</span>
<span class="nc bnc" id="L4755" title="All 2 branches missed.">        for(int p = 0; p&lt;6; p++){</span>
<span class="nc" id="L4756">          ps.printf(&quot;%12.3f&quot;,Kij[o][p]);</span>
<span class="nc bnc" id="L4757" title="All 4 branches missed.">          if(o != 5 &amp;&amp; p == 5){</span>
<span class="nc" id="L4758">            ps.print(&quot;;&quot;);</span>
          }
<span class="nc bnc" id="L4760" title="All 4 branches missed.">          else if(o == 5 &amp;&amp; p == 5){</span>
<span class="nc" id="L4761">            ps.print(&quot;]&quot;);</span>
          }
          else{
<span class="nc" id="L4764">            ps.print(&quot;,&quot;);</span>
          }
        } //Next p
      } //Next o
<span class="nc" id="L4768">      ps.println();</span>
<span class="nc" id="L4769">      ps.print(&quot;kji&quot; + e + &quot;=[&quot;);</span>
<span class="nc bnc" id="L4770" title="All 2 branches missed.">      for(int o = 0; o&lt;6; o++){</span>
<span class="nc bnc" id="L4771" title="All 2 branches missed.">        for(int p = 0; p&lt;6; p++){</span>
<span class="nc" id="L4772">          ps.printf(&quot;%12.3f&quot;,Kji[o][p]);</span>
<span class="nc bnc" id="L4773" title="All 4 branches missed.">          if(o != 5 &amp;&amp; p == 5){</span>
<span class="nc" id="L4774">            ps.print(&quot;;&quot;);</span>
          }
<span class="nc bnc" id="L4776" title="All 4 branches missed.">          else if(o == 5 &amp;&amp; p == 5){</span>
<span class="nc" id="L4777">            ps.print(&quot;]&quot;);</span>
          }
          else{
<span class="nc" id="L4780">            ps.print(&quot;,&quot;);</span>
          }
        } //Next p
      } //Next o
<span class="nc" id="L4784">      ps.println();</span>
<span class="nc" id="L4785">      ps.print(&quot;kjj&quot; + e + &quot;=[&quot;);</span>
<span class="nc bnc" id="L4786" title="All 2 branches missed.">      for(int o = 0; o&lt;6; o++){</span>
<span class="nc bnc" id="L4787" title="All 2 branches missed.">        for(int p = 0; p&lt;6; p++){</span>
<span class="nc" id="L4788">          ps.printf(&quot;%12.3f&quot;, Kjj[o][p]);</span>
<span class="nc bnc" id="L4789" title="All 4 branches missed.">          if(o != 5 &amp;&amp; p == 5){</span>
<span class="nc" id="L4790">            ps.print(&quot;;&quot;);</span>
          }
<span class="nc bnc" id="L4792" title="All 4 branches missed.">          else if(o == 5 &amp;&amp; p == 5){</span>
<span class="nc" id="L4793">            ps.print(&quot;]&quot;);</span>
          }
          else{
<span class="nc" id="L4796">            ps.print(&quot;,&quot;);</span>
          }
        } //Next p
      } //Next o
<span class="nc" id="L4800">      ps.println();</span>
<span class="nc" id="L4801">      ps.close();</span>
    }
<span class="nc" id="L4803">    catch (Exception ex) {</span>
<span class="nc" id="L4804">      System.out.println(&quot;Mat Rig Local: El archivo no pudo grabarse!&quot;);</span>
<span class="nc" id="L4805">    }</span>

<span class="nc" id="L4807">  }</span>

  public void EBEsPrintArchTxtMKG(String s, int hi) throws JMetalException{
    try {
<span class="nc" id="L4811">      PrintStream ps = new PrintStream(&quot;EBEs-M&quot;+s+&quot;-H(&quot; + hi + &quot;).txt&quot;);</span>
      // impresion de la matriz de rigidez penalizada
      // extremo ii
<span class="nc bnc" id="L4814" title="All 2 branches missed.">      for(int o = 0; o&lt;MatrixStiffness_.length; o++){</span>
<span class="nc" id="L4815">        ps.printf(&quot;(%5d) - %15.4f&quot;, o, MatrixStiffness_[o]);</span>
<span class="nc" id="L4816">        ps.println();</span>
      } //Next o
<span class="nc" id="L4818">      ps.close();</span>
    }
<span class="nc" id="L4820">    catch (Exception ex) {</span>
<span class="nc" id="L4821">      System.out.println(&quot;Mat Rig Global: El archivo no pudo grabarse!&quot;);</span>
<span class="nc" id="L4822">    }</span>
<span class="nc" id="L4823">  }</span>

  public void EBEsPrintArchTxtDesp(int hi) throws JMetalException{
    try {
<span class="nc" id="L4827">      PrintStream ps = new PrintStream(&quot;EBEs-Desp-H(&quot; + hi + &quot;).txt&quot;);</span>
      // impresion de la matriz de rigidez penalizada
      // extremo ii
<span class="nc bnc" id="L4830" title="All 2 branches missed.">      for(int o = 0; o&lt;DisplacementNodes_.length; o++){</span>
<span class="nc" id="L4831">        ps.printf(&quot;(%5d, %2d) = %20.16f&quot;, o, hi, DisplacementNodes_[o][hi]);</span>
<span class="nc" id="L4832">        ps.println();</span>
      } //Next o
<span class="nc" id="L4834">      ps.close();</span>
    }
<span class="nc" id="L4836">    catch (Exception ex) {</span>
<span class="nc" id="L4837">      System.out.println(&quot;Desplazamientos: El archivo no pudo grabarse!&quot;);</span>
<span class="nc" id="L4838">    }</span>
<span class="nc" id="L4839">  }</span>

  public void EBEsPrintArchTxtEfforts(int hi) throws JMetalException{
    try {
<span class="nc" id="L4843">      PrintStream ps = new PrintStream(&quot;EBEs-Efforts-H(&quot; + hi + &quot;).txt&quot;);</span>
      // impresion de la matriz de rigidez penalizada
      // extremo ii
<span class="nc bnc" id="L4846" title="All 2 branches missed.">      for(int ba=0; ba&lt;Element_.length; ba++){</span>
<span class="nc" id="L4847">        int ni = (int)Element_[ba][i_];</span>
<span class="nc" id="L4848">        int nj = (int)Element_[ba][j_];</span>
<span class="nc" id="L4849">        ps.printf(&quot;Ei(%3d,%3d)=%10.3f  %10.3f  %10.3f  %10.3f  %10.3f  %10.3f&quot;, ba, ni, Efforti_[0][ba][hi], Efforti_[1][ba][hi], Efforti_[2][ba][hi], Efforti_[3][ba][hi], Efforti_[4][ba][hi], Efforti_[5][ba][hi]);</span>
<span class="nc" id="L4850">        ps.println();</span>
<span class="nc" id="L4851">        ps.printf(&quot;Ej(%3d,%3d)=%10.3f  %10.3f  %10.3f  %10.3f  %10.3f  %10.3f&quot;, ba, nj, Effortj_[0][ba][hi], Effortj_[1][ba][hi], Effortj_[2][ba][hi], Effortj_[3][ba][hi], Effortj_[4][ba][hi], Effortj_[5][ba][hi]);</span>
<span class="nc" id="L4852">        ps.println();ps.println();</span>
      } //Next ba
<span class="nc" id="L4854">      ps.close();</span>
    }
<span class="nc" id="L4856">    catch (Exception ex) {</span>
<span class="nc" id="L4857">      System.out.println(&quot;Esfuerzos: El archivo no pudo grabarse!&quot;);</span>
<span class="nc" id="L4858">    }</span>
<span class="nc" id="L4859">  }</span>

  public void EBEsPrintArchTxtStrain() throws JMetalException{
    try {

<span class="nc bnc" id="L4864" title="All 2 branches missed.">      for(int hi=0; hi&lt;numberOfWeigthHypothesis_; hi++){</span>
<span class="nc" id="L4865">        PrintStream ps = new PrintStream(&quot;EBEs-Strain-H(&quot; + hi + &quot;).txt&quot;);</span>
        // impresion de la matriz de rigidez penalizada
        // extremo ii
<span class="nc" id="L4868">        ps.printf(&quot;Elements  Nodo   Stracc    Scomp     Scut&quot;);</span>
<span class="nc" id="L4869">        ps.println();</span>
<span class="nc" id="L4870">        ps.printf(&quot;--------------------------------------------&quot;);</span>
<span class="nc" id="L4871">        ps.println();</span>
<span class="nc bnc" id="L4872" title="All 2 branches missed.">        for(int ba=0; ba&lt;Element_.length; ba++){</span>
<span class="nc" id="L4873">          int ni = (int)Element_[ba][i_];</span>
<span class="nc" id="L4874">          int nj = (int)Element_[ba][j_];</span>
<span class="nc" id="L4875">          ps.printf(&quot;%4d  %4d  %10.3f  %10.3f  %10.3f&quot;, ba, ni, Straini_[STRAIN_TRACTION][ba][hi], Straini_[STRAIN_COMPRESS][ba][hi], Straini_[STRAIN_CUT][ba][hi]);</span>
<span class="nc" id="L4876">          ps.println();</span>
<span class="nc" id="L4877">          ps.printf(&quot;%4d  %4d  %10.3f  %10.3f  %10.3f&quot;, ba, nj, Strainj_[STRAIN_TRACTION][ba][hi], Strainj_[STRAIN_COMPRESS][ba][hi], Strainj_[STRAIN_CUT][ba][hi]);</span>
<span class="nc" id="L4878">          ps.println(); ps.println();</span>
        } //Next ba
<span class="nc" id="L4880">        ps.close();</span>
      }// hi
    }
<span class="nc" id="L4883">    catch (Exception ex) {</span>
<span class="nc" id="L4884">      System.out.println(&quot;Tensiones: El archivo no pudo grabarse!&quot;);</span>
<span class="nc" id="L4885">    }</span>

<span class="nc" id="L4887">  }</span>

  public void EBEsPrintArchTxtReaction(int hi) throws JMetalException{
    try {
<span class="nc" id="L4891">      PrintStream ps = new PrintStream(&quot;EBEs-Reaction-H(&quot; + hi + &quot;).txt&quot;);</span>
<span class="nc" id="L4892">      ps.printf(&quot;Nodo   Restriction   X    Y   Z   MX    MY    MZ&quot;);</span>
<span class="nc" id="L4893">      ps.println();</span>
<span class="nc" id="L4894">      ps.printf(&quot;--------------------------------------------&quot;);</span>
<span class="nc" id="L4895">      ps.println();</span>
      // impresion de la matriz de rigidez penalizada
      // extremo ii
<span class="nc bnc" id="L4898" title="All 2 branches missed.">      for(int o = 0; o&lt;NodeRestrict_.length; o++){</span>
<span class="nc" id="L4899">        int no = (int)NodeRestrict_[o][0];</span>
<span class="nc" id="L4900">        int ap = (int)NodeRestrict_[o][1];</span>
<span class="nc" id="L4901">        double x = Reaction_[6 * no + aX_ ][hi];</span>
<span class="nc" id="L4902">        double y = Reaction_[6 * no + aY_ ][hi];</span>
<span class="nc" id="L4903">        double z = Reaction_[6 * no + aZ_ ][hi];</span>
<span class="nc" id="L4904">        double mx = Reaction_[6 * no + gX_ ][hi];</span>
<span class="nc" id="L4905">        double my = Reaction_[6 * no + gY_ ][hi];</span>
<span class="nc" id="L4906">        double mz = Reaction_[6 * no + gZ_ ][hi];</span>
<span class="nc" id="L4907">        ps.printf(&quot;%5d  %6d  %8.3f %8.3f %8.3f %8.3f %8.3f %8.3f&quot;, no, ap, x, y, z, mx, my, mz);</span>
<span class="nc" id="L4908">        ps.println();</span>
      } //Next o
<span class="nc" id="L4910">      ps.close();</span>
    }
<span class="nc" id="L4912">    catch (Exception ex) {</span>
<span class="nc" id="L4913">      System.out.println(&quot;Reacciones: El archivo no pudo grabarse!&quot;);</span>
<span class="nc" id="L4914">    }</span>
<span class="nc" id="L4915">  }</span>

  public String EBEsReadProblems() throws FileNotFoundException {

    // en aquellos casos en los que se usen iteraciones en los algoritmos y no evaluaciones hacer
    // iteraciones = total evaluaciones / tamaÃ±o poblaciÃ³n

    char ch;
<span class="nc" id="L4923">    String line = &quot;&quot;;</span>
<span class="nc" id="L4924">    String var1 = &quot;&quot;;</span>
<span class="nc" id="L4925">    String txt = &quot;&quot;;</span>
<span class="nc" id="L4926">    int i=0, j=0;</span>

    // create a File instance
    //java.io.File file = new java.io.File(&quot;EBEs.txt&quot;);
    // create a Scanner for the file
    //java.util.Scanner input = new java.util.Scanner(file);

    //InputStream inputStream = getClass().getResourceAsStream(&quot;/&quot; + &quot;Ebes.txt&quot;);

<span class="nc" id="L4935">    InputStream inputStream = getClass().getResourceAsStream(&quot;/&quot; + &quot;Ebes.txt&quot;);</span>

<span class="nc bnc" id="L4937" title="All 2 branches missed.">    if (inputStream == null) {</span>
<span class="nc" id="L4938">      inputStream = new FileInputStream(&quot;Ebes.txt&quot;);</span>
    }

<span class="nc" id="L4941">    InputStreamReader isr = new InputStreamReader(inputStream);</span>
<span class="nc" id="L4942">    BufferedReader br = new BufferedReader(isr);</span>

<span class="nc" id="L4944">    Scanner input = new Scanner(br) ;</span>

    //java.util.Scanner input = new java.util.Scanner(file);
    // Read name problems EBEs
<span class="nc" id="L4948">    line=input.nextLine();</span>

    // count spaces
<span class="nc" id="L4951">    j=0;</span>
<span class="nc bnc" id="L4952" title="All 2 branches missed.">    for(i=line.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L4953">      ch=line.charAt(i);</span>
<span class="nc bnc" id="L4954" title="All 2 branches missed.">      if(ch == ' '){</span>
<span class="nc" id="L4955">        j++;</span>
      }
    }
<span class="nc" id="L4958">    OF_ = new String [j];</span>
<span class="nc" id="L4959">    int indOF=j-1;</span>

<span class="nc" id="L4961">    j=0;</span>
<span class="nc bnc" id="L4962" title="All 2 branches missed.">    for(i=line.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L4963">      ch=line.charAt(i);</span>
<span class="nc bnc" id="L4964" title="All 2 branches missed.">      if(ch == ' '){</span>
<span class="nc" id="L4965">        j=i+1;</span>
<span class="nc" id="L4966">        break;</span>
      }
    }
<span class="nc" id="L4969">    OF_[indOF]=line.substring(j);</span>
<span class="nc" id="L4970">    indOF--;</span>
<span class="nc" id="L4971">    int m=0;</span>
<span class="nc bnc" id="L4972" title="All 2 branches missed.">    if(indOF &gt;= 0)</span>
    {
<span class="nc bnc" id="L4974" title="All 2 branches missed.">      for(i=j-2;i&gt;=0;i--){</span>
<span class="nc" id="L4975">        ch=line.charAt(i);</span>
<span class="nc bnc" id="L4976" title="All 2 branches missed.">        if(ch == ' '){</span>
<span class="nc" id="L4977">          m=i+1;</span>
<span class="nc" id="L4978">          break;</span>
        }
      }
<span class="nc" id="L4981">      OF_[indOF]=line.substring(m, j-1);</span>
<span class="nc" id="L4982">      indOF--;</span>
    }
<span class="nc" id="L4984">    int n=0;</span>
<span class="nc bnc" id="L4985" title="All 2 branches missed.">    if(indOF &gt;= 0)</span>
    {
<span class="nc bnc" id="L4987" title="All 2 branches missed.">      for(i=m-2;i&gt;=0;i--){</span>
<span class="nc" id="L4988">        ch=line.charAt(i);</span>
<span class="nc bnc" id="L4989" title="All 2 branches missed.">        if(ch == ' '){</span>
<span class="nc" id="L4990">          n=i+1;</span>
<span class="nc" id="L4991">          break;</span>
        }
      }
<span class="nc" id="L4994">      OF_[indOF]=line.substring(n, m-1);</span>
<span class="nc" id="L4995">      indOF--;</span>
    }

<span class="nc" id="L4998">    int o=0;</span>
<span class="nc bnc" id="L4999" title="All 2 branches missed.">    if(indOF &gt;= 0)</span>
    {
<span class="nc bnc" id="L5001" title="All 2 branches missed.">      for(i=n-2;i&gt;=0;i--){</span>
<span class="nc" id="L5002">        ch=line.charAt(i);</span>
<span class="nc bnc" id="L5003" title="All 2 branches missed.">        if(ch == ' '){</span>
<span class="nc" id="L5004">          o=i+1;</span>
<span class="nc" id="L5005">          break;</span>
        }
      }
<span class="nc" id="L5008">      OF_[indOF]=line.substring(o, n-1);</span>
<span class="nc" id="L5009">      indOF--;</span>
    }

<span class="nc" id="L5012">    int p=0;</span>
<span class="nc bnc" id="L5013" title="All 2 branches missed.">    if(indOF &gt;= 0)</span>
    {
<span class="nc bnc" id="L5015" title="All 2 branches missed.">      for(i=o-2;i&gt;=0;i--){</span>
<span class="nc" id="L5016">        ch=line.charAt(i);</span>
<span class="nc bnc" id="L5017" title="All 2 branches missed.">        if(ch == ' '){</span>
<span class="nc" id="L5018">          p=i+1;</span>
<span class="nc" id="L5019">          break;</span>
        }
      }
<span class="nc" id="L5022">      OF_[indOF]=line.substring(p, o-1);</span>
<span class="nc" id="L5023">      indOF--;</span>
    }

<span class="nc" id="L5026">    line = line.substring(0,i);</span>
<span class="nc" id="L5027">    j=0;</span>
<span class="nc bnc" id="L5028" title="All 2 branches missed.">    for(i=line.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L5029">      ch=line.charAt(i);</span>
<span class="nc bnc" id="L5030" title="All 2 branches missed.">      if(ch == ' '){</span>
<span class="nc" id="L5031">        j=i+1;</span>
<span class="nc" id="L5032">        break;</span>
      }
    }
<span class="nc" id="L5035">    var1 = line.substring(j);</span>

<span class="nc bnc" id="L5037" title="All 2 branches missed.">    if(i == -1 )</span>
    {
<span class="nc" id="L5039">      txt = var1;</span>
    }
    else
    {
<span class="nc" id="L5043">      txt = line.substring(0,i);</span>
    }
    // clse the file
<span class="nc" id="L5046">    input.close();</span>


<span class="nc" id="L5049">    return txt;</span>

  }


  public final void EBEsReadDataFile(String fileName) throws JMetalException{

<span class="nc" id="L5056">    int i, j=0;</span>
    char ch;
<span class="nc" id="L5058">    String txt = &quot;&quot;;</span>

    try {
      // create a File instance
<span class="nc" id="L5062">      InputStream inputStream = getClass().getResourceAsStream(&quot;/&quot; + fileName);</span>

<span class="nc bnc" id="L5064" title="All 2 branches missed.">      if (inputStream == null) {</span>
<span class="nc" id="L5065">        inputStream = new FileInputStream(fileName);</span>
      }
      // create a Scanner for the file
<span class="nc" id="L5068">      Scanner input = new Scanner(inputStream);</span>
      // Read data from file
<span class="nc bnc" id="L5070" title="All 2 branches missed.">      while(input.hasNext()){</span>
<span class="nc bnc" id="L5071" title="All 2 branches missed.">        for (i=0;i&lt;5;i++){txt=input.nextLine();}</span>

        // number of nodes
<span class="nc bnc" id="L5074" title="All 2 branches missed.">        for(i=txt.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L5075">          ch=txt.charAt(i);</span>
<span class="nc bnc" id="L5076" title="All 2 branches missed.">          if(ch == ' '){</span>
<span class="nc" id="L5077">            j=i+1;break;}</span>
        }
<span class="nc" id="L5079">        txt = txt.substring(j);</span>
<span class="nc" id="L5080">        numberOfNodes =Integer.valueOf(txt);</span>

        // number of restriction
<span class="nc" id="L5083">        txt=input.nextLine();</span>
<span class="nc bnc" id="L5084" title="All 2 branches missed.">        for(i=txt.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L5085">          ch=txt.charAt(i);</span>
<span class="nc bnc" id="L5086" title="All 2 branches missed.">          if(ch == ' '){</span>
<span class="nc" id="L5087">            j=i+1;break;}</span>
        }
<span class="nc" id="L5089">        txt = txt.substring(j);</span>
<span class="nc" id="L5090">        numberOfNodesRestricts_=Integer.valueOf(txt);</span>

        // number of bar groups
<span class="nc" id="L5093">        txt=input.nextLine();</span>
<span class="nc bnc" id="L5094" title="All 2 branches missed.">        for(i=txt.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L5095">          ch=txt.charAt(i);</span>
<span class="nc bnc" id="L5096" title="All 2 branches missed.">          if(ch == ' '){</span>
<span class="nc" id="L5097">            j=i+1;break;}</span>
        }
<span class="nc" id="L5099">        txt = txt.substring(j);</span>
<span class="nc" id="L5100">        numberOfGroupElements_=Integer.valueOf(txt);</span>

        // number of elements
<span class="nc" id="L5103">        txt=input.nextLine();</span>
<span class="nc bnc" id="L5104" title="All 2 branches missed.">        for(i=txt.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L5105">          ch=txt.charAt(i);</span>
<span class="nc bnc" id="L5106" title="All 2 branches missed.">          if(ch == ' '){</span>
<span class="nc" id="L5107">            j=i+1;break;}</span>
        }
<span class="nc" id="L5109">        txt = txt.substring(j);</span>
<span class="nc" id="L5110">        numberOfElements_=Integer.valueOf(txt);</span>

        // number of hipotesis
<span class="nc bnc" id="L5113" title="All 2 branches missed.">        for (i=0;i&lt;5;i++){txt=input.nextLine();}</span>
<span class="nc bnc" id="L5114" title="All 2 branches missed.">        for(i=txt.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L5115">          ch=txt.charAt(i);</span>
<span class="nc bnc" id="L5116" title="All 2 branches missed.">          if(ch == ' '){</span>
<span class="nc" id="L5117">            j=i+1;break;}</span>
        }
<span class="nc" id="L5119">        txt = txt.substring(j);</span>
<span class="nc" id="L5120">        numberOfWeigthHypothesis_=Integer.valueOf(txt);</span>
<span class="nc" id="L5121">        numberOfWeigthHypothesis_=1;</span>

        // load as own weight for elements
<span class="nc" id="L5124">        txt=input.nextLine();</span>
<span class="nc bnc" id="L5125" title="All 2 branches missed.">        for(i=txt.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L5126">          ch=txt.charAt(i);</span>
<span class="nc bnc" id="L5127" title="All 2 branches missed.">          if(ch == ' '){</span>
<span class="nc" id="L5128">            j=i+1;break;}</span>
        }
<span class="nc" id="L5130">        txt = txt.substring(j);</span>
<span class="nc" id="L5131">        lLoadsOwnWeight =Boolean.valueOf(txt);</span>

        // Weight elements
<span class="nc" id="L5134">        txt=input.nextLine();</span>
<span class="nc bnc" id="L5135" title="All 2 branches missed.">        for(i=txt.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L5136">          ch=txt.charAt(i);</span>
<span class="nc bnc" id="L5137" title="All 2 branches missed.">          if(ch == ' '){</span>
<span class="nc" id="L5138">            j=i+1;break;}</span>
        }
<span class="nc" id="L5140">        txt = txt.substring(j);</span>
<span class="nc" id="L5141">        numberOfWeigthsElements_=Integer.valueOf(txt);</span>

        // Weight nodes
<span class="nc" id="L5144">        txt=input.nextLine();</span>
<span class="nc bnc" id="L5145" title="All 2 branches missed.">        for(i=txt.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L5146">          ch=txt.charAt(i);</span>
<span class="nc bnc" id="L5147" title="All 2 branches missed.">          if(ch == ' '){</span>
<span class="nc" id="L5148">            j=i+1;break;}</span>
        }
<span class="nc" id="L5150">        txt = txt.substring(j);</span>
<span class="nc" id="L5151">        numberOfWeigthsNodes_=Integer.valueOf(txt);</span>
        //txt = input.nextLine();
        //txt = input.next();

        // read lines
<span class="nc bnc" id="L5156" title="All 2 branches missed.">        for (i=0;i&lt;4;i++){txt=input.nextLine();}</span>

        // check node constraint
<span class="nc bnc" id="L5159" title="All 2 branches missed.">        for(i=txt.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L5160">          ch=txt.charAt(i);</span>
<span class="nc bnc" id="L5161" title="All 2 branches missed.">          if(ch == ' '){</span>
<span class="nc" id="L5162">            j=i+1;break;}</span>
        }
<span class="nc" id="L5164">        txt = txt.substring(j);</span>
<span class="nc" id="L5165">        numberOfConstraintsNodes_ = Integer.valueOf(txt);</span>

        // number Of Groups To Check Geometry
        // read lines
<span class="nc" id="L5169">        txt=input.nextLine();</span>
<span class="nc bnc" id="L5170" title="All 2 branches missed.">        for(i=txt.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L5171">          ch=txt.charAt(i);</span>
<span class="nc bnc" id="L5172" title="All 2 branches missed.">          if(ch == ' '){</span>
<span class="nc" id="L5173">            j=i+1;break;}</span>
        }
<span class="nc" id="L5175">        txt = txt.substring(j);</span>
<span class="nc" id="L5176">        numberOfGroupsToCheckGeometry_= Integer.valueOf(txt);</span>

        // Cutting efect (not not included, read lines)
<span class="nc" id="L5179">        txt=input.nextLine();</span>

        // considered second-order effect
<span class="nc" id="L5182">        txt=input.nextLine();</span>
<span class="nc bnc" id="L5183" title="All 2 branches missed.">        for(i=txt.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L5184">          ch=txt.charAt(i);</span>
<span class="nc bnc" id="L5185" title="All 2 branches missed.">          if(ch == ' '){</span>
<span class="nc" id="L5186">            j=i+1;break;}</span>
        }
<span class="nc" id="L5188">        txt = txt.substring(j);</span>
<span class="nc" id="L5189">        lSecondOrderGeometric =Boolean.valueOf(txt);</span>

        // considered buckling effect
<span class="nc" id="L5192">        txt=input.nextLine();</span>
<span class="nc bnc" id="L5193" title="All 2 branches missed.">        for(i=txt.length()-1;i&gt;=0;i--){</span>
<span class="nc" id="L5194">          ch=txt.charAt(i);</span>
<span class="nc bnc" id="L5195" title="All 2 branches missed.">          if(ch == ' '){</span>
<span class="nc" id="L5196">            j=i+1;break;}</span>
        }
<span class="nc" id="L5198">        txt = txt.substring(j);</span>
<span class="nc" id="L5199">        lBuckling =Boolean.valueOf(txt);</span>

        // read lines
<span class="nc bnc" id="L5202" title="All 2 branches missed.">        for (i=0;i&lt;3;i++){txt=input.nextLine();}</span>

<span class="nc" id="L5204">        Node_ = new double[numberOfNodes][4];</span>
<span class="nc bnc" id="L5205" title="All 2 branches missed.">        for (i=0;i&lt; numberOfNodes;i++){</span>
<span class="nc" id="L5206">          txt=input.next();</span>
<span class="nc bnc" id="L5207" title="All 2 branches missed.">          for (j=0;j&lt;4;j++){</span>
<span class="nc" id="L5208">            Node_[i][j]=Double.valueOf(input.next());</span>
          }
<span class="nc bnc" id="L5210" title="All 2 branches missed.">          for (j=0;j&lt;6;j++){txt=input.next();}</span>
        }

<span class="nc" id="L5213">        NodeRestrict_ = new double[numberOfNodesRestricts_][2];</span>
<span class="nc" id="L5214">        j=0;</span>
<span class="nc bnc" id="L5215" title="All 2 branches missed.">        for(i=0;i&lt; numberOfNodes;i++){</span>
<span class="nc bnc" id="L5216" title="All 2 branches missed.">          if(Node_[i][3] != 0){</span>
            // Restriction of the movement
<span class="nc" id="L5218">            NodeRestrict_[j][0]=i;</span>
<span class="nc" id="L5219">            NodeRestrict_[j][1]=Node_[i][3];</span>
<span class="nc" id="L5220">            j++;</span>
          }
        }
        // ELEMENTS GROUPS
<span class="nc" id="L5224">        txt=input.nextLine();</span>
<span class="nc" id="L5225">        txt=input.nextLine();</span>
<span class="nc" id="L5226">        Groups_ = new double[numberOfGroupElements_][MAX_COLUMN];</span>
<span class="nc bnc" id="L5227" title="All 2 branches missed.">        for (i=0;i&lt;numberOfGroupElements_;i++){</span>
<span class="nc bnc" id="L5228" title="All 2 branches missed.">          for (j=0;j&lt;MAX_COLUMN-1;j++){</span>
<span class="nc" id="L5229">            Groups_[i][j]=Double.valueOf(input.next());</span>
          }
<span class="nc" id="L5231">          input.next(); // description</span>
        }

        // ELEMENTS
<span class="nc" id="L5235">        txt=input.nextLine();</span>
<span class="nc" id="L5236">        txt=input.nextLine();</span>
<span class="nc" id="L5237">        Element_ = new double[numberOfElements_][8];</span>
<span class="nc bnc" id="L5238" title="All 2 branches missed.">        for (i=0;i&lt;numberOfElements_;i++){</span>
<span class="nc" id="L5239">          txt=input.next();// BARRAS</span>
<span class="nc" id="L5240">          Element_[i][INDEX_]=Double.valueOf(input.next());</span>
<span class="nc" id="L5241">          Element_[i][i_]=Double.valueOf(input.next());</span>
<span class="nc" id="L5242">          Element_[i][j_]=Double.valueOf(input.next());</span>
<span class="nc" id="L5243">          Element_[i][L_]=Double.valueOf(input.next());</span>
<span class="nc" id="L5244">          Element_[i][Vij_]=Double.valueOf(input.next());</span>
<span class="nc" id="L5245">          Element_[i][Ei_]=Double.valueOf(input.next());</span>
<span class="nc" id="L5246">          Element_[i][Ej_]=Double.valueOf(input.next());</span>
          // correction
<span class="nc" id="L5248">          int ni = (int)Element_[i][i_];</span>
<span class="nc" id="L5249">          int nj = (int)Element_[i][j_];</span>
          double xi, yi, zi;
          double xj, yj, zj;
          //coordenadas de los extremso de la barra
                /*
                if(Math.abs(Node_[ni][aX_])&lt;= 0.000001)
                   xi = 0.0;
                else xi=Node_[ni][aX_];

                if(Math.abs(Node_[ni][aY_])&lt;= 0.000001)
                	yi= 0.0;
                else yi = Node_[ni][aY_];

                if(Math.abs(Node_[ni][aZ_])&lt;= 0.000001)
                    zi = 0.0;
                else zi = Node_[ni][aZ_];

                if(Math.abs(Node_[nj][aX_])&lt;= 0.000001)
                    xj = 0.0;
                else xj=Node_[nj][aX_];

                if(Math.abs(Node_[nj][aY_])&lt;= 0.000001)
                	yj=0.0;
                else yj = Node_[nj][aY_];

                if(Math.abs(Node_[nj][aZ_])&lt;= 0.000001)
                	zj = 0.0;
                else
                */
<span class="nc" id="L5278">          xi = Node_[ni][aX_];</span>
<span class="nc" id="L5279">          yi = Node_[ni][aY_];</span>
<span class="nc" id="L5280">          zi = Node_[ni][aZ_];</span>
<span class="nc" id="L5281">          xj = Node_[nj][aX_];</span>
<span class="nc" id="L5282">          yj = Node_[nj][aY_];</span>
<span class="nc" id="L5283">          zj = Node_[nj][aZ_];</span>
<span class="nc" id="L5284">          Element_[i][L_]=Math.sqrt(Math.pow((xj - xi), 2.0) + Math.pow((yj - yi), 2.0) + Math.pow((zj - zi), 2.0));</span>
<span class="nc bnc" id="L5285" title="All 2 branches missed.">          if(Element_[i][L_] &lt; 0.001) Element_[i][L_] = 0.0;</span>
        }
<span class="nc" id="L5287">        txt=input.nextLine();</span>
<span class="nc" id="L5288">        txt=input.nextLine();</span>
        // OVERLOAD
<span class="nc" id="L5290">        OverloadInElement_ = new double[numberOfWeigthsElements_][8];</span>
<span class="nc bnc" id="L5291" title="All 2 branches missed.">        for (i=0;i&lt;numberOfWeigthsElements_;i++){</span>
<span class="nc" id="L5292">          txt=input.next(); // load number</span>
<span class="nc bnc" id="L5293" title="All 2 branches missed.">          for (j=0;j&lt;8;j++){</span>
<span class="nc" id="L5294">            OverloadInElement_[i][j]=Double.valueOf(input.next());</span>
          }
        }

        // LOAD NODES
<span class="nc" id="L5299">        txt=input.nextLine();</span>
<span class="nc bnc" id="L5300" title="All 2 branches missed.">        if(numberOfWeigthsElements_!=0){txt=input.nextLine();}</span>
<span class="nc" id="L5301">        WeightNode_ = new double[numberOfWeigthsNodes_][8];</span>
<span class="nc bnc" id="L5302" title="All 2 branches missed.">        for (i=0;i&lt;numberOfWeigthsNodes_;i++){</span>
<span class="nc" id="L5303">          txt=input.next();</span>
<span class="nc bnc" id="L5304" title="All 2 branches missed.">          for (j=0;j&lt;8;j++){</span>
<span class="nc" id="L5305">            WeightNode_[i][j]=Double.valueOf(input.next());</span>
          }
        }

        // CHECK NODE FOR DISPLACEMENT (CONSTRAINT)
<span class="nc" id="L5310">        txt=input.nextLine();</span>
<span class="nc" id="L5311">        txt=input.nextLine();</span>
<span class="nc" id="L5312">        txt=input.nextLine();</span>
<span class="nc" id="L5313">        txt=input.nextLine();</span>
<span class="nc bnc" id="L5314" title="All 2 branches missed.">        if(numberOfWeigthsNodes_!=0){txt=input.nextLine();}</span>
<span class="nc" id="L5315">        nodeCheck_ = new double[numberOfConstraintsNodes_][2];</span>
<span class="nc bnc" id="L5316" title="All 2 branches missed.">        for (i=0;i&lt;numberOfConstraintsNodes_;i++){</span>
<span class="nc" id="L5317">          nodeCheck_[i][0]=Double.valueOf(input.next());</span>
<span class="nc" id="L5318">          nodeCheck_[i][1]=Double.valueOf(input.next());</span>
        }

        //number of groups to check geometry
<span class="nc" id="L5322">        txt=input.nextLine();</span>
<span class="nc" id="L5323">        txt=input.nextLine();</span>
<span class="nc bnc" id="L5324" title="All 2 branches missed.">        if(numberOfGroupsToCheckGeometry_!=0) {</span>
<span class="nc" id="L5325">          geometryCheck_ = new int[numberOfGroupsToCheckGeometry_][];</span>
          //txt = input.nextLine();
<span class="nc bnc" id="L5327" title="All 2 branches missed.">          for (i = 0; i &lt; numberOfGroupsToCheckGeometry_; i++) {</span>
<span class="nc" id="L5328">            txt = input.nextLine();</span>
<span class="nc" id="L5329">            geometryCheck_[i] = new int[(txt.length() + 1) / 2];</span>
<span class="nc" id="L5330">            String aTxt[] = txt.split(&quot; &quot;);</span>
<span class="nc" id="L5331">            int k = 0;</span>
<span class="nc bnc" id="L5332" title="All 2 branches missed.">            for (j = 0; j &lt; aTxt.length; j++) {</span>
<span class="nc bnc" id="L5333" title="All 2 branches missed.">              if (aTxt[j] != &quot; &quot;) {</span>
<span class="nc" id="L5334">                geometryCheck_[i][k] =  Integer.parseInt(aTxt[j]);</span>
<span class="nc" id="L5335">                k++;</span>
              }
            }
          }
        }
<span class="nc bnc" id="L5340" title="All 2 branches missed.">        while(input.hasNext()){</span>
<span class="nc" id="L5341">          txt=input.nextLine();</span>
        }
      }

      // clse the file
<span class="nc" id="L5346">      input.close();</span>
    }
<span class="nc" id="L5348">    catch (Exception ex) {</span>
<span class="nc" id="L5349">      System.out.println(&quot;Error: data file EBEs not readed&quot;);</span>
<span class="nc" id="L5350">      System.out.println(ex.getMessage());</span>
<span class="nc" id="L5351">      System.exit(1);</span>
<span class="nc" id="L5352">    }</span>
<span class="nc" id="L5353">  }</span>

  public int Variable_Position() {
<span class="nc" id="L5356">    int numberOfVariables_ = 0;</span>
    try{
<span class="nc" id="L5358">      numberOfConstraintsGeometric_ = 0;</span>
<span class="nc bnc" id="L5359" title="All 2 branches missed.">      for (int gr = 0; gr &lt; numberOfGroupElements_; gr++) {</span>
<span class="nc bnc" id="L5360" title="All 2 branches missed.">        if (Groups_[gr][SHAPE] == CIRCLE) {</span>
          // variables
<span class="nc" id="L5362">          numberOfVariables_ += 1;</span>
<span class="nc" id="L5363">          Groups_[gr][VARIABLES] = 1;</span>
<span class="nc" id="L5364">          Groups_[gr][VAR_POSITION] = numberOfVariables_ - 1;</span>
          // constrain
<span class="nc" id="L5366">          numberOfConstraintsGeometric_ += 0;</span>
<span class="nc" id="L5367">          Groups_[gr][CONSTRAINT]=0;</span>

<span class="nc bnc" id="L5369" title="All 2 branches missed.">        } else if (Groups_[gr][SHAPE] == HOLE_CIRCLE) {</span>
          // variables
<span class="nc" id="L5371">          numberOfVariables_ += 2;</span>
<span class="nc" id="L5372">          Groups_[gr][VARIABLES] = 2;</span>
<span class="nc" id="L5373">          Groups_[gr][VAR_POSITION] = numberOfVariables_ - 2;</span>
          // constrain
<span class="nc" id="L5375">          numberOfConstraintsGeometric_ += 2;</span>
<span class="nc" id="L5376">          Groups_[gr][CONSTRAINT]=2;</span>

<span class="nc bnc" id="L5378" title="All 2 branches missed.">        } else if (Groups_[gr][SHAPE] == RECTANGLE) {</span>
          // variables
<span class="nc" id="L5380">          numberOfVariables_ += 2;</span>
<span class="nc" id="L5381">          Groups_[gr][VARIABLES] = 2;</span>
<span class="nc" id="L5382">          Groups_[gr][VAR_POSITION] = numberOfVariables_ - 2;</span>
          // constrain
<span class="nc" id="L5384">          numberOfConstraintsGeometric_ += 2;</span>
<span class="nc" id="L5385">          Groups_[gr][CONSTRAINT]=2;</span>

<span class="nc bnc" id="L5387" title="All 2 branches missed.">        } else if (Groups_[gr][SHAPE] == HOLE_RECTANGLE) {</span>
          // variable
<span class="nc" id="L5389">          numberOfVariables_ += 4;</span>
<span class="nc" id="L5390">          Groups_[gr][VARIABLES] = 4;</span>
<span class="nc" id="L5391">          Groups_[gr][VAR_POSITION] = numberOfVariables_ - 4;</span>
          // constrain
<span class="nc" id="L5393">          numberOfConstraintsGeometric_ += 4;</span>
<span class="nc" id="L5394">          Groups_[gr][CONSTRAINT]=4;</span>

<span class="nc bnc" id="L5396" title="All 2 branches missed.">        } else if (Groups_[gr][SHAPE] == I_SINGLE) {</span>
          // variable
<span class="nc" id="L5398">          numberOfVariables_ += 4;</span>
<span class="nc" id="L5399">          Groups_[gr][VARIABLES] = 4;</span>
<span class="nc" id="L5400">          Groups_[gr][VAR_POSITION] = numberOfVariables_ - 4;</span>
          // constrain
<span class="nc" id="L5402">          numberOfConstraintsGeometric_ += 4;</span>
<span class="nc" id="L5403">          Groups_[gr][CONSTRAINT]=4;</span>

<span class="nc bnc" id="L5405" title="All 2 branches missed.">        } else if (Groups_[gr][SHAPE] == I_DOUBLE) {</span>
          // variable
<span class="nc" id="L5407">          numberOfVariables_ += 4;</span>
<span class="nc" id="L5408">          Groups_[gr][VARIABLES] = 4;</span>
<span class="nc" id="L5409">          Groups_[gr][VAR_POSITION] = numberOfVariables_ - 4;</span>
          // constrain
<span class="nc" id="L5411">          numberOfConstraintsGeometric_ += 4;</span>
<span class="nc" id="L5412">          Groups_[gr][CONSTRAINT]=4;</span>

<span class="nc bnc" id="L5414" title="All 2 branches missed.">        } else if (Groups_[gr][SHAPE] == H_SINGLE) {</span>
          // variables
<span class="nc" id="L5416">          numberOfVariables_ += 4;</span>
<span class="nc" id="L5417">          Groups_[gr][VARIABLES] = 4;</span>
<span class="nc" id="L5418">          Groups_[gr][VAR_POSITION] = numberOfVariables_ - 4;</span>
          // constrain
<span class="nc" id="L5420">          numberOfConstraintsGeometric_ += 4;</span>
<span class="nc" id="L5421">          Groups_[gr][CONSTRAINT]=4;</span>

<span class="nc bnc" id="L5423" title="All 2 branches missed.">        } else if (Groups_[gr][SHAPE] == H_DOUBLE) {</span>
          // variable
<span class="nc" id="L5425">          numberOfVariables_ += 4;</span>
<span class="nc" id="L5426">          Groups_[gr][VARIABLES] = 4;</span>
<span class="nc" id="L5427">          Groups_[gr][VAR_POSITION] = numberOfVariables_ - 4;</span>
          // constrain
<span class="nc" id="L5429">          numberOfConstraintsGeometric_ += 4;</span>
<span class="nc" id="L5430">          Groups_[gr][CONSTRAINT]=4;</span>

<span class="nc bnc" id="L5432" title="All 2 branches missed.">        } else if (Groups_[gr][SHAPE] == L_SINGLE) {</span>
          // variable
<span class="nc" id="L5434">          numberOfVariables_ += 4;</span>
<span class="nc" id="L5435">          Groups_[gr][VARIABLES] = 4;</span>
<span class="nc" id="L5436">          Groups_[gr][VAR_POSITION] = numberOfVariables_ - 4;</span>
          // constrain
<span class="nc" id="L5438">          numberOfConstraintsGeometric_ += 4;</span>
<span class="nc" id="L5439">          Groups_[gr][CONSTRAINT]=4;</span>

<span class="nc bnc" id="L5441" title="All 2 branches missed.">        } else if (Groups_[gr][SHAPE] == L_DOUBLE) {</span>
          // variable
<span class="nc" id="L5443">          numberOfVariables_ += 4;</span>
<span class="nc" id="L5444">          Groups_[gr][VARIABLES] = 4;</span>
<span class="nc" id="L5445">          Groups_[gr][VAR_POSITION] = numberOfVariables_ - 4;</span>
          // constrain
<span class="nc" id="L5447">          numberOfConstraintsGeometric_ += 4;</span>
<span class="nc" id="L5448">          Groups_[gr][CONSTRAINT]=4;</span>

<span class="nc bnc" id="L5450" title="All 2 branches missed.">        } else if (Groups_[gr][SHAPE] == T_SINGLE) {</span>
          // variable
<span class="nc" id="L5452">          numberOfVariables_ += 4;</span>
<span class="nc" id="L5453">          Groups_[gr][VARIABLES] = 4;</span>
<span class="nc" id="L5454">          Groups_[gr][VAR_POSITION] = numberOfVariables_ - 4;</span>
          // constrain
<span class="nc" id="L5456">          numberOfConstraintsGeometric_ += 4;</span>
<span class="nc" id="L5457">          Groups_[gr][CONSTRAINT]=4;</span>

<span class="nc bnc" id="L5459" title="All 2 branches missed.">        } else if (Groups_[gr][SHAPE] == T_DOUBLE) {</span>
          // variale
<span class="nc" id="L5461">          numberOfVariables_ += 4;</span>
<span class="nc" id="L5462">          Groups_[gr][VARIABLES] = 4;</span>
<span class="nc" id="L5463">          Groups_[gr][VAR_POSITION] = numberOfVariables_ - 4;</span>
          // constrain
<span class="nc" id="L5465">          numberOfConstraintsGeometric_ += 4;</span>
<span class="nc" id="L5466">          Groups_[gr][CONSTRAINT]=4;</span>

        } else {
<span class="nc" id="L5469">          System.out.println(&quot;Error: transversal section not considerated in &quot; + gr + &quot; group&quot;);</span>
<span class="nc" id="L5470">          System.exit(1);</span>
        } // end if
      } // gr
    }
<span class="nc" id="L5474">    catch (Exception ex) {</span>
<span class="nc" id="L5475">      System.out.println(ex.getCause());</span>
<span class="nc" id="L5476">      System.out.println(ex.getMessage());</span>
<span class="nc" id="L5477">      System.exit(1);</span>
<span class="nc" id="L5478">    }</span>

<span class="nc" id="L5480">    return numberOfVariables_ ;</span>
  }

  public double FunctionENS( int hi)
  {
    // function Efficiency Nash-Sutcliffe
    // O[k] : k-th data value of matirial stress (observed)
    // E[k] : k-th estimated value of the stress
<span class="nc" id="L5488">    double SSRes = 0.0;</span>
<span class="nc" id="L5489">    double SSTot = 0.0;</span>
<span class="nc" id="L5490">    double ENS = 0.0;</span>
<span class="nc" id="L5491">    double mOmax = 0.0;</span>
<span class="nc" id="L5492">    double mOmin = 0.0;</span>

    // [0][hi] residual strain axial
    // [1][hi] residual strain transversal


<span class="nc bnc" id="L5498" title="All 2 branches missed.">    for (int i = 0; i &lt; geometryCheck_.length; i++)</span>
    {
<span class="nc" id="L5500">      double[] Omax = new double [geometryCheck_[i].length];</span>
<span class="nc" id="L5501">      double[] Omin = new double [geometryCheck_[i].length];</span>
<span class="nc" id="L5502">      double[] Emax = new double [geometryCheck_[i].length];</span>
<span class="nc" id="L5503">      double[] Emin = new double [geometryCheck_[i].length];</span>

<span class="nc bnc" id="L5505" title="All 2 branches missed.">      for (int j = 0; j &lt; geometryCheck_[i].length; j++) {</span>
<span class="nc" id="L5506">        int gr = geometryCheck_[i][j];</span>

<span class="nc" id="L5508">        Emin[j] = StrainMin_[gr][hi];</span>
<span class="nc" id="L5509">        Omin[j] = Groups_[(int) Element_[gr][INDEX_]][COMPRESSION];</span>

<span class="nc" id="L5511">        Emax[j] = StrainMax_[gr][hi];</span>
<span class="nc" id="L5512">        Omax[j] = Groups_[(int)Element_[gr][INDEX_]][STRESS];</span>

<span class="nc" id="L5514">        mOmax += (Omax[j]);</span>
<span class="nc" id="L5515">        mOmin += (Omin[j]);</span>
      }

      //mean of the observed data
<span class="nc" id="L5519">      mOmax = 2 * mOmax / Omax.length;</span>
<span class="nc" id="L5520">      mOmin = 2 * mOmin / Omin.length;</span>

<span class="nc bnc" id="L5522" title="All 2 branches missed.">      for (int k = 0; k &lt; Omax.length; k++)</span>
      {
        //Sum of Squares of Residuals, also called the residual sum of squares
<span class="nc" id="L5525">        SSRes += Math.pow((Omin[k] - Emin[k]), 2.0) + Math.pow((Omax[k] - Emax[k]), 2.0);</span>
        //Total Sum of Squares (proportional to the sample variance)
<span class="nc" id="L5527">        SSTot +=  Math.pow((Omin[k] - mOmin), 2.0) + Math.pow((Omax[k] - mOmax), 2.0);</span>
      }

<span class="nc" id="L5530">      ENS += SSRes / SSTot;</span>

    }


<span class="nc" id="L5535">    return ENS;</span>
  }

  public double FunctionsMahalanobis_Distance_With_Variance(int hi) {
    // Mahalanobis Distance With Variance for estimated value respect to estimated data

<span class="nc" id="L5541">    double MD = 0.0; // mahalanobis distance</span>
<span class="nc" id="L5542">    double[] MDi = new double [geometryCheck_.length]; // mahalanobis distance</span>

<span class="nc bnc" id="L5544" title="All 2 branches missed.">    for (int i = 0; i &lt; geometryCheck_.length; i++)</span>
    {
<span class="nc" id="L5546">      int N = geometryCheck_[i].length;</span>
<span class="nc" id="L5547">      double[] distY = new double[N];</span>
<span class="nc" id="L5548">      double[] distZ = new double[N];</span>
<span class="nc" id="L5549">      double sumY = 0.0; //</span>
<span class="nc" id="L5550">      double sumZ = 0.0; //</span>
<span class="nc" id="L5551">      double sumYxY = 0.0; //</span>
<span class="nc" id="L5552">      double sumZxZ = 0.0; //</span>
<span class="nc" id="L5553">      double sumYxZ = 0.0; //</span>
<span class="nc" id="L5554">      double meanY = 0.0; // means Y distance</span>
<span class="nc" id="L5555">      double meanZ = 0.0; // means Z distance</span>
<span class="nc" id="L5556">      double S2Y = 0.0; // variance Y distance</span>
<span class="nc" id="L5557">      double S2Z = 0.0; // variance Z distance</span>
<span class="nc" id="L5558">      double SY = 0.0; // variance Y distance</span>
<span class="nc" id="L5559">      double SZ = 0.0; // variance Z distance</span>
      //double CS2 = 0.0; // covariance
<span class="nc" id="L5561">      double r = 0.0; // Pearson correlation</span>

<span class="nc bnc" id="L5563" title="All 2 branches missed.">      for (int j = 0; j &lt; geometryCheck_[i].length; j++) {</span>

<span class="nc" id="L5565">        distY[j] = Groups_[geometryCheck_[i][j]][Y_];</span>
<span class="nc" id="L5566">        distZ[j] = Groups_[geometryCheck_[i][j]][Z_];</span>

<span class="nc" id="L5568">        sumY += distY[j];</span>
<span class="nc" id="L5569">        sumZ += distZ[j];</span>
<span class="nc" id="L5570">        sumYxY += distY[j]*distY[j];</span>
<span class="nc" id="L5571">        sumZxZ += distZ[j]*distZ[j];</span>
<span class="nc" id="L5572">        sumYxZ += distY[j]*distZ[j];</span>

<span class="nc" id="L5574">        meanY += distY[j];</span>
<span class="nc" id="L5575">        meanZ += distZ[j];</span>

      }
      //mean of the observed data and values estimated
<span class="nc" id="L5579">      meanY /= N;</span>
<span class="nc" id="L5580">      meanZ /= N;</span>

      // Pearson’s correlation coefficient
<span class="nc" id="L5583">      r = (N*sumYxZ-sumY*sumZ)/(Math.sqrt((N*sumYxY-Math.pow(sumY,2.0))*(N*sumZxZ-Math.pow(sumZ,2.0))));</span>


      // variance
<span class="nc bnc" id="L5587" title="All 2 branches missed.">      for (int k = 0; k &lt; N; k++) {</span>
<span class="nc" id="L5588">        S2Y += Math.pow((distY[k] - meanY), 2.0);</span>
<span class="nc" id="L5589">        S2Z += Math.pow((distZ[k] - meanZ), 2.0);</span>
      }

<span class="nc" id="L5592">      S2Y /= (N-1);</span>
<span class="nc" id="L5593">      S2Z /= (N-1);</span>
<span class="nc" id="L5594">      SY = Math.sqrt(S2Y);</span>
<span class="nc" id="L5595">      SZ = Math.sqrt(S2Z);</span>
      //CS2 /= (N-1);

      // Mahalanobis distance
<span class="nc bnc" id="L5599" title="All 2 branches missed.">      for (int k = 1; k &lt; N; k++) {</span>
<span class="nc" id="L5600">        MDi[i] += Math.pow((0-distY[k]), 2.0) / S2Y + Math.pow((0-distZ[k]), 2.0) / S2Z - 2.0*r*(0-distY[k])*(0-distZ[k])/(SY*SZ);</span>
      }

<span class="nc" id="L5603">      MDi[i] = Math.sqrt(1/(1-Math.pow(r,2.0))*MDi[i]);</span>
    }

<span class="nc bnc" id="L5606" title="All 2 branches missed.">    for (int i = 0; i &lt; geometryCheck_.length; i++) {</span>
<span class="nc" id="L5607">      MD += MDi[i];</span>
    }

<span class="nc" id="L5610">    return MD;</span>
  }

/*
  public double FunctionENS(int indx, int hi)
  {
    // function Efficiency Nash-Sutcliffe
    // O[k] : k-th data value of matirial stress (observed)
    // E[k] : k-th estimated value of the stress
    double[] O = new double [numberOfGroupElements_];
    double[] E = new double [numberOfGroupElements_];
    int k = O.length;
    double Om = 0.0;

    // [0][hi] residual strain axial
    // [1][hi] residual strain transversal

    if( indx == COMPRESSION)
    {
      // compress (-)
      for(int gr=0; gr&lt;numberOfGroupElements_; gr++)
      {
        E[gr]=StrainMin_[gr][hi];
        if(StrainMin_[gr][hi] !=0.0)
          O[gr]=Groups_[(int)Element_[gr][INDEX_]][COMPRESSION];
      }
    }
    else if ( indx == STRESS)
    {
      // stress (+)
      for(int gr=0; gr&lt;numberOfGroupElements_; gr++)
      {
        E[gr]=StrainMax_[gr][hi];
        if(StrainMax_[gr][hi] !=0.0)
          O[gr]=Groups_[(int)Element_[gr][INDEX_]][STRESS];
      }
    }
    else {
      for(int gr=0; gr&lt;numberOfGroupElements_; gr++) {
        E[gr] = StrainMin_[gr][hi];
        if (StrainMin_[gr][hi] != 0.0)
          O[gr]+= Math.abs(Groups_[(int) Element_[gr][INDEX_]][COMPRESSION]);

        E[gr]=StrainMax_[gr][hi];
        if(StrainMax_[gr][hi] !=0.0)
          O[gr]+=Math.abs(Groups_[(int)Element_[gr][INDEX_]][STRESS]);
      }
    }

    //mean of the observed data
    for(int i=0; i&lt;k;i++)
    {
      Om += O[i];
    }

    Om = Om/k;
    if ( indx == 2)
      Om *=2.0;

    double SSRes = 0.0;
    double SSTot = 0.0;
    double ENS = 0.0;
    for (int i = 0; i &lt; k; i++)
    {
      //Sum of Squares of Residuals, also called the residual sum of squares
      SSRes += Math.pow((O[i] - E[i]), 2.0);
      //Total Sum of Squares (proportional to the sample variance)
      SSTot += Math.pow((O[i] - Om), 2.0);
    }
    //ENS = Math.abs(1.0 - Math.abs(SSRes / SSTot));
    ENS = Math.abs(SSRes / SSTot);
    return ENS;
  }
  */
}


</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>